// This file is auto-generated. Do not edit!

namespace cv
{
namespace ocl
{
const char* arithm_2_mat="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics:enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics:enable\n"
"#define CV_PI   3.1415926535897932384626433832795\n"
"char round_char(double v){\n"
"char v1=(char)v;\n"
"return convert_char_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"unsigned char round_uchar(double v){\n"
"unsigned char v1=(unsigned char)v;\n"
"return convert_uchar_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"short round_short(double v){\n"
"short v1=(short)v;\n"
"return convert_short_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"unsigned short round_ushort(double v){\n"
"unsigned short v1=(unsigned short)v;\n"
"return convert_ushort_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"int round_int(double v){\n"
"int v1=(int)v;\n"
"return convert_int_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"char round2_char(double v){\n"
"char v1=(char)v;\n"
"if((v-v1)==0.5&&v1%2==0)\n"
"return v1;\n"
"else\n"
"return convert_char_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"unsigned char round2_uchar(double v){\n"
"unsigned char v1=(unsigned char)v;\n"
"if((v-v1)==0.5&&v1%2==0)\n"
"return v1;\n"
"else\n"
"return convert_uchar_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"short round2_short(double v){\n"
"short v1=(short)v;\n"
"if((v-v1)==0.5&&v1%2==0)\n"
"return v1;\n"
"else\n"
"return convert_short_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"unsigned short round2_ushort(double v){\n"
"unsigned short v1=(unsigned short)v;\n"
"if((v-v1)==0.5&&v1%2==0)\n"
"return v1;\n"
"else\n"
"return convert_ushort_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"int round2_int(double v){\n"
"int v1=(int)v;\n"
"if((v-v1)==0.5&&v1%2==0)\n"
"return v1;\n"
"else\n"
"return convert_int_sat(v+(v>=0 ? 0.5 : -0.5));\n"
"}\n"
"__kernel void arithm_op_exp_5 (int rows,int cols,int srcStep,__global float *src1Mat,\n"
"__global float * dstMat,int channels)\n"
"{\n"
"size_t x = get_global_id(0);\n"
"size_t y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"size_t idx = y * ( srcStep >> 2 ) + x;\n"
"dstMat[idx] = (float)exp((float)src1Mat[idx]);\n"
"}\n"
"}\n"
"__kernel void arithm_op_exp_6 (int rows,int cols,int srcStep,__global double *src1Mat,\n"
"__global double * dstMat,int channels)\n"
"{\n"
"size_t x = get_global_id(0);\n"
"size_t y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"size_t idx = y * ( srcStep >> 3 ) + x;\n"
"dstMat[idx] = exp(src1Mat[idx]);\n"
"}\n"
"}\n"
"__kernel void arithm_op_log_5 (int rows,int cols,int srcStep,__global float *src1Mat,\n"
"__global float * dstMat,int channels)\n"
"{\n"
"size_t x = get_global_id(0);\n"
"size_t y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"size_t idx = y * ( srcStep >> 2 ) + x;\n"
"dstMat[idx] =(float) log((float)src1Mat[idx]);\n"
"}\n"
"}\n"
"__kernel void arithm_op_log_6 (int rows,int cols,int srcStep,__global double *src1Mat,\n"
"__global double * dstMat,int channels)\n"
"{\n"
"size_t x = get_global_id(0);\n"
"size_t y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"size_t idx = y * ( srcStep >> 3 ) + x;\n"
"dstMat[idx] = log(src1Mat[idx]);\n"
"}\n"
"}\n"
;
const char* arithm_absdiff="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_absdiff_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = abs_diff(src1_data, src2_data);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_absdiff_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"ushort4 tmp_data = abs_diff(src1_data, src2_data);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_absdiff_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"short4  dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"ushort4 tmp = abs_diff(src1_data, src2_data);\n"
"short4  tmp_data = convert_short4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_absdiff_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"uint tmp = abs_diff(data1, data2);\n"
"int  tmp_data = convert_int_sat(tmp);\n"
"*((__global int *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"__kernel void arithm_absdiff_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"float tmp = fabs(data1 - data2);\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_absdiff_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"double tmp = fabs(data1-data2);\n"
"*((__global double *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_absdiff_C1_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"int4 src2_data = (int4)(src2.x, src2.x, src2.x, src2.x);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4_sat(abs_diff(convert_int4_sat(src1_data), src2_data));\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C1_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = convert_ushort2_sat(abs_diff(convert_int2_sat(src1_data), src2_data));\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C1_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp = convert_ushort2_sat(abs_diff(convert_int2_sat(src1_data), src2_data));\n"
"short2 tmp_data = convert_short2_sat(tmp);\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C1_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"uint tmp_data = abs_diff(src_data1, src_data2);\n"
"int  data = convert_int_sat(tmp_data);\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C1_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float src_data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float src_data2 = src2.x;\n"
"float dst_data  = *((__global float *)((__global char *)dst  + dst_index));\n"
"float data = fabs(src_data1 - src_data2);\n"
"*((__global float *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_absdiff_C1_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double src_data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double src2_data = src2.x;\n"
"double dst_data  = *((__global double *)((__global char *)dst  + dst_index));\n"
"double data = fabs(src_data1 - src2_data);\n"
"*((__global double *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_absdiff_C2_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"int4 src2_data = (int4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4_sat(abs_diff(convert_int4_sat(src1_data), src2_data));\n"
"data.xy = (dst_index + 0 >= dst_start) ? tmp_data.xy : data.xy;\n"
"data.zw = (dst_index + 2 <  dst_end  ) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C2_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"ushort2 data = convert_ushort2_sat( abs_diff(convert_int2_sat(src_data1), src_data2));\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C2_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"ushort2 tmp = convert_ushort2_sat(abs_diff(convert_int2_sat(src_data1), src_data2));\n"
"short2 data = convert_short2_sat(tmp);\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C2_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = convert_int2_sat(abs_diff(src_data1, src_data2));\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C2_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"float2 src_data1 = *((__global float2 *)((__global char *)src1 + src1_index));\n"
"float2 src_data2 = (float2)(src2.x, src2.y);\n"
"float2 dst_data  = *((__global float2 *)((__global char *)dst  + dst_index));\n"
"float2 data = fabs(src_data1 - src_data2);\n"
"*((__global float2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_absdiff_C2_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"double2 src_data1 = *((__global double2 *)((__global char *)src1 + src1_index));\n"
"double2 src_data2 = (double2)(src2.x, src2.y);\n"
"double2 dst_data  = *((__global double2 *)((__global char *)dst  + dst_index));\n"
"double2 data = fabs(src_data1 - src_data2);\n"
"*((__global double2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_absdiff_C3_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"int4 src2_data_0 = (int4)(src2.x, src2.y, src2.z, src2.x);\n"
"int4 src2_data_1 = (int4)(src2.y, src2.z, src2.x, src2.y);\n"
"int4 src2_data_2 = (int4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = convert_uchar4_sat(abs_diff(convert_int4_sat(src1_data_0), src2_data_0));\n"
"uchar4 tmp_data_1 = convert_uchar4_sat(abs_diff(convert_int4_sat(src1_data_1), src2_data_1));\n"
"uchar4 tmp_data_2 = convert_uchar4_sat(abs_diff(convert_int4_sat(src1_data_2), src2_data_2));\n"
"data_0.xyz = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C3_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = convert_ushort2_sat(abs_diff(convert_int2_sat(src1_data_0), src2_data_0));\n"
"ushort2 tmp_data_1 = convert_ushort2_sat(abs_diff(convert_int2_sat(src1_data_1), src2_data_1));\n"
"ushort2 tmp_data_2 = convert_ushort2_sat(abs_diff(convert_int2_sat(src1_data_2), src2_data_2));\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C3_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = convert_short2_sat(abs_diff(convert_int2_sat(src1_data_0), src2_data_0));\n"
"short2 tmp_data_1 = convert_short2_sat(abs_diff(convert_int2_sat(src1_data_1), src2_data_1));\n"
"short2 tmp_data_2 = convert_short2_sat(abs_diff(convert_int2_sat(src1_data_2), src2_data_2));\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C3_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = convert_int_sat(abs_diff(src1_data_0, src2_data_0));\n"
"int tmp_data_1 = convert_int_sat(abs_diff(src1_data_1, src2_data_1));\n"
"int tmp_data_2 = convert_int_sat(abs_diff(src1_data_2, src2_data_2));\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C3_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"float src1_data_0 = *((__global float *)((__global char *)src1 + src1_index + 0));\n"
"float src1_data_1 = *((__global float *)((__global char *)src1 + src1_index + 4));\n"
"float src1_data_2 = *((__global float *)((__global char *)src1 + src1_index + 8));\n"
"float src2_data_0 = src2.x;\n"
"float src2_data_1 = src2.y;\n"
"float src2_data_2 = src2.z;\n"
"float data_0 = *((__global float *)((__global char *)dst + dst_index + 0));\n"
"float data_1 = *((__global float *)((__global char *)dst + dst_index + 4));\n"
"float data_2 = *((__global float *)((__global char *)dst + dst_index + 8));\n"
"float tmp_data_0 = fabs(src1_data_0 - src2_data_0);\n"
"float tmp_data_1 = fabs(src1_data_1 - src2_data_1);\n"
"float tmp_data_2 = fabs(src1_data_2 - src2_data_2);\n"
"*((__global float *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global float *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global float *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_absdiff_C3_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"double src1_data_0 = *((__global double *)((__global char *)src1 + src1_index + 0 ));\n"
"double src1_data_1 = *((__global double *)((__global char *)src1 + src1_index + 8 ));\n"
"double src1_data_2 = *((__global double *)((__global char *)src1 + src1_index + 16));\n"
"double src2_data_0 = src2.x;\n"
"double src2_data_1 = src2.y;\n"
"double src2_data_2 = src2.z;\n"
"double data_0 = *((__global double *)((__global char *)dst + dst_index + 0 ));\n"
"double data_1 = *((__global double *)((__global char *)dst + dst_index + 8 ));\n"
"double data_2 = *((__global double *)((__global char *)dst + dst_index + 16));\n"
"double tmp_data_0 = fabs(src1_data_0 - src2_data_0);\n"
"double tmp_data_1 = fabs(src1_data_1 - src2_data_1);\n"
"double tmp_data_2 = fabs(src1_data_2 - src2_data_2);\n"
"*((__global double *)((__global char *)dst + dst_index + 0 ))= tmp_data_0;\n"
"*((__global double *)((__global char *)dst + dst_index + 8 ))= tmp_data_1;\n"
"*((__global double *)((__global char *)dst + dst_index + 16))= tmp_data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_absdiff_C4_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 data = convert_uchar4_sat(abs_diff(convert_int4_sat(src_data1), src2));\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C4_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 data = convert_ushort4_sat(abs_diff(convert_int4_sat(src_data1), src2));\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C4_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 data = convert_short4_sat(abs_diff(convert_int4_sat(src_data1), src2));\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C4_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 data = convert_int4_sat(abs_diff(src_data1, src2));\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_absdiff_C4_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"float4 src_data1 = *((__global float4 *)((__global char *)src1 + src1_index));\n"
"float4 data = fabs(src_data1 - src2);\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_absdiff_C4_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"double4 src_data1 = *((__global double4 *)((__global char *)src1 + src1_index));\n"
"double4 data = fabs(src_data1 - src2);\n"
"*((__global double4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_add="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_add_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"short4 tmp      = convert_short4_sat(src1_data) + convert_short4_sat(src2_data);\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"int4    tmp = convert_int4_sat(src1_data) + convert_int4_sat(src2_data);\n"
"ushort4 tmp_data = convert_ushort4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"int4   tmp = convert_int4_sat(src1_data) + convert_int4_sat(src2_data);\n"
"short4 tmp_data = convert_short4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"long tmp  = (long)(data1) + (long)(data2);\n"
"*((__global int *)((__global char *)dst + dst_index)) = convert_int_sat(tmp);\n"
"}\n"
"}\n"
"__kernel void arithm_add_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"float tmp = data1 + data2;\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_add_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"*((__global double *)((__global char *)dst + dst_index)) = data1 + data2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_add_with_mask_C1_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"int mask_index_fix = mask_index < 0 ? 0 : mask_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"uchar4 mask_data = vload4(0, mask + mask_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(mask_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (mask_index == -2) ? mask_data.zwxy:mask_data.yzwx;\n"
"mask_data.xyzw = (mask_index == -1) ? mask_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"short4 tmp = convert_short4_sat(src1_data) + convert_short4_sat(src2_data);\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C1_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = vload2(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) + convert_int2_sat(src2_data);\n"
"ushort2 tmp_data = convert_ushort2_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C1_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = vload2(0, (__global short *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) + convert_int2_sat(src2_data);\n"
"short2 tmp_data = convert_short2_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C1_D4 (__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = convert_int_sat((long)src_data1 + (long)src_data2);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C1_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float src_data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float src_data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"float dst_data  = *((__global float *)((__global char *)dst  + dst_index));\n"
"float data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_add_with_mask_C1_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double src_data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double src_data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"double dst_data  = *((__global double *)((__global char *)dst  + dst_index));\n"
"double data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_add_with_mask_C2_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"short4   tmp = convert_short4_sat(src1_data) + convert_short4_sat(src2_data);\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C2_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = *((__global ushort2 *)((__global char *)src2 + src2_index));\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) + convert_int2_sat(src_data2);\n"
"ushort2 data = convert_ushort2_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C2_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = *((__global short2 *)((__global char *)src2 + src2_index));\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) + convert_int2_sat(src_data2);\n"
"short2 data = convert_short2_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C2_D4 (__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int    *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = *((__global int2 *)((__global char *)src2 + src2_index));\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = convert_int2_sat(convert_long2_sat(src_data1) + convert_long2_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C2_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float2 src_data1 = *((__global float2 *)((__global char *)src1 + src1_index));\n"
"float2 src_data2 = *((__global float2 *)((__global char *)src2 + src2_index));\n"
"float2 dst_data  = *((__global float2 *)((__global char *)dst  + dst_index));\n"
"float2 data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_add_with_mask_C2_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double2 src_data1 = *((__global double2 *)((__global char *)src1 + src1_index));\n"
"double2 src_data2 = *((__global double2 *)((__global char *)src2 + src2_index));\n"
"double2 dst_data  = *((__global double2 *)((__global char *)dst  + dst_index));\n"
"double2 data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_add_with_mask_C3_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int src2_index = mad24(y, src2_step, (x * 3) + src2_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = vload4(0, src2 + src2_index + 0);\n"
"uchar4 src2_data_1 = vload4(0, src2 + src2_index + 4);\n"
"uchar4 src2_data_2 = vload4(0, src2 + src2_index + 8);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = convert_uchar4_sat(convert_short4_sat(src1_data_0) + convert_short4_sat(src2_data_0));\n"
"uchar4 tmp_data_1 = convert_uchar4_sat(convert_short4_sat(src1_data_1) + convert_short4_sat(src2_data_1));\n"
"uchar4 tmp_data_2 = convert_uchar4_sat(convert_short4_sat(src1_data_2) + convert_short4_sat(src2_data_2));\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C3_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 0));\n"
"ushort2 src2_data_1 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 4));\n"
"ushort2 src2_data_2 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = convert_ushort2_sat(convert_int2_sat(src1_data_0) + convert_int2_sat(src2_data_0));\n"
"ushort2 tmp_data_1 = convert_ushort2_sat(convert_int2_sat(src1_data_1) + convert_int2_sat(src2_data_1));\n"
"ushort2 tmp_data_2 = convert_ushort2_sat(convert_int2_sat(src1_data_2) + convert_int2_sat(src2_data_2));\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C3_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 0));\n"
"short2 src2_data_1 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 4));\n"
"short2 src2_data_2 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = convert_short2_sat(convert_int2_sat(src1_data_0) + convert_int2_sat(src2_data_0));\n"
"short2 tmp_data_1 = convert_short2_sat(convert_int2_sat(src1_data_1) + convert_int2_sat(src2_data_1));\n"
"short2 tmp_data_2 = convert_short2_sat(convert_int2_sat(src1_data_2) + convert_int2_sat(src2_data_2));\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C3_D4 (__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = *((__global int *)((__global char *)src2 + src2_index + 0));\n"
"int src2_data_1 = *((__global int *)((__global char *)src2 + src2_index + 4));\n"
"int src2_data_2 = *((__global int *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = convert_int_sat((long)src1_data_0 + (long)src2_data_0);\n"
"int tmp_data_1 = convert_int_sat((long)src1_data_1 + (long)src2_data_1);\n"
"int tmp_data_2 = convert_int_sat((long)src1_data_2 + (long)src2_data_2);\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C3_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"float src1_data_0 = *((__global float *)((__global char *)src1 + src1_index + 0));\n"
"float src1_data_1 = *((__global float *)((__global char *)src1 + src1_index + 4));\n"
"float src1_data_2 = *((__global float *)((__global char *)src1 + src1_index + 8));\n"
"float src2_data_0 = *((__global float *)((__global char *)src2 + src2_index + 0));\n"
"float src2_data_1 = *((__global float *)((__global char *)src2 + src2_index + 4));\n"
"float src2_data_2 = *((__global float *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"float data_0 = *((__global float *)((__global char *)dst + dst_index + 0));\n"
"float data_1 = *((__global float *)((__global char *)dst + dst_index + 4));\n"
"float data_2 = *((__global float *)((__global char *)dst + dst_index + 8));\n"
"float tmp_data_0 = src1_data_0 + src2_data_0;\n"
"float tmp_data_1 = src1_data_1 + src2_data_1;\n"
"float tmp_data_2 = src1_data_2 + src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global float *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global float *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global float *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_add_with_mask_C3_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 24) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"double src1_data_0 = *((__global double *)((__global char *)src1 + src1_index + 0 ));\n"
"double src1_data_1 = *((__global double *)((__global char *)src1 + src1_index + 8 ));\n"
"double src1_data_2 = *((__global double *)((__global char *)src1 + src1_index + 16));\n"
"double src2_data_0 = *((__global double *)((__global char *)src2 + src2_index + 0 ));\n"
"double src2_data_1 = *((__global double *)((__global char *)src2 + src2_index + 8 ));\n"
"double src2_data_2 = *((__global double *)((__global char *)src2 + src2_index + 16));\n"
"uchar mask_data = * (mask + mask_index);\n"
"double data_0 = *((__global double *)((__global char *)dst + dst_index + 0 ));\n"
"double data_1 = *((__global double *)((__global char *)dst + dst_index + 8 ));\n"
"double data_2 = *((__global double *)((__global char *)dst + dst_index + 16));\n"
"double tmp_data_0 = src1_data_0 + src2_data_0;\n"
"double tmp_data_1 = src1_data_1 + src2_data_1;\n"
"double tmp_data_2 = src1_data_2 + src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global double *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global double *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global double *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_add_with_mask_C4_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 src_data2 = *((__global uchar4 *)(src2 + src2_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 data = convert_uchar4_sat(convert_ushort4_sat(src_data1) + convert_ushort4_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C4_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 src_data2 = *((__global ushort4 *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"ushort4 data = convert_ushort4_sat(convert_int4_sat(src_data1) + convert_int4_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C4_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src_data2 = *((__global short4 *)((__global char *)src2 + src2_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = convert_short4_sat(convert_int4_sat(src_data1) + convert_int4_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C4_D4 (__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 src_data2 = *((__global int4 *)((__global char *)src2 + src2_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"int4 data = convert_int4_sat(convert_long4_sat(src_data1) + convert_long4_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_add_with_mask_C4_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float4 src_data1 = *((__global float4 *)((__global char *)src1 + src1_index));\n"
"float4 src_data2 = *((__global float4 *)((__global char *)src2 + src2_index));\n"
"float4 dst_data  = *((__global float4 *)((__global char *)dst  + dst_index));\n"
"float4 data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_add_with_mask_C4_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 5) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double4 src_data1 = *((__global double4 *)((__global char *)src1 + src1_index));\n"
"double4 src_data2 = *((__global double4 *)((__global char *)src2 + src2_index));\n"
"double4 dst_data  = *((__global double4 *)((__global char *)dst  + dst_index));\n"
"double4 data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_add_scalar="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_s_add_C1_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"int4 src2_data = (int4)(src2.x, src2.x, src2.x, src2.x);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"int4 tmp = convert_int4_sat(src1_data) + src2_data;\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C1_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) + src2_data;\n"
"ushort2 tmp_data = convert_ushort2_sat(tmp);\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C1_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) + src2_data;\n"
"short2 tmp_data = convert_short2_sat(tmp);\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C1_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = convert_int_sat((long)src_data1 + (long)src_data2);\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C1_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float src_data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float src_data2 = src2.x;\n"
"float dst_data  = *((__global float *)((__global char *)dst  + dst_index));\n"
"float data = src_data1 + src_data2;\n"
"*((__global float *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_add_C1_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double src_data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double src2_data = src2.x;\n"
"double dst_data  = *((__global double *)((__global char *)dst  + dst_index));\n"
"double data = src_data1 + src2_data;\n"
"*((__global double *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_add_C2_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"int4 src2_data = (int4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"int4 tmp = convert_int4_sat(src1_data) + src2_data;\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.xy = (dst_index + 0 >= dst_start) ? tmp_data.xy : data.xy;\n"
"data.zw = (dst_index + 2 <  dst_end  ) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C2_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) + src_data2;\n"
"ushort2 data = convert_ushort2_sat(tmp);\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C2_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) + src_data2;\n"
"short2 data = convert_short2_sat(tmp);\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C2_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = convert_int2_sat(convert_long2_sat(src_data1) + convert_long2_sat(src_data2));\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C2_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"float2 src_data1 = *((__global float2 *)((__global char *)src1 + src1_index));\n"
"float2 src_data2 = (float2)(src2.x, src2.y);\n"
"float2 dst_data  = *((__global float2 *)((__global char *)dst  + dst_index));\n"
"float2 data = src_data1 + src_data2;\n"
"*((__global float2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_add_C2_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"double2 src_data1 = *((__global double2 *)((__global char *)src1 + src1_index));\n"
"double2 src_data2 = (double2)(src2.x, src2.y);\n"
"double2 dst_data  = *((__global double2 *)((__global char *)dst  + dst_index));\n"
"double2 data = src_data1 + src_data2;\n"
"*((__global double2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_add_C3_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"int4 src2_data_0 = (int4)(src2.x, src2.y, src2.z, src2.x);\n"
"int4 src2_data_1 = (int4)(src2.y, src2.z, src2.x, src2.y);\n"
"int4 src2_data_2 = (int4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = convert_uchar4_sat(convert_int4_sat(src1_data_0) + src2_data_0);\n"
"uchar4 tmp_data_1 = convert_uchar4_sat(convert_int4_sat(src1_data_1) + src2_data_1);\n"
"uchar4 tmp_data_2 = convert_uchar4_sat(convert_int4_sat(src1_data_2) + src2_data_2);\n"
"data_0.xyz = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C3_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = convert_ushort2_sat(convert_int2_sat(src1_data_0) + src2_data_0);\n"
"ushort2 tmp_data_1 = convert_ushort2_sat(convert_int2_sat(src1_data_1) + src2_data_1);\n"
"ushort2 tmp_data_2 = convert_ushort2_sat(convert_int2_sat(src1_data_2) + src2_data_2);\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C3_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = convert_short2_sat(convert_int2_sat(src1_data_0) + src2_data_0);\n"
"short2 tmp_data_1 = convert_short2_sat(convert_int2_sat(src1_data_1) + src2_data_1);\n"
"short2 tmp_data_2 = convert_short2_sat(convert_int2_sat(src1_data_2) + src2_data_2);\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C3_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = convert_int_sat((long)src1_data_0 + (long)src2_data_0);\n"
"int tmp_data_1 = convert_int_sat((long)src1_data_1 + (long)src2_data_1);\n"
"int tmp_data_2 = convert_int_sat((long)src1_data_2 + (long)src2_data_2);\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C3_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"float src1_data_0 = *((__global float *)((__global char *)src1 + src1_index + 0));\n"
"float src1_data_1 = *((__global float *)((__global char *)src1 + src1_index + 4));\n"
"float src1_data_2 = *((__global float *)((__global char *)src1 + src1_index + 8));\n"
"float src2_data_0 = src2.x;\n"
"float src2_data_1 = src2.y;\n"
"float src2_data_2 = src2.z;\n"
"float data_0 = *((__global float *)((__global char *)dst + dst_index + 0));\n"
"float data_1 = *((__global float *)((__global char *)dst + dst_index + 4));\n"
"float data_2 = *((__global float *)((__global char *)dst + dst_index + 8));\n"
"float tmp_data_0 = src1_data_0 + src2_data_0;\n"
"float tmp_data_1 = src1_data_1 + src2_data_1;\n"
"float tmp_data_2 = src1_data_2 + src2_data_2;\n"
"*((__global float *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global float *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global float *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_add_C3_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"double src1_data_0 = *((__global double *)((__global char *)src1 + src1_index + 0 ));\n"
"double src1_data_1 = *((__global double *)((__global char *)src1 + src1_index + 8 ));\n"
"double src1_data_2 = *((__global double *)((__global char *)src1 + src1_index + 16));\n"
"double src2_data_0 = src2.x;\n"
"double src2_data_1 = src2.y;\n"
"double src2_data_2 = src2.z;\n"
"double data_0 = *((__global double *)((__global char *)dst + dst_index + 0 ));\n"
"double data_1 = *((__global double *)((__global char *)dst + dst_index + 8 ));\n"
"double data_2 = *((__global double *)((__global char *)dst + dst_index + 16));\n"
"double tmp_data_0 = src1_data_0 + src2_data_0;\n"
"double tmp_data_1 = src1_data_1 + src2_data_1;\n"
"double tmp_data_2 = src1_data_2 + src2_data_2;\n"
"*((__global double *)((__global char *)dst + dst_index + 0 ))= tmp_data_0;\n"
"*((__global double *)((__global char *)dst + dst_index + 8 ))= tmp_data_1;\n"
"*((__global double *)((__global char *)dst + dst_index + 16))= tmp_data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_add_C4_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 data = convert_uchar4_sat(convert_int4_sat(src_data1) + src2);\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C4_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 data = convert_ushort4_sat(convert_int4_sat(src_data1) + src2);\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C4_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 data = convert_short4_sat(convert_int4_sat(src_data1) + src2);\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C4_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 data = convert_int4_sat(convert_long4_sat(src_data1) + convert_long4_sat(src2));\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_C4_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"float4 src_data1 = *((__global float4 *)((__global char *)src1 + src1_index));\n"
"float4 data = src_data1 + src2;\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_add_C4_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"double4 src_data1 = *((__global double4 *)((__global char *)src1 + src1_index));\n"
"double4 data = src_data1 + src2;\n"
"*((__global double4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_add_scalar_mask="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_s_add_with_mask_C1_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int mask_index_fix = mask_index < 0 ? 0 : mask_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"int4 src2_data = (int4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 mask_data = vload4(0, mask + mask_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(mask_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (mask_index == -2) ? mask_data.zwxy:mask_data.yzwx;\n"
"mask_data.xyzw = (mask_index == -1) ? mask_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"int4 tmp = convert_int4_sat(src1_data) + src2_data;\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C1_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar  *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) + src2_data;\n"
"ushort2 tmp_data = convert_ushort2_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C1_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) + src2_data;\n"
"short2 tmp_data = convert_short2_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C1_D4 (__global   int   *src1, int src1_step, int src1_offset,\n"
"__global   int   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = convert_int_sat((long)src_data1 + (long)src_data2);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C1_D5 (__global   float   *src1, int src1_step, int src1_offset,\n"
"__global   float   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float src_data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float src_data2 = src2.x;\n"
"float dst_data  = *((__global float *)((__global char *)dst  + dst_index));\n"
"float data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_add_with_mask_C1_D6 (__global   double   *src1, int src1_step, int src1_offset,\n"
"__global   double   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double src_data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double src_data2 = src2.x;\n"
"double dst_data  = *((__global double *)((__global char *)dst  + dst_index));\n"
"double data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_add_with_mask_C2_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"int4   src2_data = (int4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"int4  tmp = convert_int4_sat(src1_data) + src2_data;\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C2_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) + src_data2;\n"
"ushort2 data = convert_ushort2_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C2_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) + src_data2;\n"
"short2 data = convert_short2_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C2_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = convert_int2_sat(convert_long2_sat(src_data1) + convert_long2_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C2_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float2 src_data1 = *((__global float2 *)((__global char *)src1 + src1_index));\n"
"float2 src_data2 = (float2)(src2.x, src2.y);\n"
"float2 dst_data  = *((__global float2 *)((__global char *)dst  + dst_index));\n"
"float2 data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_add_with_mask_C2_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double2 src_data1 = *((__global double2 *)((__global char *)src1 + src1_index));\n"
"double2 src_data2 = (double2)(src2.x, src2.y);\n"
"double2 dst_data  = *((__global double2 *)((__global char *)dst  + dst_index));\n"
"double2 data = src_data1 + src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_add_with_mask_C3_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"int4 src2_data_0 = (int4)(src2.x, src2.y, src2.z, src2.x);\n"
"int4 src2_data_1 = (int4)(src2.y, src2.z, src2.x, src2.y);\n"
"int4 src2_data_2 = (int4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = convert_uchar4_sat(convert_int4_sat(src1_data_0) + src2_data_0);\n"
"uchar4 tmp_data_1 = convert_uchar4_sat(convert_int4_sat(src1_data_1) + src2_data_1);\n"
"uchar4 tmp_data_2 = convert_uchar4_sat(convert_int4_sat(src1_data_2) + src2_data_2);\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C3_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = convert_ushort2_sat(convert_int2_sat(src1_data_0) + src2_data_0);\n"
"ushort2 tmp_data_1 = convert_ushort2_sat(convert_int2_sat(src1_data_1) + src2_data_1);\n"
"ushort2 tmp_data_2 = convert_ushort2_sat(convert_int2_sat(src1_data_2) + src2_data_2);\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C3_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = convert_short2_sat(convert_int2_sat(src1_data_0) + src2_data_0);\n"
"short2 tmp_data_1 = convert_short2_sat(convert_int2_sat(src1_data_1) + src2_data_1);\n"
"short2 tmp_data_2 = convert_short2_sat(convert_int2_sat(src1_data_2) + src2_data_2);\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C3_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = convert_int_sat((long)src1_data_0 + (long)src2_data_0);\n"
"int tmp_data_1 = convert_int_sat((long)src1_data_1 + (long)src2_data_1);\n"
"int tmp_data_2 = convert_int_sat((long)src1_data_2 + (long)src2_data_2);\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C3_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"float src1_data_0 = *((__global float *)((__global char *)src1 + src1_index + 0));\n"
"float src1_data_1 = *((__global float *)((__global char *)src1 + src1_index + 4));\n"
"float src1_data_2 = *((__global float *)((__global char *)src1 + src1_index + 8));\n"
"float src2_data_0 = src2.x;\n"
"float src2_data_1 = src2.y;\n"
"float src2_data_2 = src2.z;\n"
"uchar mask_data = * (mask + mask_index);\n"
"float data_0 = *((__global float *)((__global char *)dst + dst_index + 0));\n"
"float data_1 = *((__global float *)((__global char *)dst + dst_index + 4));\n"
"float data_2 = *((__global float *)((__global char *)dst + dst_index + 8));\n"
"float tmp_data_0 = src1_data_0 + src2_data_0;\n"
"float tmp_data_1 = src1_data_1 + src2_data_1;\n"
"float tmp_data_2 = src1_data_2 + src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global float *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global float *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global float *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_add_with_mask_C3_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar  *mask, int mask_step, int mask_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"double src1_data_0 = *((__global double *)((__global char *)src1 + src1_index + 0 ));\n"
"double src1_data_1 = *((__global double *)((__global char *)src1 + src1_index + 8 ));\n"
"double src1_data_2 = *((__global double *)((__global char *)src1 + src1_index + 16));\n"
"double src2_data_0 = src2.x;\n"
"double src2_data_1 = src2.y;\n"
"double src2_data_2 = src2.z;\n"
"uchar mask_data = * (mask + mask_index);\n"
"double data_0 = *((__global double *)((__global char *)dst + dst_index + 0 ));\n"
"double data_1 = *((__global double *)((__global char *)dst + dst_index + 8 ));\n"
"double data_2 = *((__global double *)((__global char *)dst + dst_index + 16));\n"
"double tmp_data_0 = src1_data_0 + src2_data_0;\n"
"double tmp_data_1 = src1_data_1 + src2_data_1;\n"
"double tmp_data_2 = src1_data_2 + src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global double *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global double *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global double *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_add_with_mask_C4_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 data = convert_uchar4_sat(convert_int4_sat(src_data1) + src2);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C4_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"ushort4 data = convert_ushort4_sat(convert_int4_sat(src_data1) + src2);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C4_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = convert_short4_sat(convert_int4_sat(src_data1) + src2);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C4_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"int4 data = convert_int4_sat(convert_long4_sat(src_data1) + convert_long4_sat(src2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_add_with_mask_C4_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"float4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float4 src_data1 = *((__global float4 *)((__global char *)src1 + src1_index));\n"
"float4 dst_data  = *((__global float4 *)((__global char *)dst  + dst_index));\n"
"float4 data = src_data1 + src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_add_with_mask_C4_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"double4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double4 src_data1 = *((__global double4 *)((__global char *)src1 + src1_index));\n"
"double4 dst_data  = *((__global double4 *)((__global char *)dst  + dst_index));\n"
"double4 data = src_data1 + src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_addWeighted="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"typedef double F;\n"
"#else\n"
"typedef float F;\n"
"#endif\n"
"__kernel void addWeighted_D0 (__global uchar *src1,int src1_step,int src1_offset,\n"
"__global uchar *src2, int src2_step,int src2_offset,\n"
"F alpha,F beta,F gama,\n"
"__global uchar *dst,  int dst_step,int dst_offset,\n"
"int rows,  int cols,int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data ,src2_data;\n"
"src1_data.x= src1_index+0 >= 0 ? src1[src1_index+0] : 0;\n"
"src1_data.y= src1_index+1 >= 0 ? src1[src1_index+1] : 0;\n"
"src1_data.z= src1_index+2 >= 0 ? src1[src1_index+2] : 0;\n"
"src1_data.w= src1_index+3 >= 0 ? src1[src1_index+3] : 0;\n"
"src2_data.x= src2_index+0 >= 0 ? src2[src2_index+0] : 0;\n"
"src2_data.y= src2_index+1 >= 0 ? src2[src2_index+1] : 0;\n"
"src2_data.z= src2_index+2 >= 0 ? src2[src2_index+2] : 0;\n"
"src2_data.w= src2_index+3 >= 0 ? src2[src2_index+3] : 0;\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"short4 tmp;\n"
"tmp.x = src1_data.x * alpha + src2_data.x * beta + gama;\n"
"tmp.y = src1_data.y * alpha + src2_data.y * beta + gama;\n"
"tmp.z = src1_data.z * alpha + src2_data.z * beta + gama;\n"
"tmp.w = src1_data.w * alpha + src2_data.w * beta + gama;\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void addWeighted_D2 (__global ushort *src1, int src1_step,int src1_offset,\n"
"__global ushort *src2, int src2_step,int src2_offset,\n"
"F alpha,F beta,F gama,\n"
"__global ushort *dst,  int dst_step,int dst_offset,\n"
"int rows,  int cols,int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset -( dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset -( dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset +( x<< 1) & (int)0xfffffff8);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index_fix));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"int4 tmp;\n"
"tmp.x = src1_data.x * alpha + src2_data.x * beta + gama;\n"
"tmp.y = src1_data.y * alpha + src2_data.y * beta + gama;\n"
"tmp.z = src1_data.z * alpha + src2_data.z * beta + gama;\n"
"tmp.w = src1_data.w * alpha + src2_data.w * beta + gama;\n"
"ushort4 tmp_data = convert_ushort4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void addWeighted_D3 (__global short *src1, int src1_step,int src1_offset,\n"
"__global short *src2,  int src2_step,int src2_offset,\n"
"F alpha,F beta,F gama,\n"
"__global short *dst,  int dst_step,int dst_offset,\n"
"int rows,  int cols,int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset -( dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset -( dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset +( x<< 1) - (dst_align << 1 ));\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index_fix));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"int4 tmp;\n"
"tmp.x = src1_data.x * alpha + src2_data.x * beta + gama;\n"
"tmp.y = src1_data.y * alpha + src2_data.y * beta + gama;\n"
"tmp.z = src1_data.z * alpha + src2_data.z * beta + gama;\n"
"tmp.w = src1_data.w * alpha + src2_data.w * beta + gama;\n"
"short4 tmp_data = convert_short4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void addWeighted_D4 (__global int *src1, int src1_step,int src1_offset,\n"
"__global int *src2, int src2_step,int src2_offset,\n"
"F alpha,F beta, F gama,\n"
"__global int *dst,  int dst_step,int dst_offset,\n"
"int rows,  int cols,int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define bitOfInt  (sizeof(int)== 4 ? 2: 3)\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> bitOfInt) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << bitOfInt) + src1_offset - (dst_align << bitOfInt));\n"
"int src2_index = mad24(y, src2_step, (x << bitOfInt) + src2_offset - (dst_align << bitOfInt));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << bitOfInt) -(dst_align << bitOfInt));\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"int4 src1_data = vload4(0, (__global int *)((__global char *)src1 + src1_index_fix));\n"
"int4 src2_data = vload4(0, (__global int *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"int4 dst_data = *((__global int4 *)((__global char *)dst + dst_index));\n"
"float4 tmp;\n"
"tmp.x = src1_data.x * alpha + src2_data.x * beta + gama;\n"
"tmp.y = src1_data.y * alpha + src2_data.y * beta + gama;\n"
"tmp.z = src1_data.z * alpha + src2_data.z * beta + gama;\n"
"tmp.w = src1_data.w * alpha + src2_data.w * beta + gama;\n"
"int4 tmp_data = convert_int4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 8 >= dst_start) && (dst_index + 8 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 12 >= dst_start) && (dst_index + 12 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void addWeighted_D5 (__global float *src1,int src1_step,int src1_offset,\n"
"__global float *src2, int src2_step,int src2_offset,\n"
"F alpha,F beta, F gama,\n"
"__global float *dst,  int dst_step,int dst_offset,\n"
"int rows,  int cols,int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 2) -(dst_align << 2));\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"float4 src1_data = vload4(0, (__global float  *)((__global char *)src1 + src1_index_fix));\n"
"float4 src2_data = vload4(0, (__global float *)((__global char *)src2 + src2_index_fix));\n"
"float4 dst_data = *((__global float4 *)((__global char *)dst + dst_index));\n"
"if(src1_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"float4 tmp_data;\n"
"tmp_data.x = src1_data.x * alpha + src2_data.x * beta + gama;\n"
"tmp_data.y = src1_data.y * alpha + src2_data.y * beta + gama;\n"
"tmp_data.z = src1_data.z * alpha + src2_data.z * beta + gama;\n"
"tmp_data.w = src1_data.w * alpha + src2_data.w * beta + gama;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 8 >= dst_start) && (dst_index + 8 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 12 >= dst_start) && (dst_index + 12 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void addWeighted_D6 (__global double *src1, int src1_step,int src1_offset,\n"
"__global double *src2, int src2_step,int src2_offset,\n"
"F alpha,F beta, F gama,\n"
"__global double *dst,  int dst_step,int dst_offset,\n"
"int rows,  int cols,int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 3) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset - (dst_align << 3));\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset - (dst_align << 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 3) -(dst_align << 3));\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"double4 src1_data = vload4(0, (__global double  *)((__global char *)src1 + src1_index_fix));\n"
"double4 src2_data = vload4(0, (__global double  *)((__global char *)src2 + src2_index_fix));\n"
"double4 dst_data = *((__global double4 *)((__global char *)dst + dst_index));\n"
"if(src1_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"double4 tmp_data;\n"
"tmp_data.x = src1_data.x * alpha + src2_data.x * beta + gama;\n"
"tmp_data.y = src1_data.y * alpha + src2_data.y * beta + gama;\n"
"tmp_data.z = src1_data.z * alpha + src2_data.z * beta + gama;\n"
"tmp_data.w = src1_data.w * alpha + src2_data.w * beta + gama;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 8 >= dst_start) && (dst_index + 8 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 16 >= dst_start) && (dst_index + 16 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 24 >= dst_start) && (dst_index + 24 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global double4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_and="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_bitwise_and_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data & src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_D1 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"char4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"char4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"char4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"char4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"char4 dst_data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data & src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global char4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index_fix));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"ushort4 tmp_data = src1_data & src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index_fix));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"short4 tmp_data = src1_data & src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"int tmp  = data1 & data2;\n"
"*((__global int *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_D5 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"char4 data1 = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 data2 = *((__global char4 *)((__global char *)src2 + src2_index));\n"
"char4 tmp = data1 & data2;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_and_D6 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"char8 data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 data2 = *((__global char8 *)((__global char *)src2 + src2_index));\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data1 & data2;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_and_mask="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_bitwise_and_with_mask_C1_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data & src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C1_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data & src2_data;\n"
"data.x = convert_char((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = convert_char((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = convert_char((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = convert_char((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C1_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = vload2(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = src1_data & src2_data;\n"
"data.x = convert_ushort((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = convert_ushort((mask_data.y) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C1_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = vload2(0, (__global short *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"short2 tmp_data = src1_data & src2_data;\n"
"data.x = convert_short((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = convert_short((mask_data.y) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C1_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C1_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 src_data2 = *((__global char4 *)((__global char *)src2 + src2_index));\n"
"char4 dst_data  = *((__global char4 *)((__global char *)dst  + dst_index));\n"
"char4 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C1_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src_data2 = *((__global char8 *)((__global char *)src2 + src2_index));\n"
"char8 dst_data  = *((__global char8 *)((__global char *)dst  + dst_index));\n"
"char8 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C2_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data & src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C2_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data & src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C2_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = *((__global ushort2 *)((__global char *)src2 + src2_index));\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"ushort2 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C2_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = *((__global short2 *)((__global char *)src2 + src2_index));\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"short2 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C2_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int    *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = *((__global int2 *)((__global char *)src2 + src2_index));\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C2_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src_data2 = *((__global char8 *)((__global char *)src2 + src2_index));\n"
"char8 dst_data  = *((__global char8 *)((__global char *)dst  + dst_index));\n"
"char8 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C2_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char16 src_data1 = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src_data2 = *((__global char16 *)((__global char *)src2 + src2_index));\n"
"char16 dst_data  = *((__global char16 *)((__global char *)dst  + dst_index));\n"
"char16 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C3_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int src2_index = mad24(y, src2_step, (x * 3) + src2_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = vload4(0, src2 + src2_index + 0);\n"
"uchar4 src2_data_1 = vload4(0, src2 + src2_index + 4);\n"
"uchar4 src2_data_2 = vload4(0, src2 + src2_index + 8);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 =  src1_data_0 & src2_data_0;\n"
"uchar4 tmp_data_1 =  src1_data_1 & src2_data_1;\n"
"uchar4 tmp_data_2 =  src1_data_2 & src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C3_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int src2_index = mad24(y, src2_step, (x * 3) + src2_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"char4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"char4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"char4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"char4 src2_data_0 = vload4(0, src2 + src2_index + 0);\n"
"char4 src2_data_1 = vload4(0, src2 + src2_index + 4);\n"
"char4 src2_data_2 = vload4(0, src2 + src2_index + 8);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)(dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)(dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)(dst + dst_index + 8));\n"
"char4 tmp_data_0 =  src1_data_0 & src2_data_0;\n"
"char4 tmp_data_1 =  src1_data_1 & src2_data_1;\n"
"char4 tmp_data_2 =  src1_data_2 & src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global char4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global char4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global char4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C3_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 0));\n"
"ushort2 src2_data_1 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 4));\n"
"ushort2 src2_data_2 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 =  src1_data_0 & src2_data_0 ;\n"
"ushort2 tmp_data_1 =  src1_data_1 & src2_data_1 ;\n"
"ushort2 tmp_data_2 =  src1_data_2 & src2_data_2 ;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C3_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 0));\n"
"short2 src2_data_1 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 4));\n"
"short2 src2_data_2 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 =  src1_data_0 & src2_data_0 ;\n"
"short2 tmp_data_1 =  src1_data_1 & src2_data_1 ;\n"
"short2 tmp_data_2 =  src1_data_2 & src2_data_2 ;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C3_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = *((__global int *)((__global char *)src2 + src2_index + 0));\n"
"int src2_data_1 = *((__global int *)((__global char *)src2 + src2_index + 4));\n"
"int src2_data_2 = *((__global int *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 =  src1_data_0 &  src2_data_0 ;\n"
"int tmp_data_1 =  src1_data_1 &  src2_data_1 ;\n"
"int tmp_data_2 =  src1_data_2 &  src2_data_2 ;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C3_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"char4 src1_data_0 = *((__global char4 *)((__global char *)src1 + src1_index + 0));\n"
"char4 src1_data_1 = *((__global char4 *)((__global char *)src1 + src1_index + 4));\n"
"char4 src1_data_2 = *((__global char4 *)((__global char *)src1 + src1_index + 8));\n"
"char4 src2_data_0 = *((__global char4 *)((__global char *)src2 + src2_index + 0));\n"
"char4 src2_data_1 = *((__global char4 *)((__global char *)src2 + src2_index + 4));\n"
"char4 src2_data_2 = *((__global char4 *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)((__global char *)dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)((__global char *)dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)((__global char *)dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_and_with_mask_C3_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 24) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"char8 src1_data_0 = *((__global char8 *)((__global char *)src1 + src1_index + 0 ));\n"
"char8 src1_data_1 = *((__global char8 *)((__global char *)src1 + src1_index + 8 ));\n"
"char8 src1_data_2 = *((__global char8 *)((__global char *)src1 + src1_index + 16));\n"
"char8 src2_data_0 = *((__global char8 *)((__global char *)src2 + src2_index + 0 ));\n"
"char8 src2_data_1 = *((__global char8 *)((__global char *)src2 + src2_index + 8 ));\n"
"char8 src2_data_2 = *((__global char8 *)((__global char *)src2 + src2_index + 16));\n"
"uchar mask_data = * (mask + mask_index);\n"
"char8 data_0 = *((__global char8 *)((__global char *)dst + dst_index + 0 ));\n"
"char8 data_1 = *((__global char8 *)((__global char *)dst + dst_index + 8 ));\n"
"char8 data_2 = *((__global char8 *)((__global char *)dst + dst_index + 16));\n"
"char8 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"char8 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"char8 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_bitwise_and_with_mask_C4_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 src_data2 = *((__global uchar4 *)(src2 + src2_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C4_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)(src1 + src1_index));\n"
"char4 src_data2 = *((__global char4 *)(src2 + src2_index));\n"
"char4 dst_data  = *((__global char4 *)(dst  + dst_index));\n"
"char4 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C4_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 src_data2 = *((__global ushort4 *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"ushort4 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C4_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src_data2 = *((__global short4 *)((__global char *)src2 + src2_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C4_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 src_data2 = *((__global int4 *)((__global char *)src2 + src2_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"int4 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_and_with_mask_C4_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char16 src_data1 = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src_data2 = *((__global char16 *)((__global char *)src2 + src2_index));\n"
"char16 dst_data  = *((__global char16 *)((__global char *)dst  + dst_index));\n"
"char16 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_and_with_mask_C4_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 5) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1_0 = *((__global char8 *)((__global char *)src1 + src1_index + 0));\n"
"char8 src_data1_1 = *((__global char8 *)((__global char *)src1 + src1_index + 8));\n"
"char8 src_data1_2 = *((__global char8 *)((__global char *)src1 + src1_index + 16));\n"
"char8 src_data1_3 = *((__global char8 *)((__global char *)src1 + src1_index + 24));\n"
"char8 src_data2_0 = *((__global char8 *)((__global char *)src2 + src2_index + 0));\n"
"char8 src_data2_1 = *((__global char8 *)((__global char *)src2 + src2_index + 8));\n"
"char8 src_data2_2 = *((__global char8 *)((__global char *)src2 + src2_index + 16));\n"
"char8 src_data2_3 = *((__global char8 *)((__global char *)src2 + src2_index + 24));\n"
"char8 dst_data_0  = *((__global char8 *)((__global char *)dst  + dst_index + 0));\n"
"char8 dst_data_1  = *((__global char8 *)((__global char *)dst  + dst_index + 8));\n"
"char8 dst_data_2  = *((__global char8 *)((__global char *)dst  + dst_index + 16));\n"
"char8 dst_data_3  = *((__global char8 *)((__global char *)dst  + dst_index + 24));\n"
"char8 data_0 = src_data1_0 & src_data2_0;\n"
"char8 data_1 = src_data1_1 & src_data2_1;\n"
"char8 data_2 = src_data1_2 & src_data2_2;\n"
"char8 data_3 = src_data1_3 & src_data2_3;\n"
"data_0 = mask_data ? data_0 : dst_data_0;\n"
"data_1 = mask_data ? data_1 : dst_data_1;\n"
"data_2 = mask_data ? data_2 : dst_data_2;\n"
"data_3 = mask_data ? data_3 : dst_data_3;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 0)) = data_0;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 8)) = data_1;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 16)) = data_2;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 24)) = data_3;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_and_scalar="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_s_bitwise_and_C1_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data & src2_data;\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C1_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.x, src2.x, src2.x);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data & src2_data;\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C1_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = (ushort2)(src2.x, src2.x);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = src1_data & src2_data;\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C1_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = (short2)(src2.x, src2.x);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"short2 tmp_data = src1_data & src2_data;\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C1_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int data = src_data1 & src_data2;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C1_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"char4 src1_data = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 src2_data = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 data  = *((__global char4 *)((__global char *)dst  + dst_index));\n"
"char4 tmp_data = src1_data & src2_data;\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_and_C1_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"short4 src1_data = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 tmp_data = src1_data & src2_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_and_C2_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data & src2_data;\n"
"data.xy = (dst_index + 0 >= dst_start) ? tmp_data.xy : data.xy;\n"
"data.zw = (dst_index + 2 <  dst_end  ) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C2_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.y, src2.x, src2.y);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data & src2_data;\n"
"data.xy = (dst_index + 0 >= dst_start) ? tmp_data.xy : data.xy;\n"
"data.zw = (dst_index + 2 <  dst_end  ) ? tmp_data.zw : data.zw;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C2_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = (ushort2)(src2.x, src2.y);\n"
"ushort2 data = src_data1 & src_data2;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C2_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = (short2)(src2.x, src2.y);\n"
"short2 data = src_data1 & src_data2;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C2_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 data = src_data1 & src_data2;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C2_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"char8 src1_data = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src2_data = (char8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char8 tmp_data = src1_data & src2_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_and_C2_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"short8 src1_data = *((__global short8 *)((__global char *)src1 + src1_index));\n"
"short8 src2_data = (short8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short8 tmp_data = src1_data & src2_data;\n"
"*((__global short8 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_and_C3_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = (uchar4)(src2.x, src2.y, src2.z, src2.x);\n"
"uchar4 src2_data_1 = (uchar4)(src2.y, src2.z, src2.x, src2.y);\n"
"uchar4 src2_data_2 = (uchar4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"uchar4 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"uchar4 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0.xyz = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C3_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"char4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"char4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"char4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"char4 src2_data_0 = (char4)(src2.x, src2.y, src2.z, src2.x);\n"
"char4 src2_data_1 = (char4)(src2.y, src2.z, src2.x, src2.y);\n"
"char4 src2_data_2 = (char4)(src2.z, src2.x, src2.y, src2.z);\n"
"char4 data_0 = *((__global char4 *)(dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)(dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)(dst + dst_index + 8));\n"
"char4 tmp_data_0 = convert_char4_sat(convert_uchar4_sat(src1_data_0) & convert_uchar4_sat(src2_data_0));\n"
"char4 tmp_data_1 = convert_char4_sat(convert_uchar4_sat(src1_data_1) & convert_uchar4_sat(src2_data_1));\n"
"char4 tmp_data_2 = convert_char4_sat(convert_uchar4_sat(src1_data_2) & convert_uchar4_sat(src2_data_2));\n"
"data_0.xyz = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global char4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global char4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global char4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C3_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = (ushort2)(src2.x, src2.y);\n"
"ushort2 src2_data_1 = (ushort2)(src2.z, src2.x);\n"
"ushort2 src2_data_2 = (ushort2)(src2.y, src2.z);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"ushort2 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"ushort2 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C3_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = (short2)(src2.x, src2.y);\n"
"short2 src2_data_1 = (short2)(src2.z, src2.x);\n"
"short2 src2_data_2 = (short2)(src2.y, src2.z);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"short2 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"short2 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C3_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = src1_data_0 & src2_data_0;\n"
"int tmp_data_1 = src1_data_1 & src2_data_1;\n"
"int tmp_data_2 = src1_data_2 & src2_data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C3_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"char4 src1_data_0 = *((__global char4 *)((__global char *)src1 + src1_index + 0));\n"
"char4 src1_data_1 = *((__global char4 *)((__global char *)src1 + src1_index + 4));\n"
"char4 src1_data_2 = *((__global char4 *)((__global char *)src1 + src1_index + 8));\n"
"char4 src2_data_0 = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 src2_data_1 = (char4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char4 src2_data_2 = (char4)(src2.s8, src2.s9, src2.sA, src2.sB);\n"
"char4 data_0 = *((__global char4 *)((__global char *)dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)((__global char *)dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)((__global char *)dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_and_C3_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0 ));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8 ));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"short4 data_0 = *((__global short4 *)((__global char *)dst + dst_index + 0 ));\n"
"short4 data_1 = *((__global short4 *)((__global char *)dst + dst_index + 8 ));\n"
"short4 data_2 = *((__global short4 *)((__global char *)dst + dst_index + 16));\n"
"short4 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"short4 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"short4 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0 ))= tmp_data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8 ))= tmp_data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16))= tmp_data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_and_C4_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 data = src_data1 & src2;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C4_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"char4 src_data1 = *((__global char4 *)(src1 + src1_index));\n"
"char4 data = src_data1 & src2;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C4_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 data = src_data1 & src2;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C4_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 data = src_data1 & src2;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C4_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 data = src_data1 & src2;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_C4_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"char16 src1_data = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src2_data = (char16)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7,\n"
"src2.s8, src2.s9, src2.sa, src2.sb, src2.sc, src2.sd, src2.se, src2.sf);\n"
"char16 tmp_data = src1_data & src2_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_and_C4_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src1_data_3 = *((__global short4 *)((__global char *)src1 + src1_index + 24));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"short4 src2_data_3 = (short4)(src2.sc, src2.sd, src2.se, src2.sf);\n"
"short4 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"short4 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"short4 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"short4 tmp_data_3 = src1_data_3 & src2_data_3;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0 ))= tmp_data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8 ))= tmp_data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16))= tmp_data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 24))= tmp_data_3;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_and_scalar_mask="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_s_bitwise_and_with_mask_C1_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data & src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C1_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data & src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C1_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar  *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = (ushort2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = src1_data & src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C1_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = (short2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"short2 tmp_data = src1_data & src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C1_D4 (\n"
"__global   int   *src1, int src1_step, int src1_offset,\n"
"__global   int   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C1_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src1_data = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 src2_data = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 dst_data  = *((__global char4 *)((__global char *)dst  + dst_index));\n"
"char4 data = src1_data & src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_and_with_mask_C1_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src1_data = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = src1_data & src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_and_with_mask_C2_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data & src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C2_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data & src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C2_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = (ushort2)(src2.x, src2.y);\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"ushort2 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C2_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = (short2)(src2.x, src2.y);\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"short2 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C2_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = src_data1 & src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C2_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global  char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src1_data = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src2_data = (char8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char8 dst_data = *((__global char8 *)((__global char *)dst  + dst_index));\n"
"char8 data = src1_data & src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_and_with_mask_C2_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short8 src1_data = *((__global short8 *)((__global char *)src1 + src1_index));\n"
"short8 src2_data = (short8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short8 dst_data = *((__global short8 *)((__global char *)dst  + dst_index));\n"
"short8 data = src1_data & src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_and_with_mask_C3_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = (uchar4)(src2.x, src2.y, src2.z, src2.x);\n"
"uchar4 src2_data_1 = (uchar4)(src2.y, src2.z, src2.x, src2.y);\n"
"uchar4 src2_data_2 = (uchar4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"uchar4 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"uchar4 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C3_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"char4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"char4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"char4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"char4 src2_data_0 = (char4)(src2.x, src2.y, src2.z, src2.x);\n"
"char4 src2_data_1 = (char4)(src2.y, src2.z, src2.x, src2.y);\n"
"char4 src2_data_2 = (char4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)(dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)(dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)(dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global char4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global char4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global char4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C3_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = (ushort2)(src2.x, src2.y);\n"
"ushort2 src2_data_1 = (ushort2)(src2.z, src2.x);\n"
"ushort2 src2_data_2 = (ushort2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"ushort2 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"ushort2 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C3_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = (short2)(src2.x, src2.y);\n"
"short2 src2_data_1 = (short2)(src2.z, src2.x);\n"
"short2 src2_data_2 = (short2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"short2 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"short2 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C3_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = src1_data_0 & src2_data_0;\n"
"int tmp_data_1 = src1_data_1 & src2_data_1;\n"
"int tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C3_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"char4 src1_data_0 = *((__global char4 *)((__global char *)src1 + src1_index + 0));\n"
"char4 src1_data_1 = *((__global char4 *)((__global char *)src1 + src1_index + 4));\n"
"char4 src1_data_2 = *((__global char4 *)((__global char *)src1 + src1_index + 8));\n"
"char4 src2_data_0 = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 src2_data_1 = (char4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char4 src2_data_2 = (char4)(src2.s8, src2.s9, src2.sA, src2.sB);\n"
"uchar mask_data = * (mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)((__global char *)dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)((__global char *)dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)((__global char *)dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_and_with_mask_C3_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0 ));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8 ));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"uchar mask_data = * (mask + mask_index);\n"
"short4 data_0 = *((__global short4 *)((__global char *)dst + dst_index + 0 ));\n"
"short4 data_1 = *((__global short4 *)((__global char *)dst + dst_index + 8 ));\n"
"short4 data_2 = *((__global short4 *)((__global char *)dst + dst_index + 16));\n"
"short4 tmp_data_0 = src1_data_0 & src2_data_0;\n"
"short4 tmp_data_1 = src1_data_1 & src2_data_1;\n"
"short4 tmp_data_2 = src1_data_2 & src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_and_with_mask_C4_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 data = src_data1 & src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C4_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)(src1 + src1_index));\n"
"char4 dst_data  = *((__global char4 *)(dst  + dst_index));\n"
"char4 data = src_data1 & src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C4_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"ushort4 data = src_data1 & src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C4_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = src_data1 & src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C4_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"int4 data = src_data1 & src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_and_with_mask_C4_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char16 src1_data = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src2_data = (char16)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7,\n"
"src2.s8, src2.s9, src2.sa, src2.sb, src2.sc, src2.sd, src2.se, src2.sf);\n"
"char16 dst_data  = *((__global char16 *)((__global char *)dst  + dst_index));\n"
"char16 data = src1_data & src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_and_with_mask_C4_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src1_data_3 = *((__global short4 *)((__global char *)src1 + src1_index + 24));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"short4 src2_data_3 = (short4)(src2.sc, src2.sd, src2.se, src2.sf);\n"
"short4 dst_data_0  = *((__global short4 *)((__global char *)dst  + dst_index + 0));\n"
"short4 dst_data_1  = *((__global short4 *)((__global char *)dst  + dst_index + 8));\n"
"short4 dst_data_2  = *((__global short4 *)((__global char *)dst  + dst_index + 16));\n"
"short4 dst_data_3  = *((__global short4 *)((__global char *)dst  + dst_index + 24));\n"
"short4 data_0 = src1_data_0 & src2_data_0;\n"
"short4 data_1 = src1_data_1 & src2_data_1;\n"
"short4 data_2 = src1_data_2 & src2_data_2;\n"
"short4 data_3 = src1_data_3 & src2_data_3;\n"
"data_0 = mask_data ? data_0 : dst_data_0;\n"
"data_1 = mask_data ? data_1 : dst_data_1;\n"
"data_2 = mask_data ? data_2 : dst_data_2;\n"
"data_3 = mask_data ? data_3 : dst_data_3;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0)) = data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8)) = data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16)) = data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 24)) = data_3;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_not="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_bitwise_not_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = ~ src1_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_not_D1 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 dst_data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = ~ src1_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global char4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_not_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"ushort4 tmp_data = ~ src1_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_not_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"short4 tmp_data = ~ src1_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_not_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int tmp  = ~ data1;\n"
"*((__global int *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_not_D5 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src_index = mad24(y, src_step, (x << 2) + src_offset);\n"
"int dst_index = mad24(y, dst_step, (x << 2) + dst_offset);\n"
"char4 data;\n"
"data = *((__global char4 *)((__global char *)src + src_index));\n"
"data = ~ data;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_not_D6 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src_index = mad24(y, src_step, (x << 3) + src_offset);\n"
"int dst_index = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"char8 data;\n"
"data = *((__global char8 *)((__global char *)src + src_index));\n"
"data = ~ data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_or="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_bitwise_or_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data | src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_D1 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = vload4(0, src2 + src2_index);\n"
"char4 dst_data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data | src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global char4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"ushort4 tmp_data = src1_data | src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"short4 tmp_data = src1_data | src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"int tmp  = data1 | data2;\n"
"*((__global int *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_D5 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"char4 data1 = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 data2 = *((__global char4 *)((__global char *)src2 + src2_index));\n"
"char4 tmp = data1 | data2;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_or_D6 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"char8 data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 data2 = *((__global char8 *)((__global char *)src2 + src2_index));\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data1 | data2;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_or_mask="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_bitwise_or_with_mask_C1_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data | src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C1_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data | src2_data;\n"
"data.x = convert_char((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = convert_char((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = convert_char((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = convert_char((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C1_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = vload2(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = src1_data | src2_data;\n"
"data.x = convert_ushort((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = convert_ushort((mask_data.y) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C1_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = vload2(0, (__global short *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"short2 tmp_data = src1_data | src2_data;\n"
"data.x = convert_short((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = convert_short((mask_data.y) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C1_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C1_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 src_data2 = *((__global char4 *)((__global char *)src2 + src2_index));\n"
"char4 dst_data  = *((__global char4 *)((__global char *)dst  + dst_index));\n"
"char4 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_or_with_mask_C1_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src_data2 = *((__global char8 *)((__global char *)src2 + src2_index));\n"
"char8 dst_data  = *((__global char8 *)((__global char *)dst  + dst_index));\n"
"char8 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_bitwise_or_with_mask_C2_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data | src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C2_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data | src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C2_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = *((__global ushort2 *)((__global char *)src2 + src2_index));\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"ushort2 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C2_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = *((__global short2 *)((__global char *)src2 + src2_index));\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"short2 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C2_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int    *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = *((__global int2 *)((__global char *)src2 + src2_index));\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C2_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src_data2 = *((__global char8 *)((__global char *)src2 + src2_index));\n"
"char8 dst_data  = *((__global char8 *)((__global char *)dst  + dst_index));\n"
"char8 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_or_with_mask_C2_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char16 src_data1 = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src_data2 = *((__global char16 *)((__global char *)src2 + src2_index));\n"
"char16 dst_data  = *((__global char16 *)((__global char *)dst  + dst_index));\n"
"char16 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_bitwise_or_with_mask_C3_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int src2_index = mad24(y, src2_step, (x * 3) + src2_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = vload4(0, src2 + src2_index + 0);\n"
"uchar4 src2_data_1 = vload4(0, src2 + src2_index + 4);\n"
"uchar4 src2_data_2 = vload4(0, src2 + src2_index + 8);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 =  src1_data_0 | src2_data_0;\n"
"uchar4 tmp_data_1 =  src1_data_1 | src2_data_1;\n"
"uchar4 tmp_data_2 =  src1_data_2 | src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C3_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int src2_index = mad24(y, src2_step, (x * 3) + src2_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"char4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"char4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"char4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"char4 src2_data_0 = vload4(0, src2 + src2_index + 0);\n"
"char4 src2_data_1 = vload4(0, src2 + src2_index + 4);\n"
"char4 src2_data_2 = vload4(0, src2 + src2_index + 8);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)(dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)(dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)(dst + dst_index + 8));\n"
"char4 tmp_data_0 =  src1_data_0 | src2_data_0;\n"
"char4 tmp_data_1 =  src1_data_1 | src2_data_1;\n"
"char4 tmp_data_2 =  src1_data_2 | src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global char4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global char4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global char4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C3_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 0));\n"
"ushort2 src2_data_1 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 4));\n"
"ushort2 src2_data_2 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 =  src1_data_0 | src2_data_0 ;\n"
"ushort2 tmp_data_1 =  src1_data_1 | src2_data_1 ;\n"
"ushort2 tmp_data_2 =  src1_data_2 | src2_data_2 ;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C3_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 0));\n"
"short2 src2_data_1 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 4));\n"
"short2 src2_data_2 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 =  src1_data_0 | src2_data_0 ;\n"
"short2 tmp_data_1 =  src1_data_1 | src2_data_1 ;\n"
"short2 tmp_data_2 =  src1_data_2 | src2_data_2 ;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C3_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = *((__global int *)((__global char *)src2 + src2_index + 0));\n"
"int src2_data_1 = *((__global int *)((__global char *)src2 + src2_index + 4));\n"
"int src2_data_2 = *((__global int *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 =  src1_data_0 |  src2_data_0 ;\n"
"int tmp_data_1 =  src1_data_1 |  src2_data_1 ;\n"
"int tmp_data_2 =  src1_data_2 |  src2_data_2 ;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C3_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"char4 src1_data_0 = *((__global char4 *)((__global char *)src1 + src1_index + 0));\n"
"char4 src1_data_1 = *((__global char4 *)((__global char *)src1 + src1_index + 4));\n"
"char4 src1_data_2 = *((__global char4 *)((__global char *)src1 + src1_index + 8));\n"
"char4 src2_data_0 = *((__global char4 *)((__global char *)src2 + src2_index + 0));\n"
"char4 src2_data_1 = *((__global char4 *)((__global char *)src2 + src2_index + 4));\n"
"char4 src2_data_2 = *((__global char4 *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)((__global char *)dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)((__global char *)dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)((__global char *)dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_or_with_mask_C3_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 24) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"char8 src1_data_0 = *((__global char8 *)((__global char *)src1 + src1_index + 0 ));\n"
"char8 src1_data_1 = *((__global char8 *)((__global char *)src1 + src1_index + 8 ));\n"
"char8 src1_data_2 = *((__global char8 *)((__global char *)src1 + src1_index + 16));\n"
"char8 src2_data_0 = *((__global char8 *)((__global char *)src2 + src2_index + 0 ));\n"
"char8 src2_data_1 = *((__global char8 *)((__global char *)src2 + src2_index + 8 ));\n"
"char8 src2_data_2 = *((__global char8 *)((__global char *)src2 + src2_index + 16));\n"
"uchar mask_data = * (mask + mask_index);\n"
"char8 data_0 = *((__global char8 *)((__global char *)dst + dst_index + 0 ));\n"
"char8 data_1 = *((__global char8 *)((__global char *)dst + dst_index + 8 ));\n"
"char8 data_2 = *((__global char8 *)((__global char *)dst + dst_index + 16));\n"
"char8 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"char8 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"char8 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_bitwise_or_with_mask_C4_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 src_data2 = *((__global uchar4 *)(src2 + src2_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C4_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)(src1 + src1_index));\n"
"char4 src_data2 = *((__global char4 *)(src2 + src2_index));\n"
"char4 dst_data  = *((__global char4 *)(dst  + dst_index));\n"
"char4 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C4_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 src_data2 = *((__global ushort4 *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"ushort4 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C4_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src_data2 = *((__global short4 *)((__global char *)src2 + src2_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C4_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 src_data2 = *((__global int4 *)((__global char *)src2 + src2_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"int4 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_or_with_mask_C4_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char16 src_data1 = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src_data2 = *((__global char16 *)((__global char *)src2 + src2_index));\n"
"char16 dst_data  = *((__global char16 *)((__global char *)dst  + dst_index));\n"
"char16 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_or_with_mask_C4_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 5) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1_0 = *((__global char8 *)((__global char *)src1 + src1_index + 0));\n"
"char8 src_data1_1 = *((__global char8 *)((__global char *)src1 + src1_index + 8));\n"
"char8 src_data1_2 = *((__global char8 *)((__global char *)src1 + src1_index + 16));\n"
"char8 src_data1_3 = *((__global char8 *)((__global char *)src1 + src1_index + 24));\n"
"char8 src_data2_0 = *((__global char8 *)((__global char *)src2 + src2_index + 0));\n"
"char8 src_data2_1 = *((__global char8 *)((__global char *)src2 + src2_index + 8));\n"
"char8 src_data2_2 = *((__global char8 *)((__global char *)src2 + src2_index + 16));\n"
"char8 src_data2_3 = *((__global char8 *)((__global char *)src2 + src2_index + 24));\n"
"char8 dst_data_0  = *((__global char8 *)((__global char *)dst  + dst_index + 0));\n"
"char8 dst_data_1  = *((__global char8 *)((__global char *)dst  + dst_index + 8));\n"
"char8 dst_data_2  = *((__global char8 *)((__global char *)dst  + dst_index + 16));\n"
"char8 dst_data_3  = *((__global char8 *)((__global char *)dst  + dst_index + 24));\n"
"char8 data_0 = src_data1_0 | src_data2_0;\n"
"char8 data_1 = src_data1_1 | src_data2_1;\n"
"char8 data_2 = src_data1_2 | src_data2_2;\n"
"char8 data_3 = src_data1_3 | src_data2_3;\n"
"data_0 = mask_data ? data_0 : dst_data_0;\n"
"data_1 = mask_data ? data_1 : dst_data_1;\n"
"data_2 = mask_data ? data_2 : dst_data_2;\n"
"data_3 = mask_data ? data_3 : dst_data_3;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 0)) = data_0;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 8)) = data_1;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 16)) = data_2;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 24)) = data_3;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_or_scalar="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_s_bitwise_or_C1_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data | src2_data;\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C1_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.x, src2.x, src2.x);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data | src2_data;\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C1_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = (ushort2)(src2.x, src2.x);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = src1_data | src2_data;\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C1_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = (short2)(src2.x, src2.x);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"short2 tmp_data = src1_data | src2_data;\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C1_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int data = src_data1 | src_data2;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C1_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"char4 src_data1 = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 src_data2 = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 data = src_data1 | src_data2;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_or_C1_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"short4 src1_data = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 tmp_data = src1_data | src2_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_or_C2_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data | src2_data;\n"
"data.xy = (dst_index + 0 >= dst_start) ? tmp_data.xy : data.xy;\n"
"data.zw = (dst_index + 2 <  dst_end  ) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C2_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.y, src2.x, src2.y);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data | src2_data;\n"
"data.xy = (dst_index + 0 >= dst_start) ? tmp_data.xy : data.xy;\n"
"data.zw = (dst_index + 2 <  dst_end  ) ? tmp_data.zw : data.zw;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C2_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = (ushort2)(src2.x, src2.y);\n"
"ushort2 data = src_data1 | src_data2;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C2_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = (short2)(src2.x, src2.y);\n"
"short2 data = src_data1 | src_data2;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C2_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 data = src_data1 | src_data2;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C2_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"char8 src_data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src_data2 = (char8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char8 data = src_data1 | src_data2;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_or_C2_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"short8 src1_data = *((__global short8 *)((__global char *)src1 + src1_index));\n"
"short8 src2_data = (short8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short8 tmp_data = src1_data & src2_data;\n"
"*((__global short8 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_or_C3_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = (uchar4)(src2.x, src2.y, src2.z, src2.x);\n"
"uchar4 src2_data_1 = (uchar4)(src2.y, src2.z, src2.x, src2.y);\n"
"uchar4 src2_data_2 = (uchar4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 =  src1_data_0  |  src2_data_0  ;\n"
"uchar4 tmp_data_1 =  src1_data_1  |  src2_data_1  ;\n"
"uchar4 tmp_data_2 =  src1_data_2  |  src2_data_2  ;\n"
"data_0.xyz = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C3_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"char4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"char4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"char4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"char4 src2_data_0 = (char4)(src2.x, src2.y, src2.z, src2.x);\n"
"char4 src2_data_1 = (char4)(src2.y, src2.z, src2.x, src2.y);\n"
"char4 src2_data_2 = (char4)(src2.z, src2.x, src2.y, src2.z);\n"
"char4 data_0 = *((__global char4 *)(dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)(dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)(dst + dst_index + 8));\n"
"char4 tmp_data_0 =  src1_data_0  |  src2_data_0;\n"
"char4 tmp_data_1 =  src1_data_1  |  src2_data_1;\n"
"char4 tmp_data_2 =  src1_data_2  |  src2_data_2;\n"
"data_0.xyz = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global char4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global char4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global char4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C3_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = (ushort2)(src2.x, src2.y);\n"
"ushort2 src2_data_1 = (ushort2)(src2.z, src2.x);\n"
"ushort2 src2_data_2 = (ushort2)(src2.y, src2.z);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = src1_data_0  |  src2_data_0  ;\n"
"ushort2 tmp_data_1 = src1_data_1  |  src2_data_1  ;\n"
"ushort2 tmp_data_2 = src1_data_2  |  src2_data_2  ;\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C3_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = (short2)(src2.x, src2.y);\n"
"short2 src2_data_1 = (short2)(src2.z, src2.x);\n"
"short2 src2_data_2 = (short2)(src2.y, src2.z);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 =  src1_data_0  |  src2_data_0  ;\n"
"short2 tmp_data_1 =  src1_data_1  |  src2_data_1  ;\n"
"short2 tmp_data_2 =  src1_data_2  |  src2_data_2  ;\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C3_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = src1_data_0 | src2_data_0;\n"
"int tmp_data_1 = src1_data_1 | src2_data_1;\n"
"int tmp_data_2 = src1_data_2 | src2_data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C3_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"char4 src1_data_0 = *((__global char4 *)((__global char *)src1 + src1_index + 0));\n"
"char4 src1_data_1 = *((__global char4 *)((__global char *)src1 + src1_index + 4));\n"
"char4 src1_data_2 = *((__global char4 *)((__global char *)src1 + src1_index + 8));\n"
"char4 src2_data_0 = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 src2_data_1 = (char4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char4 src2_data_2 = (char4)(src2.s8, src2.s9, src2.sA, src2.sB);\n"
"char4 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_or_C3_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0 ));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8 ));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"short4 data_0 = *((__global short4 *)((__global char *)dst + dst_index + 0 ));\n"
"short4 data_1 = *((__global short4 *)((__global char *)dst + dst_index + 8 ));\n"
"short4 data_2 = *((__global short4 *)((__global char *)dst + dst_index + 16));\n"
"short4 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"short4 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"short4 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0 ))= tmp_data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8 ))= tmp_data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16))= tmp_data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_or_C4_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 data = src_data1 | src2;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C4_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"char4 src_data1 = *((__global char4 *)(src1 + src1_index));\n"
"char4 data = src_data1 | src2;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C4_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 data = src_data1 | src2;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C4_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 data = src_data1 | src2;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C4_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 data = src_data1 | src2;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_C4_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"char16 src_data1 = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src_data2 = (char16)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7,\n"
"src2.s8, src2.s9, src2.sa, src2.sb, src2.sc, src2.sd, src2.se, src2.sf);\n"
"char16 data = src_data1 | src_data2;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_or_C4_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src1_data_3 = *((__global short4 *)((__global char *)src1 + src1_index + 24));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"short4 src2_data_3 = (short4)(src2.sc, src2.sd, src2.se, src2.sf);\n"
"short4 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"short4 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"short4 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"short4 tmp_data_3 = src1_data_3 | src2_data_3;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0 ))= tmp_data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8 ))= tmp_data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16))= tmp_data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 24))= tmp_data_3;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_or_scalar_mask="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_s_bitwise_or_with_mask_C1_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data | src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C1_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data | src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C1_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar  *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = (ushort2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = src1_data | src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C1_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = (short2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"short2 tmp_data = src1_data | src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C1_D4 (\n"
"__global   int   *src1, int src1_step, int src1_offset,\n"
"__global   int   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C1_D5 (\n"
"__global   char   *src1, int src1_step, int src1_offset,\n"
"__global   char   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 src_data2 = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 dst_data  = *((__global char4 *)((__global char *)dst  + dst_index));\n"
"char4 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_or_with_mask_C1_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src1_data = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = src1_data | src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_or_with_mask_C2_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data | src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C2_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data | src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C2_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = (ushort2)(src2.x, src2.y);\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"ushort2 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C2_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = (short2)(src2.x, src2.y);\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"short2 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C2_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C2_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src_data2 = (char8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char8 dst_data = *((__global char8 *)((__global char *)dst  + dst_index));\n"
"char8 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_or_with_mask_C2_D6 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short8 src1_data = *((__global short8 *)((__global char *)src1 + src1_index));\n"
"short8 src2_data = (short8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short8 dst_data = *((__global short8 *)((__global char *)dst  + dst_index));\n"
"short8 data = src1_data | src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_or_with_mask_C3_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = (uchar4)(src2.x, src2.y, src2.z, src2.x);\n"
"uchar4 src2_data_1 = (uchar4)(src2.y, src2.z, src2.x, src2.y);\n"
"uchar4 src2_data_2 = (uchar4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"uchar4 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"uchar4 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C3_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"char4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"char4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"char4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"char4 src2_data_0 = (char4)(src2.x, src2.y, src2.z, src2.x);\n"
"char4 src2_data_1 = (char4)(src2.y, src2.z, src2.x, src2.y);\n"
"char4 src2_data_2 = (char4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)(dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)(dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)(dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global char4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global char4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global char4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C3_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = (ushort2)(src2.x, src2.y);\n"
"ushort2 src2_data_1 = (ushort2)(src2.z, src2.x);\n"
"ushort2 src2_data_2 = (ushort2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"ushort2 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"ushort2 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C3_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = (short2)(src2.x, src2.y);\n"
"short2 src2_data_1 = (short2)(src2.z, src2.x);\n"
"short2 src2_data_2 = (short2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"short2 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"short2 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C3_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = src1_data_0 | src2_data_0;\n"
"int tmp_data_1 = src1_data_1 | src2_data_1;\n"
"int tmp_data_2 = src1_data_2 | src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C3_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"char4 src1_data_0 = *((__global char4 *)((__global char *)src1 + src1_index + 0));\n"
"char4 src1_data_1 = *((__global char4 *)((__global char *)src1 + src1_index + 4));\n"
"char4 src1_data_2 = *((__global char4 *)((__global char *)src1 + src1_index + 8));\n"
"char4 src2_data_0 = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 src2_data_1 = (char4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char4 src2_data_2 = (char4)(src2.s8, src2.s9, src2.sA, src2.sB);\n"
"uchar mask_data = * (mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)((__global char *)dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)((__global char *)dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)((__global char *)dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_or_with_mask_C3_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0 ));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8 ));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"uchar mask_data = * (mask + mask_index);\n"
"short4 data_0 = *((__global short4 *)((__global char *)dst + dst_index + 0 ));\n"
"short4 data_1 = *((__global short4 *)((__global char *)dst + dst_index + 8 ));\n"
"short4 data_2 = *((__global short4 *)((__global char *)dst + dst_index + 16));\n"
"short4 tmp_data_0 = src1_data_0 | src2_data_0;\n"
"short4 tmp_data_1 = src1_data_1 | src2_data_1;\n"
"short4 tmp_data_2 = src1_data_2 | src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_or_with_mask_C4_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 data = src_data1 | src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C4_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)(src1 + src1_index));\n"
"char4 dst_data  = *((__global char4 *)(dst  + dst_index));\n"
"char4 data = src_data1 | src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C4_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"ushort4 data = src_data1 | src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C4_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = src_data1 | src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C4_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"int4 data = src_data1 | src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_or_with_mask_C4_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char16 src_data1 = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src_data2 = (char16)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7,\n"
"src2.s8, src2.s9, src2.sa, src2.sb, src2.sc, src2.sd, src2.se, src2.sf);\n"
"char16 dst_data  = *((__global char16 *)((__global char *)dst  + dst_index));\n"
"char16 data = src_data1 | src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_or_with_mask_C4_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src1_data_3 = *((__global short4 *)((__global char *)src1 + src1_index + 24));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"short4 src2_data_3 = (short4)(src2.sc, src2.sd, src2.se, src2.sf);\n"
"short4 dst_data_0  = *((__global short4 *)((__global char *)dst  + dst_index + 0));\n"
"short4 dst_data_1  = *((__global short4 *)((__global char *)dst  + dst_index + 8));\n"
"short4 dst_data_2  = *((__global short4 *)((__global char *)dst  + dst_index + 16));\n"
"short4 dst_data_3  = *((__global short4 *)((__global char *)dst  + dst_index + 24));\n"
"short4 data_0 = src1_data_0 | src2_data_0;\n"
"short4 data_1 = src1_data_1 | src2_data_1;\n"
"short4 data_2 = src1_data_2 | src2_data_2;\n"
"short4 data_3 = src1_data_3 | src2_data_3;\n"
"data_0 = mask_data ? data_0 : dst_data_0;\n"
"data_1 = mask_data ? data_1 : dst_data_1;\n"
"data_2 = mask_data ? data_2 : dst_data_2;\n"
"data_3 = mask_data ? data_3 : dst_data_3;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0)) = data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8)) = data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16)) = data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 24)) = data_3;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_xor="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_bitwise_xor_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data ^ src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_D1 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"char4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"char4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"char4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"char4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"char4 dst_data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data ^ src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global char4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index_fix));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"ushort4 tmp_data = src1_data ^ src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index_fix));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index_fix));\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"if(src1_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"short4 tmp_data = src1_data ^ src2_data;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"int tmp  = data1 ^ data2;\n"
"*((__global int *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_D5 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"char4 data1 = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 data2 = *((__global char4 *)((__global char *)src2 + src2_index));\n"
"char4 tmp = data1 ^ data2;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_xor_D6 (__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"char8 data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 data2 = *((__global char8 *)((__global char *)src2 + src2_index));\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data1 ^ data2;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_xor_mask="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_bitwise_xor_with_mask_C1_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data ^ src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C1_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data ^ src2_data;\n"
"data.x = convert_char((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = convert_char((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = convert_char((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = convert_char((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C1_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = vload2(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = src1_data ^ src2_data;\n"
"data.x = convert_ushort((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = convert_ushort((mask_data.y) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C1_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = vload2(0, (__global short *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"short2 tmp_data = src1_data ^ src2_data;\n"
"data.x = convert_short((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = convert_short((mask_data.y) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C1_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C1_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 src_data2 = *((__global char4 *)((__global char *)src2 + src2_index));\n"
"char4 dst_data  = *((__global char4 *)((__global char *)dst  + dst_index));\n"
"char4 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_xor_with_mask_C1_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src_data2 = *((__global char8 *)((__global char *)src2 + src2_index));\n"
"char8 dst_data  = *((__global char8 *)((__global char *)dst  + dst_index));\n"
"char8 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_bitwise_xor_with_mask_C2_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data ^ src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C2_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data ^ src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C2_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = *((__global ushort2 *)((__global char *)src2 + src2_index));\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"ushort2 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C2_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = *((__global short2 *)((__global char *)src2 + src2_index));\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"short2 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C2_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int    *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = *((__global int2 *)((__global char *)src2 + src2_index));\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C2_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1 = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src_data2 = *((__global char8 *)((__global char *)src2 + src2_index));\n"
"char8 dst_data  = *((__global char8 *)((__global char *)dst  + dst_index));\n"
"char8 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_xor_with_mask_C2_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char16 src_data1 = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src_data2 = *((__global char16 *)((__global char *)src2 + src2_index));\n"
"char16 dst_data  = *((__global char16 *)((__global char *)dst  + dst_index));\n"
"char16 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_bitwise_xor_with_mask_C3_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int src2_index = mad24(y, src2_step, (x * 3) + src2_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = vload4(0, src2 + src2_index + 0);\n"
"uchar4 src2_data_1 = vload4(0, src2 + src2_index + 4);\n"
"uchar4 src2_data_2 = vload4(0, src2 + src2_index + 8);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 =  src1_data_0 ^ src2_data_0;\n"
"uchar4 tmp_data_1 =  src1_data_1 ^ src2_data_1;\n"
"uchar4 tmp_data_2 =  src1_data_2 ^ src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C3_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int src2_index = mad24(y, src2_step, (x * 3) + src2_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"char4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"char4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"char4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"char4 src2_data_0 = vload4(0, src2 + src2_index + 0);\n"
"char4 src2_data_1 = vload4(0, src2 + src2_index + 4);\n"
"char4 src2_data_2 = vload4(0, src2 + src2_index + 8);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)(dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)(dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)(dst + dst_index + 8));\n"
"char4 tmp_data_0 =  src1_data_0 ^ src2_data_0;\n"
"char4 tmp_data_1 =  src1_data_1 ^ src2_data_1;\n"
"char4 tmp_data_2 =  src1_data_2 ^ src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global char4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global char4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global char4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C3_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 0));\n"
"ushort2 src2_data_1 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 4));\n"
"ushort2 src2_data_2 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 =  src1_data_0 ^ src2_data_0 ;\n"
"ushort2 tmp_data_1 =  src1_data_1 ^ src2_data_1 ;\n"
"ushort2 tmp_data_2 =  src1_data_2 ^ src2_data_2 ;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C3_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 0));\n"
"short2 src2_data_1 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 4));\n"
"short2 src2_data_2 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 =  src1_data_0 ^ src2_data_0 ;\n"
"short2 tmp_data_1 =  src1_data_1 ^ src2_data_1 ;\n"
"short2 tmp_data_2 =  src1_data_2 ^ src2_data_2 ;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C3_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = *((__global int *)((__global char *)src2 + src2_index + 0));\n"
"int src2_data_1 = *((__global int *)((__global char *)src2 + src2_index + 4));\n"
"int src2_data_2 = *((__global int *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 =  src1_data_0 ^  src2_data_0 ;\n"
"int tmp_data_1 =  src1_data_1 ^  src2_data_1 ;\n"
"int tmp_data_2 =  src1_data_2 ^  src2_data_2 ;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C3_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"char4 src1_data_0 = *((__global char4 *)((__global char *)src1 + src1_index + 0));\n"
"char4 src1_data_1 = *((__global char4 *)((__global char *)src1 + src1_index + 4));\n"
"char4 src1_data_2 = *((__global char4 *)((__global char *)src1 + src1_index + 8));\n"
"char4 src2_data_0 = *((__global char4 *)((__global char *)src2 + src2_index + 0));\n"
"char4 src2_data_1 = *((__global char4 *)((__global char *)src2 + src2_index + 4));\n"
"char4 src2_data_2 = *((__global char4 *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)((__global char *)dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)((__global char *)dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)((__global char *)dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_xor_with_mask_C3_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 24) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"char8 src1_data_0 = *((__global char8 *)((__global char *)src1 + src1_index + 0 ));\n"
"char8 src1_data_1 = *((__global char8 *)((__global char *)src1 + src1_index + 8 ));\n"
"char8 src1_data_2 = *((__global char8 *)((__global char *)src1 + src1_index + 16));\n"
"char8 src2_data_0 = *((__global char8 *)((__global char *)src2 + src2_index + 0 ));\n"
"char8 src2_data_1 = *((__global char8 *)((__global char *)src2 + src2_index + 8 ));\n"
"char8 src2_data_2 = *((__global char8 *)((__global char *)src2 + src2_index + 16));\n"
"uchar mask_data = * (mask + mask_index);\n"
"char8 data_0 = *((__global char8 *)((__global char *)dst + dst_index + 0 ));\n"
"char8 data_1 = *((__global char8 *)((__global char *)dst + dst_index + 8 ));\n"
"char8 data_2 = *((__global char8 *)((__global char *)dst + dst_index + 16));\n"
"char8 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"char8 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"char8 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_bitwise_xor_with_mask_C4_D0 (\n"
"__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 src_data2 = *((__global uchar4 *)(src2 + src2_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C4_D1 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)(src1 + src1_index));\n"
"char4 src_data2 = *((__global char4 *)(src2 + src2_index));\n"
"char4 dst_data  = *((__global char4 *)(dst  + dst_index));\n"
"char4 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C4_D2 (\n"
"__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 src_data2 = *((__global ushort4 *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"ushort4 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C4_D3 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src_data2 = *((__global short4 *)((__global char *)src2 + src2_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C4_D4 (\n"
"__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 src_data2 = *((__global int4 *)((__global char *)src2 + src2_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"int4 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_bitwise_xor_with_mask_C4_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char16 src_data1 = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src_data2 = *((__global char16 *)((__global char *)src2 + src2_index));\n"
"char16 dst_data  = *((__global char16 *)((__global char *)dst  + dst_index));\n"
"char16 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_bitwise_xor_with_mask_C4_D6 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 5) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src_data1_0 = *((__global char8 *)((__global char *)src1 + src1_index + 0));\n"
"char8 src_data1_1 = *((__global char8 *)((__global char *)src1 + src1_index + 8));\n"
"char8 src_data1_2 = *((__global char8 *)((__global char *)src1 + src1_index + 16));\n"
"char8 src_data1_3 = *((__global char8 *)((__global char *)src1 + src1_index + 24));\n"
"char8 src_data2_0 = *((__global char8 *)((__global char *)src2 + src2_index + 0));\n"
"char8 src_data2_1 = *((__global char8 *)((__global char *)src2 + src2_index + 8));\n"
"char8 src_data2_2 = *((__global char8 *)((__global char *)src2 + src2_index + 16));\n"
"char8 src_data2_3 = *((__global char8 *)((__global char *)src2 + src2_index + 24));\n"
"char8 dst_data_0  = *((__global char8 *)((__global char *)dst  + dst_index + 0));\n"
"char8 dst_data_1  = *((__global char8 *)((__global char *)dst  + dst_index + 8));\n"
"char8 dst_data_2  = *((__global char8 *)((__global char *)dst  + dst_index + 16));\n"
"char8 dst_data_3  = *((__global char8 *)((__global char *)dst  + dst_index + 24));\n"
"char8 data_0 = src_data1_0 ^ src_data2_0;\n"
"char8 data_1 = src_data1_1 ^ src_data2_1;\n"
"char8 data_2 = src_data1_2 ^ src_data2_2;\n"
"char8 data_3 = src_data1_3 ^ src_data2_3;\n"
"data_0 = mask_data ? data_0 : dst_data_0;\n"
"data_1 = mask_data ? data_1 : dst_data_1;\n"
"data_2 = mask_data ? data_2 : dst_data_2;\n"
"data_3 = mask_data ? data_3 : dst_data_3;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 0)) = data_0;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 8)) = data_1;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 16)) = data_2;\n"
"*((__global char8 *)((__global char *)dst + dst_index + 24)) = data_3;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_xor_scalar="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_s_bitwise_xor_C1_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data ^ src2_data;\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C1_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.x, src2.x, src2.x);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data ^ src2_data;\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C1_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = (ushort2)(src2.x, src2.x);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = src1_data ^ src2_data;\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C1_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = (short2)(src2.x, src2.x);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"short2 tmp_data = src1_data ^ src2_data;\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C1_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int data = src_data1 ^ src_data2;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C1_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"char4 src1_data = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 src2_data = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 data  = *((__global char4 *)((__global char *)dst  + dst_index));\n"
"char4 tmp_data = src1_data ^ src2_data;\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_xor_C1_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"short4 src1_data = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 tmp_data = src1_data ^ src2_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_xor_C2_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data ^ src2_data;\n"
"data.xy = (dst_index + 0 >= dst_start) ? tmp_data.xy : data.xy;\n"
"data.zw = (dst_index + 2 <  dst_end  ) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C2_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.y, src2.x, src2.y);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data ^ src2_data;\n"
"data.xy = (dst_index + 0 >= dst_start) ? tmp_data.xy : data.xy;\n"
"data.zw = (dst_index + 2 <  dst_end  ) ? tmp_data.zw : data.zw;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C2_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = (ushort2)(src2.x, src2.y);\n"
"ushort2 data = src_data1 ^ src_data2;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C2_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = (short2)(src2.x, src2.y);\n"
"short2 data = src_data1 ^ src_data2;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C2_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 data = src_data1 ^ src_data2;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C2_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"char8 src1_data = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src2_data = (char8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char8 tmp_data = src1_data ^ src2_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_xor_C2_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"short8 src1_data = *((__global short8 *)((__global char *)src1 + src1_index));\n"
"short8 src2_data = (short8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short8 tmp_data = src1_data ^ src2_data;\n"
"*((__global short8 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_xor_C3_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = (uchar4)(src2.x, src2.y, src2.z, src2.x);\n"
"uchar4 src2_data_1 = (uchar4)(src2.y, src2.z, src2.x, src2.y);\n"
"uchar4 src2_data_2 = (uchar4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"uchar4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"uchar4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0.xyz = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C3_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"char4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"char4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"char4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"char4 src2_data_0 = (char4)(src2.x, src2.y, src2.z, src2.x);\n"
"char4 src2_data_1 = (char4)(src2.y, src2.z, src2.x, src2.y);\n"
"char4 src2_data_2 = (char4)(src2.z, src2.x, src2.y, src2.z);\n"
"char4 data_0 = *((__global char4 *)(dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)(dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)(dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0.xyz = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global char4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global char4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global char4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C3_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = (ushort2)(src2.x, src2.y);\n"
"ushort2 src2_data_1 = (ushort2)(src2.z, src2.x);\n"
"ushort2 src2_data_2 = (ushort2)(src2.y, src2.z);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"ushort2 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"ushort2 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C3_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = (short2)(src2.x, src2.y);\n"
"short2 src2_data_1 = (short2)(src2.z, src2.x);\n"
"short2 src2_data_2 = (short2)(src2.y, src2.z);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"short2 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"short2 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C3_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"int tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"int tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C3_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"char4 src1_data_0 = *((__global char4 *)((__global char *)src1 + src1_index + 0));\n"
"char4 src1_data_1 = *((__global char4 *)((__global char *)src1 + src1_index + 4));\n"
"char4 src1_data_2 = *((__global char4 *)((__global char *)src1 + src1_index + 8));\n"
"char4 src2_data_0 = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 src2_data_1 = (char4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char4 src2_data_2 = (char4)(src2.s8, src2.s9, src2.sA, src2.sB);\n"
"char4 data_0 = *((__global char4 *)((__global char *)dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)((__global char *)dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)((__global char *)dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_xor_C3_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0 ));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8 ));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"short4 data_0 = *((__global short4 *)((__global char *)dst + dst_index + 0 ));\n"
"short4 data_1 = *((__global short4 *)((__global char *)dst + dst_index + 8 ));\n"
"short4 data_2 = *((__global short4 *)((__global char *)dst + dst_index + 16));\n"
"short4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"short4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"short4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0 ))= tmp_data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8 ))= tmp_data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16))= tmp_data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_xor_C4_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 data = src_data1 ^ src2;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C4_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"char4 src_data1 = *((__global char4 *)(src1 + src1_index));\n"
"char4 data = src_data1 ^ src2;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C4_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 data = src_data1 ^ src2;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C4_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 data = src_data1 ^ src2;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C4_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 data = src_data1 ^ src2;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_C4_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"char16 src1_data = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src2_data = (char16)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7,\n"
"src2.s8, src2.s9, src2.sa, src2.sb, src2.sc, src2.sd, src2.se, src2.sf);\n"
"char16 tmp_data = src1_data ^ src2_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_xor_C4_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src1_data_3 = *((__global short4 *)((__global char *)src1 + src1_index + 24));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"short4 src2_data_3 = (short4)(src2.sc, src2.sd, src2.se, src2.sf);\n"
"short4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"short4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"short4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"short4 tmp_data_3 = src1_data_3 ^ src2_data_3;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0 ))= tmp_data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8 ))= tmp_data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16))= tmp_data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 24))= tmp_data_3;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_bitwise_xor_scalar_mask="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C1_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data ^ src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C1_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data ^ src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C1_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar  *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = (ushort2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"ushort2 tmp_data = src1_data ^ src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C1_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = (short2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"short2 tmp_data = src1_data ^ src2_data;\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C1_D4 (\n"
"__global   int   *src1, int src1_step, int src1_offset,\n"
"__global   int   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C1_D5 (\n"
"__global char *src1, int src1_step, int src1_offset,\n"
"__global char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src1_data = *((__global char4 *)((__global char *)src1 + src1_index));\n"
"char4 src2_data = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 dst_data  = *((__global char4 *)((__global char *)dst  + dst_index));\n"
"char4 data = src1_data ^ src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C1_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src1_data = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = src1_data ^ src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C2_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = (uchar4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = src1_data ^ src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C2_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"char4 src1_data = vload4(0, src1 + src1_index);\n"
"char4 src2_data = (char4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"char4 data = *((__global char4 *)(dst + dst_index));\n"
"char4 tmp_data = src1_data ^ src2_data;\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C2_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = (ushort2)(src2.x, src2.y);\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"ushort2 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C2_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = (short2)(src2.x, src2.y);\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"short2 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C2_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = src_data1 ^ src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C2_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global  char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char8 src1_data = *((__global char8 *)((__global char *)src1 + src1_index));\n"
"char8 src2_data = (char8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char8 dst_data = *((__global char8 *)((__global char *)dst  + dst_index));\n"
"char8 data = src1_data ^ src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C2_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short8 src1_data = *((__global short8 *)((__global char *)src1 + src1_index));\n"
"short8 src2_data = (short8)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short8 dst_data = *((__global short8 *)((__global char *)dst  + dst_index));\n"
"short8 data = src1_data ^ src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short8 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C3_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = (uchar4)(src2.x, src2.y, src2.z, src2.x);\n"
"uchar4 src2_data_1 = (uchar4)(src2.y, src2.z, src2.x, src2.y);\n"
"uchar4 src2_data_2 = (uchar4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"uchar4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"uchar4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C3_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"char4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"char4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"char4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"char4 src2_data_0 = (char4)(src2.x, src2.y, src2.z, src2.x);\n"
"char4 src2_data_1 = (char4)(src2.y, src2.z, src2.x, src2.y);\n"
"char4 src2_data_2 = (char4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)(dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)(dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)(dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global char4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global char4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global char4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C3_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = (ushort2)(src2.x, src2.y);\n"
"ushort2 src2_data_1 = (ushort2)(src2.z, src2.x);\n"
"ushort2 src2_data_2 = (ushort2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"ushort2 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"ushort2 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C3_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = (short2)(src2.x, src2.y);\n"
"short2 src2_data_1 = (short2)(src2.z, src2.x);\n"
"short2 src2_data_2 = (short2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"short2 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"short2 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C3_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"int tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"int tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C3_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"char4 src1_data_0 = *((__global char4 *)((__global char *)src1 + src1_index + 0));\n"
"char4 src1_data_1 = *((__global char4 *)((__global char *)src1 + src1_index + 4));\n"
"char4 src1_data_2 = *((__global char4 *)((__global char *)src1 + src1_index + 8));\n"
"char4 src2_data_0 = (char4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"char4 src2_data_1 = (char4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"char4 src2_data_2 = (char4)(src2.s8, src2.s9, src2.sA, src2.sB);\n"
"uchar mask_data = * (mask + mask_index);\n"
"char4 data_0 = *((__global char4 *)((__global char *)dst + dst_index + 0));\n"
"char4 data_1 = *((__global char4 *)((__global char *)dst + dst_index + 4));\n"
"char4 data_2 = *((__global char4 *)((__global char *)dst + dst_index + 8));\n"
"char4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"char4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"char4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global char4 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C3_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0 ));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8 ));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"uchar mask_data = * (mask + mask_index);\n"
"short4 data_0 = *((__global short4 *)((__global char *)dst + dst_index + 0 ));\n"
"short4 data_1 = *((__global short4 *)((__global char *)dst + dst_index + 8 ));\n"
"short4 data_2 = *((__global short4 *)((__global char *)dst + dst_index + 16));\n"
"short4 tmp_data_0 = src1_data_0 ^ src2_data_0;\n"
"short4 tmp_data_1 = src1_data_1 ^ src2_data_1;\n"
"short4 tmp_data_2 = src1_data_2 ^ src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C4_D0 (\n"
"__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"uchar4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 data = src_data1 ^ src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C4_D1 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char4 src_data1 = *((__global char4 *)(src1 + src1_index));\n"
"char4 dst_data  = *((__global char4 *)(dst  + dst_index));\n"
"char4 data = src_data1 ^ src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C4_D2 (\n"
"__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"ushort4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"ushort4 data = src_data1 ^ src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C4_D3 (\n"
"__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"short4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = src_data1 ^ src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C4_D4 (\n"
"__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"int4 data = src_data1 ^ src2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C4_D5 (\n"
"__global   char *src1, int src1_step, int src1_offset,\n"
"__global   char *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"char16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"char16 src1_data = *((__global char16 *)((__global char *)src1 + src1_index));\n"
"char16 src2_data = (char16)(src2.s0, src2.s1, src2.s2, src2.s3, src2.s4, src2.s5, src2.s6, src2.s7,\n"
"src2.s8, src2.s9, src2.sa, src2.sb, src2.sc, src2.sd, src2.se, src2.sf);\n"
"char16 dst_data  = *((__global char16 *)((__global char *)dst  + dst_index));\n"
"char16 data = src1_data ^ src2_data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global char16 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_bitwise_xor_with_mask_C4_D6 (\n"
"__global short *src1, int src1_step, int src1_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"short16 src2, int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src1_data_0 = *((__global short4 *)((__global char *)src1 + src1_index + 0));\n"
"short4 src1_data_1 = *((__global short4 *)((__global char *)src1 + src1_index + 8));\n"
"short4 src1_data_2 = *((__global short4 *)((__global char *)src1 + src1_index + 16));\n"
"short4 src1_data_3 = *((__global short4 *)((__global char *)src1 + src1_index + 24));\n"
"short4 src2_data_0 = (short4)(src2.s0, src2.s1, src2.s2, src2.s3);\n"
"short4 src2_data_1 = (short4)(src2.s4, src2.s5, src2.s6, src2.s7);\n"
"short4 src2_data_2 = (short4)(src2.s8, src2.s9, src2.sa, src2.sb);\n"
"short4 src2_data_3 = (short4)(src2.sc, src2.sd, src2.se, src2.sf);\n"
"short4 dst_data_0  = *((__global short4 *)((__global char *)dst  + dst_index + 0));\n"
"short4 dst_data_1  = *((__global short4 *)((__global char *)dst  + dst_index + 8));\n"
"short4 dst_data_2  = *((__global short4 *)((__global char *)dst  + dst_index + 16));\n"
"short4 dst_data_3  = *((__global short4 *)((__global char *)dst  + dst_index + 24));\n"
"short4 data_0 = src1_data_0 ^ src2_data_0;\n"
"short4 data_1 = src1_data_1 ^ src2_data_1;\n"
"short4 data_2 = src1_data_2 ^ src2_data_2;\n"
"short4 data_3 = src1_data_3 ^ src2_data_3;\n"
"data_0 = mask_data ? data_0 : dst_data_0;\n"
"data_1 = mask_data ? data_1 : dst_data_1;\n"
"data_2 = mask_data ? data_2 : dst_data_2;\n"
"data_3 = mask_data ? data_3 : dst_data_3;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 0)) = data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 8)) = data_1;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 16)) = data_2;\n"
"*((__global short4 *)((__global char *)dst + dst_index + 24)) = data_3;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_cartToPolar="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define CV_PI   3.1415926535897932384626433832795\n"
"#ifndef DBL_EPSILON\n"
"#define DBL_EPSILON 0x1.0p-52\n"
"#endif\n"
"__kernel void arithm_cartToPolar_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst1, int dst1_step, int dst1_offset,\n"
"__global float *dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int angInDegree)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst1_index = mad24(y, dst1_step, (x << 2) + dst1_offset);\n"
"int dst2_index = mad24(y, dst2_step, (x << 2) + dst2_offset);\n"
"float x = *((__global float *)((__global char *)src1 + src1_index));\n"
"float y = *((__global float *)((__global char *)src2 + src2_index));\n"
"float x2 = x * x;\n"
"float y2 = y * y;\n"
"float magnitude = sqrt(x2 + y2);\n"
"float cartToPolar;\n"
"float tmp = y >= 0 ? 0 : CV_PI*2;\n"
"tmp = x < 0 ? CV_PI : tmp;\n"
"float tmp1 = y >= 0 ? CV_PI*0.5 : CV_PI*1.5;\n"
"cartToPolar = y2 <= x2 ? x*y/(x2 + 0.28f*y2 + (float)DBL_EPSILON)  + tmp :\n"
"tmp1 - x*y/(y2 + 0.28f*x2 + (float)DBL_EPSILON);\n"
"cartToPolar = angInDegree == 0 ? cartToPolar : cartToPolar * (float)(180/CV_PI);\n"
"*((__global float *)((__global char *)dst1 + dst1_index)) = magnitude;\n"
"*((__global float *)((__global char *)dst2 + dst2_index)) = cartToPolar;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_cartToPolar_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst1, int dst1_step, int dst1_offset,\n"
"__global double *dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int angInDegree)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst1_index = mad24(y, dst1_step, (x << 3) + dst1_offset);\n"
"int dst2_index = mad24(y, dst2_step, (x << 3) + dst2_offset);\n"
"double x = *((__global double *)((__global char *)src1 + src1_index));\n"
"double y = *((__global double *)((__global char *)src2 + src2_index));\n"
"double x2 = x * x;\n"
"double y2 = y * y;\n"
"double magnitude = sqrt(x2 + y2);\n"
"double cartToPolar;\n"
"float tmp = y >= 0 ? 0 : CV_PI*2;\n"
"tmp = x < 0 ? CV_PI : tmp;\n"
"float tmp1 = y >= 0 ? CV_PI*0.5 : CV_PI*1.5;\n"
"cartToPolar = y2 <= x2 ? x*y/(x2 + 0.28f*y2 + (float)DBL_EPSILON)  + tmp :\n"
"tmp1 - x*y/(y2 + 0.28f*x2 + (float)DBL_EPSILON);\n"
"cartToPolar = angInDegree == 0 ? cartToPolar : cartToPolar * (float)(180/CV_PI);\n"
"*((__global double *)((__global char *)dst1 + dst1_index)) = magnitude;\n"
"*((__global double *)((__global char *)dst2 + dst2_index)) = cartToPolar;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_compare_eq="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_compare_eq_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data == src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_ne_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data == src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_eq_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data == src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_eq_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"int4 src1_data = vload4(0, (__global int *)((__global char *)src1 + src1_index));\n"
"int4 src2_data = vload4(0, (__global int *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data == src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_eq_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"float4 src1_data = vload4(0, (__global float *)((__global char *)src1 + src1_index_fix));\n"
"float4 src2_data = vload4(0, (__global float *)((__global char *)src2 + src2_index_fix));\n"
"if(src2_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data == src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_compare_eq_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 3) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset - (dst_align << 3));\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset - (dst_align << 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"double4 src1_data = vload4(0, (__global double *)((__global char *)src1 + src1_index_fix));\n"
"double4 src2_data = vload4(0, (__global double *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data == src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_compare_gt_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data > src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_gt_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data > src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_gt_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data > src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_gt_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"int4 src1_data = vload4(0, (__global int *)((__global char *)src1 + src1_index));\n"
"int4 src2_data = vload4(0, (__global int *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data > src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_gt_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"float4 src1_data = vload4(0, (__global float *)((__global char *)src1 + src1_index_fix));\n"
"float4 src2_data = vload4(0, (__global float *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data > src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_compare_gt_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 3) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset - (dst_align << 3));\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset - (dst_align << 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"double4 src1_data = vload4(0, (__global double *)((__global char *)src1 + src1_index_fix));\n"
"double4 src2_data = vload4(0, (__global double *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data > src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_compare_ge_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data >= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_ge_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data >= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_ge_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data >= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_ge_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"int4 src1_data = vload4(0, (__global int *)((__global char *)src1 + src1_index));\n"
"int4 src2_data = vload4(0, (__global int *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data >= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_ge_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"float4 src1_data = vload4(0, (__global float *)((__global char *)src1 + src1_index_fix));\n"
"float4 src2_data = vload4(0, (__global float *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data >= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_compare_ge_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 3)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset - (dst_align << 3));\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset - (dst_align << 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"double4 src1_data = vload4(0, (__global double *)((__global char *)src1 + src1_index_fix));\n"
"double4 src2_data = vload4(0, (__global double *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data >= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_compare_ne="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_compare_ne_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data != src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_ne_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data != src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_ne_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data != src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_ne_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"int4 src1_data = vload4(0, (__global int *)((__global char *)src1 + src1_index));\n"
"int4 src2_data = vload4(0, (__global int *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data != src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_ne_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"float4 src1_data = vload4(0, (__global float *)((__global char *)src1 + src1_index_fix));\n"
"float4 src2_data = vload4(0, (__global float *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data != src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_compare_ne_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 3) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset - (dst_align << 3));\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset - (dst_align << 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"double4 src1_data = vload4(0, (__global double *)((__global char *)src1 + src1_index_fix));\n"
"double4 src2_data = vload4(0, (__global double *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data != src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_compare_lt_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global  uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data < src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_lt_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data < src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_lt_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data < src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_lt_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"int4 src1_data = vload4(0, (__global int *)((__global char *)src1 + src1_index));\n"
"int4 src2_data = vload4(0, (__global int *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data < src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_lt_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"float4 src1_data = vload4(0, (__global float *)((__global char *)src1 + src1_index_fix));\n"
"float4 src2_data = vload4(0, (__global float *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data < src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_compare_lt_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 3) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset - (dst_align << 3));\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset - (dst_align << 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"double4 src1_data = vload4(0, (__global double *)((__global char *)src1 + src1_index_fix));\n"
"double4 src2_data = vload4(0, (__global double *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data < src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_compare_le_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"uchar4 src1_data = vload4(0, src1 + src1_index_fix);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index_fix);\n"
"if(src1_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data <= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_le_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data <= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_le_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data <= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_le_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"int4 src1_data = vload4(0, (__global int *)((__global char *)src1 + src1_index));\n"
"int4 src2_data = vload4(0, (__global int *)((__global char *)src2 + src2_index));\n"
"if(src1_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"int4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data =convert_uchar4((src1_data <= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_compare_le_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 2)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"float4 src1_data = vload4(0, (__global float *)((__global char *)src1 + src1_index_fix));\n"
"float4 src2_data = vload4(0, (__global float *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data <= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_compare_le_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 3)& 3)\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset - (dst_align << 3));\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset - (dst_align << 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"double4 src1_data = vload4(0, (__global double *)((__global char *)src1 + src1_index_fix));\n"
"double4 src2_data = vload4(0, (__global double *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"double4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 tmp_data = convert_uchar4((src1_data <= src2_data));\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_div="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"typedef double F ;\n"
"typedef double4 F4;\n"
"#define convert_F4 convert_double4\n"
"#define convert_F  double\n"
"#else\n"
"typedef float F;\n"
"typedef float4 F4;\n"
"#define convert_F4 convert_float4\n"
"#define convert_F  float\n"
"#endif\n"
"inline uchar round2_uchar(F v)\n"
"{\n"
"return convert_uchar_sat(round(v));\n"
"}\n"
"inline ushort round2_ushort(F v)\n"
"{\n"
"return convert_ushort_sat(round(v));\n"
"}\n"
"inline short round2_short(F v)\n"
"{\n"
"return convert_short_sat(round(v));\n"
"}\n"
"inline int round2_int(F v)\n"
"{\n"
"return convert_int_sat(round(v));\n"
"}\n"
"__kernel void arithm_div_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int2 coor = (int2)(get_global_id(0), get_global_id(1));\n"
"if (coor.x < cols && coor.y < rows)\n"
"{\n"
"coor.x = coor.x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int2 src_index = (int2)(mad24(coor.y, src1_step, coor.x + src1_offset - dst_align),\n"
"mad24(coor.y, src2_step, coor.x + src2_offset - dst_align));\n"
"int4 dst_args  = (int4)(mad24(coor.y, dst_step, dst_offset),\n"
"mad24(coor.y, dst_step, dst_offset + dst_step1),\n"
"mad24(coor.y, dst_step, dst_offset + coor.x & (int)0xfffffffc),\n"
"0);\n"
"uchar4 src1_data = vload4(0, src1 + src_index.x);\n"
"uchar4 src2_data = vload4(0, src2 + src_index.y);\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst + dst_args.z));\n"
"F4 tmp      = convert_F4(src1_data) * scalar;\n"
"uchar4 tmp_data;\n"
"tmp_data.x = ((tmp.x == 0) || (src2_data.x == 0)) ? 0 : round2_uchar(tmp.x / src2_data.x);\n"
"tmp_data.y = ((tmp.y == 0) || (src2_data.y == 0)) ? 0 : round2_uchar(tmp.y / src2_data.y);\n"
"tmp_data.z = ((tmp.z == 0) || (src2_data.z == 0)) ? 0 : round2_uchar(tmp.z / src2_data.z);\n"
"tmp_data.w = ((tmp.w == 0) || (src2_data.w == 0)) ? 0 : round2_uchar(tmp.w / src2_data.w);\n"
"dst_data.x = ((dst_args.z + 0 >= dst_args.x) && (dst_args.z + 0 < dst_args.y)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_args.z + 1 >= dst_args.x) && (dst_args.z + 1 < dst_args.y)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_args.z + 2 >= dst_args.x) && (dst_args.z + 2 < dst_args.y)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_args.z + 3 >= dst_args.x) && (dst_args.z + 3 < dst_args.y)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_args.z)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_div_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"F4 tmp   = convert_F4(src1_data) * scalar;\n"
"ushort4 tmp_data;\n"
"tmp_data.x = ((tmp.x == 0) || (src2_data.x == 0)) ? 0 : round2_ushort(tmp.x / (F)src2_data.x);\n"
"tmp_data.y = ((tmp.y == 0) || (src2_data.y == 0)) ? 0 : round2_ushort(tmp.y / (F)src2_data.y);\n"
"tmp_data.z = ((tmp.z == 0) || (src2_data.z == 0)) ? 0 : round2_ushort(tmp.z / (F)src2_data.z);\n"
"tmp_data.w = ((tmp.w == 0) || (src2_data.w == 0)) ? 0 : round2_ushort(tmp.w / (F)src2_data.w);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_div_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"F4 tmp   = convert_F4(src1_data) * scalar;\n"
"short4 tmp_data;\n"
"tmp_data.x = ((tmp.x == 0) || (src2_data.x == 0)) ? 0 : round2_short(tmp.x / (F)src2_data.x);\n"
"tmp_data.y = ((tmp.y == 0) || (src2_data.y == 0)) ? 0 : round2_short(tmp.y / (F)src2_data.y);\n"
"tmp_data.z = ((tmp.z == 0) || (src2_data.z == 0)) ? 0 : round2_short(tmp.z / (F)src2_data.z);\n"
"tmp_data.w = ((tmp.w == 0) || (src2_data.w == 0)) ? 0 : round2_short(tmp.w / (F)src2_data.w);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_div_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"F tmp  = (convert_F)(data1) * scalar;\n"
"int tmp_data = (tmp == 0 || data2 == 0) ? 0 : round2_int(tmp / (convert_F)(data2));\n"
"*((__global int *)((__global char *)dst + dst_index)) =tmp_data;\n"
"}\n"
"}\n"
"__kernel void arithm_div_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"F tmp  = (convert_F)(data1) * scalar;\n"
"float tmp_data = (tmp == 0 || data2 == 0) ? 0 : convert_float(tmp / (convert_F)(data2));\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_div_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, double scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"double tmp  = data1 * scalar;\n"
"double tmp_data = (tmp == 0 || data2 == 0) ? 0 : (tmp / data2);\n"
"*((__global double *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_div_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src_index = mad24(y, src_step, x + src_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src_data = vload4(0, src + src_index);\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst + dst_index));\n"
"uchar4 tmp_data;\n"
"tmp_data.x = ((scalar == 0) || (src_data.x == 0)) ? 0 : round2_uchar(scalar / (F)src_data.x);\n"
"tmp_data.y = ((scalar == 0) || (src_data.y == 0)) ? 0 : round2_uchar(scalar / (F)src_data.y);\n"
"tmp_data.z = ((scalar == 0) || (src_data.z == 0)) ? 0 : round2_uchar(scalar / (F)src_data.z);\n"
"tmp_data.w = ((scalar == 0) || (src_data.w == 0)) ? 0 : round2_uchar(scalar / (F)src_data.w);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_div_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src_index = mad24(y, src_step, (x << 1) + src_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"ushort4 src_data = vload4(0, (__global ushort *)((__global char *)src + src_index));\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"ushort4 tmp_data;\n"
"tmp_data.x = ((scalar == 0) || (src_data.x == 0)) ? 0 : round2_ushort(scalar / (F)src_data.x);\n"
"tmp_data.y = ((scalar == 0) || (src_data.y == 0)) ? 0 : round2_ushort(scalar / (F)src_data.y);\n"
"tmp_data.z = ((scalar == 0) || (src_data.z == 0)) ? 0 : round2_ushort(scalar / (F)src_data.z);\n"
"tmp_data.w = ((scalar == 0) || (src_data.w == 0)) ? 0 : round2_ushort(scalar / (F)src_data.w);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_div_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src_index = mad24(y, src_step, (x << 1) + src_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"short4 src_data = vload4(0, (__global short *)((__global char *)src + src_index));\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"short4 tmp_data;\n"
"tmp_data.x = ((scalar == 0) || (src_data.x == 0)) ? 0 : round2_short(scalar / (F)src_data.x);\n"
"tmp_data.y = ((scalar == 0) || (src_data.y == 0)) ? 0 : round2_short(scalar / (F)src_data.y);\n"
"tmp_data.z = ((scalar == 0) || (src_data.z == 0)) ? 0 : round2_short(scalar / (F)src_data.z);\n"
"tmp_data.w = ((scalar == 0) || (src_data.w == 0)) ? 0 : round2_short(scalar / (F)src_data.w);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_div_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src_index = mad24(y, src_step, (x << 2) + src_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data = *((__global int *)((__global char *)src + src_index));\n"
"int tmp_data = (scalar == 0 || data == 0) ? 0 : round2_int(scalar / (convert_F)(data));\n"
"*((__global int *)((__global char *)dst + dst_index)) =tmp_data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_div_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, F scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src_index = mad24(y, src_step, (x << 2) + src_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data = *((__global float *)((__global char *)src + src_index));\n"
"float tmp_data = (scalar == 0 || data == 0) ? 0 : convert_float(scalar / (convert_F)(data));\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_div_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, double scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src_index = mad24(y, src_step, (x << 3) + src_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double data = *((__global double *)((__global char *)src + src_index));\n"
"double tmp_data = (scalar == 0 || data == 0) ? 0 : (scalar / data);\n"
"*((__global double *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_exp="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void arithm_exp_D5(int rows, int cols, int srcStep, int dstStep, int srcOffset, int dstOffset, __global float *src, __global float *dst)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"int srcIdx = mad24( y, srcStep, x + srcOffset);\n"
"int dstIdx = mad24( y, dstStep, x + dstOffset);\n"
"float src_data = *((__global float *)((__global char *)src + srcIdx));\n"
"float dst_data = exp(src_data);\n"
"*((__global float *)((__global char *)dst + dstIdx)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_exp_D6(int rows, int cols, int srcStep, int dstStep, int srcOffset, int dstOffset, __global double *src, __global double *dst)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows )\n"
"{\n"
"x = x << 3;\n"
"int srcIdx = mad24( y, srcStep, x + srcOffset);\n"
"int dstIdx = mad24( y, dstStep, x + dstOffset);\n"
"double src_data = *((__global double *)((__global char *)src + srcIdx));\n"
"double dst_data = exp(src_data);\n"
"*((__global double *)((__global char *)dst + dstIdx )) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_flip="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void arithm_flip_rows_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src_index_0 = mad24(y,            src_step, x + src_offset - dst_align);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, x + src_offset - dst_align);\n"
"int dst_start_0  = mad24(y,            dst_step, dst_offset);\n"
"int dst_start_1  = mad24(rows - y - 1, dst_step, dst_offset);\n"
"int dst_end_0    = mad24(y,            dst_step, dst_offset + dst_step1);\n"
"int dst_end_1    = mad24(rows - y - 1, dst_step, dst_offset + dst_step1);\n"
"int dst_index_0  = mad24(y,            dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int dst_index_1  = mad24(rows - y - 1, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src_index_0 < 0 ? 0 : src_index_0;\n"
"int src2_index_fix = src_index_1 < 0 ? 0 : src_index_1;\n"
"uchar4 src_data_0 = vload4(0, src + src1_index_fix);\n"
"uchar4 src_data_1 = vload4(0, src + src2_index_fix);\n"
"if(src_index_0 < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src_index_0 == -2) ? src_data_0.zwxy:src_data_0.yzwx;\n"
"src_data_0.xyzw = (src_index_0 == -1) ? src_data_0.wxyz:tmp.xyzw;\n"
"}\n"
"if(src_index_1 < 0)\n"
"{\n"
"uchar4 tmp;\n"
"tmp.xyzw = (src_index_1 == -2) ? src_data_1.zwxy:src_data_1.yzwx;\n"
"src_data_1.xyzw = (src_index_1 == -1) ? src_data_1.wxyz:tmp.xyzw;\n"
"}\n"
"uchar4 dst_data_0 = *((__global uchar4 *)(dst + dst_index_0));\n"
"uchar4 dst_data_1 = *((__global uchar4 *)(dst + dst_index_1));\n"
"dst_data_0.x =  (dst_index_0 + 0 >= dst_start_0)                                   ? src_data_1.x : dst_data_0.x;\n"
"dst_data_0.y = ((dst_index_0 + 1 >= dst_start_0) && (dst_index_0 + 1 < dst_end_0)) ? src_data_1.y : dst_data_0.y;\n"
"dst_data_0.z = ((dst_index_0 + 2 >= dst_start_0) && (dst_index_0 + 2 < dst_end_0)) ? src_data_1.z : dst_data_0.z;\n"
"dst_data_0.w =  (dst_index_0 + 3 < dst_end_0)                                      ? src_data_1.w : dst_data_0.w;\n"
"dst_data_1.x =  (dst_index_1 + 0 >= dst_start_1)                                   ? src_data_0.x : dst_data_1.x;\n"
"dst_data_1.y = ((dst_index_1 + 1 >= dst_start_1) && (dst_index_1 + 1 < dst_end_1)) ? src_data_0.y : dst_data_1.y;\n"
"dst_data_1.z = ((dst_index_1 + 2 >= dst_start_1) && (dst_index_1 + 2 < dst_end_1)) ? src_data_0.z : dst_data_1.z;\n"
"dst_data_1.w =  (dst_index_1 + 3 < dst_end_1)                                      ? src_data_0.w : dst_data_1.w;\n"
"*((__global uchar4 *)(dst + dst_index_0)) = dst_data_0;\n"
"*((__global uchar4 *)(dst + dst_index_1)) = dst_data_1;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rows_D1 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src_index_0 = mad24(y,            src_step, x + src_offset - dst_align);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, x + src_offset - dst_align);\n"
"int dst_start_0  = mad24(y,            dst_step, dst_offset);\n"
"int dst_start_1  = mad24(rows - y - 1, dst_step, dst_offset);\n"
"int dst_end_0    = mad24(y,            dst_step, dst_offset + dst_step1);\n"
"int dst_end_1    = mad24(rows - y - 1, dst_step, dst_offset + dst_step1);\n"
"int dst_index_0  = mad24(y,            dst_step, dst_offset + x & (int)0xfffffffc);\n"
"int dst_index_1  = mad24(rows - y - 1, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"char4 src_data_0 = vload4(0, src + src_index_0);\n"
"char4 src_data_1 = vload4(0, src + src_index_1);\n"
"char4 dst_data_0 = *((__global char4 *)(dst + dst_index_0));\n"
"char4 dst_data_1 = *((__global char4 *)(dst + dst_index_1));\n"
"dst_data_0.x =  (dst_index_0 + 0 >= dst_start_0)                                   ? src_data_1.x : dst_data_0.x;\n"
"dst_data_0.y = ((dst_index_0 + 1 >= dst_start_0) && (dst_index_0 + 1 < dst_end_0)) ? src_data_1.y : dst_data_0.y;\n"
"dst_data_0.z = ((dst_index_0 + 2 >= dst_start_0) && (dst_index_0 + 2 < dst_end_0)) ? src_data_1.z : dst_data_0.z;\n"
"dst_data_0.w =  (dst_index_0 + 3 < dst_end_0)                                      ? src_data_1.w : dst_data_0.w;\n"
"dst_data_1.x =  (dst_index_1 + 0 >= dst_start_1)                                   ? src_data_0.x : dst_data_1.x;\n"
"dst_data_1.y = ((dst_index_1 + 1 >= dst_start_1) && (dst_index_1 + 1 < dst_end_1)) ? src_data_0.y : dst_data_1.y;\n"
"dst_data_1.z = ((dst_index_1 + 2 >= dst_start_1) && (dst_index_1 + 2 < dst_end_1)) ? src_data_0.z : dst_data_1.z;\n"
"dst_data_1.w =  (dst_index_1 + 3 < dst_end_1)                                      ? src_data_0.w : dst_data_1.w;\n"
"*((__global char4 *)(dst + dst_index_0)) = dst_data_0;\n"
"*((__global char4 *)(dst + dst_index_1)) = dst_data_1;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rows_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset >> 1) & 3) << 1)\n"
"int src_index_0 = mad24(y,            src_step, (x << 1) + src_offset - dst_align);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, (x << 1) + src_offset - dst_align);\n"
"int dst_start_0  = mad24(y,            dst_step, dst_offset);\n"
"int dst_start_1  = mad24(rows - y - 1, dst_step, dst_offset);\n"
"int dst_end_0    = mad24(y,            dst_step, dst_offset + dst_step1);\n"
"int dst_end_1    = mad24(rows - y - 1, dst_step, dst_offset + dst_step1);\n"
"int dst_index_0  = mad24(y,            dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"int dst_index_1  = mad24(rows - y - 1, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"ushort4 src_data_0 = vload4(0, (__global ushort *)((__global char *)src + src_index_0));\n"
"ushort4 src_data_1 = vload4(0, (__global ushort *)((__global char *)src + src_index_1));\n"
"ushort4 dst_data_0 = *((__global ushort4 *)((__global char *)dst + dst_index_0));\n"
"ushort4 dst_data_1 = *((__global ushort4 *)((__global char *)dst + dst_index_1));\n"
"dst_data_0.x =  (dst_index_0 + 0 >= dst_start_0)                                   ? src_data_1.x : dst_data_0.x;\n"
"dst_data_0.y = ((dst_index_0 + 2 >= dst_start_0) && (dst_index_0 + 2 < dst_end_0)) ? src_data_1.y : dst_data_0.y;\n"
"dst_data_0.z = ((dst_index_0 + 4 >= dst_start_0) && (dst_index_0 + 4 < dst_end_0)) ? src_data_1.z : dst_data_0.z;\n"
"dst_data_0.w =  (dst_index_0 + 6 < dst_end_0)                                      ? src_data_1.w : dst_data_0.w;\n"
"dst_data_1.x =  (dst_index_1 + 0 >= dst_start_1)                                   ? src_data_0.x : dst_data_1.x;\n"
"dst_data_1.y = ((dst_index_1 + 2 >= dst_start_1) && (dst_index_1 + 2 < dst_end_1)) ? src_data_0.y : dst_data_1.y;\n"
"dst_data_1.z = ((dst_index_1 + 4 >= dst_start_1) && (dst_index_1 + 4 < dst_end_1)) ? src_data_0.z : dst_data_1.z;\n"
"dst_data_1.w =  (dst_index_1 + 6 < dst_end_1)                                      ? src_data_0.w : dst_data_1.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index_0)) = dst_data_0;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index_1)) = dst_data_1;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rows_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (((dst_offset >> 1) & 3) << 1)\n"
"int src_index_0 = mad24(y,            src_step, (x << 1) + src_offset - dst_align);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, (x << 1) + src_offset - dst_align);\n"
"int dst_start_0  = mad24(y,            dst_step, dst_offset);\n"
"int dst_start_1  = mad24(rows - y - 1, dst_step, dst_offset);\n"
"int dst_end_0    = mad24(y,            dst_step, dst_offset + dst_step1);\n"
"int dst_end_1    = mad24(rows - y - 1, dst_step, dst_offset + dst_step1);\n"
"int dst_index_0  = mad24(y,            dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"int dst_index_1  = mad24(rows - y - 1, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"short4 src_data_0 = vload4(0, (__global short *)((__global char *)src + src_index_0));\n"
"short4 src_data_1 = vload4(0, (__global short *)((__global char *)src + src_index_1));\n"
"short4 dst_data_0 = *((__global short4 *)((__global char *)dst + dst_index_0));\n"
"short4 dst_data_1 = *((__global short4 *)((__global char *)dst + dst_index_1));\n"
"dst_data_0.x =  (dst_index_0 + 0 >= dst_start_0)                                   ? src_data_1.x : dst_data_0.x;\n"
"dst_data_0.y = ((dst_index_0 + 2 >= dst_start_0) && (dst_index_0 + 2 < dst_end_0)) ? src_data_1.y : dst_data_0.y;\n"
"dst_data_0.z = ((dst_index_0 + 4 >= dst_start_0) && (dst_index_0 + 4 < dst_end_0)) ? src_data_1.z : dst_data_0.z;\n"
"dst_data_0.w =  (dst_index_0 + 6 < dst_end_0)                                      ? src_data_1.w : dst_data_0.w;\n"
"dst_data_1.x =  (dst_index_1 + 0 >= dst_start_1)                                   ? src_data_0.x : dst_data_1.x;\n"
"dst_data_1.y = ((dst_index_1 + 2 >= dst_start_1) && (dst_index_1 + 2 < dst_end_1)) ? src_data_0.y : dst_data_1.y;\n"
"dst_data_1.z = ((dst_index_1 + 4 >= dst_start_1) && (dst_index_1 + 4 < dst_end_1)) ? src_data_0.z : dst_data_1.z;\n"
"dst_data_1.w =  (dst_index_1 + 6 < dst_end_1)                                      ? src_data_0.w : dst_data_1.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index_0)) = dst_data_0;\n"
"*((__global short4 *)((__global char *)dst + dst_index_1)) = dst_data_1;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rows_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 2) + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, (x << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 2) + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, (x << 2) + dst_offset);\n"
"int data0 = *((__global int *)((__global char *)src + src_index_0));\n"
"int data1 = *((__global int *)((__global char *)src + src_index_1));\n"
"*((__global int *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global int *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rows_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 2) + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, (x << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 2) + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, (x << 2) + dst_offset);\n"
"float data0 = *((__global float *)((__global char *)src + src_index_0));\n"
"float data1 = *((__global float *)((__global char *)src + src_index_1));\n"
"*((__global float *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global float *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_flip_rows_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 3) + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, (x << 3) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 3) + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, (x << 3) + dst_offset);\n"
"double data0 = *((__global double *)((__global char *)src + src_index_0));\n"
"double data1 = *((__global double *)((__global char *)src + src_index_1));\n"
"*((__global double *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global double *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_flip_cols_C1_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x)           + src_offset);\n"
"int src_index_1 = mad24(y, src_step, (cols - x -1) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x)           + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, (cols - x -1) + dst_offset);\n"
"uchar data0 = *(src + src_index_0);\n"
"uchar data1 = *(src + src_index_1);\n"
"*(dst + dst_index_0) = data1;\n"
"*(dst + dst_index_1) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C1_D1 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x)           + src_offset);\n"
"int src_index_1 = mad24(y, src_step, (cols - x -1) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x)           + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, (cols - x -1) + dst_offset);\n"
"char data0 = *(src + src_index_0);\n"
"char data1 = *(src + src_index_1);\n"
"*(dst + dst_index_0) = data1;\n"
"*(dst + dst_index_1) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C1_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 1)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 1) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 1) + dst_offset);\n"
"ushort data0 = *((__global ushort *)((__global char *)src + src_index_0));\n"
"ushort data1 = *((__global ushort *)((__global char *)src + src_index_1));\n"
"*((__global ushort *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global ushort *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C1_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 1)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 1) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 1) + dst_offset);\n"
"short data0 = *((__global short *)((__global char *)src + src_index_0));\n"
"short data1 = *((__global short *)((__global char *)src + src_index_1));\n"
"*((__global short *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global short *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C1_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"int data0 = *((__global int *)((__global char *)src + src_index_0));\n"
"int data1 = *((__global int *)((__global char *)src + src_index_1));\n"
"*((__global int *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global int *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C1_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"float data0 = *((__global float *)((__global char *)src + src_index_0));\n"
"float data1 = *((__global float *)((__global char *)src + src_index_1));\n"
"*((__global float *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global float *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_flip_cols_C1_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"double data0 = *((__global double *)((__global char *)src + src_index_0));\n"
"double data1 = *((__global double *)((__global char *)src + src_index_1));\n"
"*((__global double *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global double *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_flip_cols_C2_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 1)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 1) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 1) + dst_offset);\n"
"uchar2 data0 = *((__global uchar2 *)((__global char *)src + src_index_0));\n"
"uchar2 data1 = *((__global uchar2 *)((__global char *)src + src_index_1));\n"
"*((__global uchar2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global uchar2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C2_D1 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 1)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 1) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 1) + dst_offset);\n"
"char2 data0 = *((__global char2 *)((__global char *)src + src_index_0));\n"
"char2 data1 = *((__global char2 *)((__global char *)src + src_index_1));\n"
"*((__global char2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global char2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C2_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"ushort2 data0 = *((__global ushort2 *)((__global char *)src + src_index_0));\n"
"ushort2 data1 = *((__global ushort2 *)((__global char *)src + src_index_1));\n"
"*((__global ushort2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C2_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"short2 data0 = *((__global short2 *)((__global char *)src + src_index_0));\n"
"short2 data1 = *((__global short2 *)((__global char *)src + src_index_1));\n"
"*((__global short2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global short2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C2_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"int2 data0 = *((__global int2 *)((__global char *)src + src_index_0));\n"
"int2 data1 = *((__global int2 *)((__global char *)src + src_index_1));\n"
"*((__global int2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global int2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C2_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"float2 data0 = *((__global float2 *)((__global char *)src + src_index_0));\n"
"float2 data1 = *((__global float2 *)((__global char *)src + src_index_1));\n"
"*((__global float2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global float2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_flip_cols_C2_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 4)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 4) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 4)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 4) + dst_offset);\n"
"double2 data0 = *((__global double2 *)((__global char *)src + src_index_0));\n"
"double2 data1 = *((__global double2 *)((__global char *)src + src_index_1));\n"
"*((__global double2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global double2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_flip_cols_C3_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x) * 3           + src_offset);\n"
"int src_index_1 = mad24(y, src_step, (cols - x -1) * 3 + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x) * 3           + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, (cols - x -1) * 3 + dst_offset);\n"
"uchar data0_0 = *(src + src_index_0 + 0);\n"
"uchar data0_1 = *(src + src_index_0 + 1);\n"
"uchar data0_2 = *(src + src_index_0 + 2);\n"
"uchar data1_0 = *(src + src_index_1 + 0);\n"
"uchar data1_1 = *(src + src_index_1 + 1);\n"
"uchar data1_2 = *(src + src_index_1 + 2);\n"
"*(dst + dst_index_0 + 0 ) = data1_0;\n"
"*(dst + dst_index_0 + 1 ) = data1_1;\n"
"*(dst + dst_index_0 + 2 ) = data1_2;\n"
"*(dst + dst_index_1 + 0) = data0_0;\n"
"*(dst + dst_index_1 + 1) = data0_1;\n"
"*(dst + dst_index_1 + 2) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C3_D1 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x) * 3           + src_offset);\n"
"int src_index_1 = mad24(y, src_step, (cols - x -1) * 3 + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x) * 3           + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, (cols - x -1) * 3 + dst_offset);\n"
"char data0_0 = *(src + src_index_0 + 0);\n"
"char data0_1 = *(src + src_index_0 + 1);\n"
"char data0_2 = *(src + src_index_0 + 2);\n"
"char data1_0 = *(src + src_index_1 + 0);\n"
"char data1_1 = *(src + src_index_1 + 1);\n"
"char data1_2 = *(src + src_index_1 + 2);\n"
"*(dst + dst_index_0 + 0 ) = data1_0;\n"
"*(dst + dst_index_0 + 1 ) = data1_1;\n"
"*(dst + dst_index_0 + 2 ) = data1_2;\n"
"*(dst + dst_index_1 + 0) = data0_0;\n"
"*(dst + dst_index_1 + 1) = data0_1;\n"
"*(dst + dst_index_1 + 2) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C3_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x * 3 << 1)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) * 3 << 1) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x * 3 << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) * 3 << 1) + dst_offset);\n"
"ushort data0_0 = *((__global ushort *)((__global char *)src + src_index_0 + 0));\n"
"ushort data0_1 = *((__global ushort *)((__global char *)src + src_index_0 + 2));\n"
"ushort data0_2 = *((__global ushort *)((__global char *)src + src_index_0 + 4));\n"
"ushort data1_0 = *((__global ushort *)((__global char *)src + src_index_1 + 0));\n"
"ushort data1_1 = *((__global ushort *)((__global char *)src + src_index_1 + 2));\n"
"ushort data1_2 = *((__global ushort *)((__global char *)src + src_index_1 + 4));\n"
"*((__global ushort *)((__global char *)dst + dst_index_0 + 0)) = data1_0;\n"
"*((__global ushort *)((__global char *)dst + dst_index_0 + 2)) = data1_1;\n"
"*((__global ushort *)((__global char *)dst + dst_index_0 + 4)) = data1_2;\n"
"*((__global ushort *)((__global char *)dst + dst_index_1 + 0)) = data0_0;\n"
"*((__global ushort *)((__global char *)dst + dst_index_1 + 2)) = data0_1;\n"
"*((__global ushort *)((__global char *)dst + dst_index_1 + 4)) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C3_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x * 3 << 1)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) * 3 << 1) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x * 3 << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) * 3 << 1) + dst_offset);\n"
"short data0_0 = *((__global short *)((__global char *)src + src_index_0 + 0));\n"
"short data0_1 = *((__global short *)((__global char *)src + src_index_0 + 2));\n"
"short data0_2 = *((__global short *)((__global char *)src + src_index_0 + 4));\n"
"short data1_0 = *((__global short *)((__global char *)src + src_index_1 + 0));\n"
"short data1_1 = *((__global short *)((__global char *)src + src_index_1 + 2));\n"
"short data1_2 = *((__global short *)((__global char *)src + src_index_1 + 4));\n"
"*((__global short *)((__global char *)dst + dst_index_0 + 0)) = data1_0;\n"
"*((__global short *)((__global char *)dst + dst_index_0 + 2)) = data1_1;\n"
"*((__global short *)((__global char *)dst + dst_index_0 + 4)) = data1_2;\n"
"*((__global short *)((__global char *)dst + dst_index_1 + 0)) = data0_0;\n"
"*((__global short *)((__global char *)dst + dst_index_1 + 2)) = data0_1;\n"
"*((__global short *)((__global char *)dst + dst_index_1 + 4)) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C3_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x * 3 << 2)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) * 3 << 2) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x * 3 << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) * 3 << 2) + dst_offset);\n"
"int data0_0 = *((__global int *)((__global char *)src + src_index_0 + 0));\n"
"int data0_1 = *((__global int *)((__global char *)src + src_index_0 + 4));\n"
"int data0_2 = *((__global int *)((__global char *)src + src_index_0 + 8));\n"
"int data1_0 = *((__global int *)((__global char *)src + src_index_1 + 0));\n"
"int data1_1 = *((__global int *)((__global char *)src + src_index_1 + 4));\n"
"int data1_2 = *((__global int *)((__global char *)src + src_index_1 + 8));\n"
"*((__global int *)((__global char *)dst + dst_index_0 + 0)) = data1_0;\n"
"*((__global int *)((__global char *)dst + dst_index_0 + 4)) = data1_1;\n"
"*((__global int *)((__global char *)dst + dst_index_0 + 8)) = data1_2;\n"
"*((__global int *)((__global char *)dst + dst_index_1 + 0)) = data0_0;\n"
"*((__global int *)((__global char *)dst + dst_index_1 + 4)) = data0_1;\n"
"*((__global int *)((__global char *)dst + dst_index_1 + 8)) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C3_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x * 3 << 2)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) * 3 << 2) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x * 3 << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) * 3 << 2) + dst_offset);\n"
"float data0_0 = *((__global float *)((__global char *)src + src_index_0 + 0));\n"
"float data0_1 = *((__global float *)((__global char *)src + src_index_0 + 4));\n"
"float data0_2 = *((__global float *)((__global char *)src + src_index_0 + 8));\n"
"float data1_0 = *((__global float *)((__global char *)src + src_index_1 + 0));\n"
"float data1_1 = *((__global float *)((__global char *)src + src_index_1 + 4));\n"
"float data1_2 = *((__global float *)((__global char *)src + src_index_1 + 8));\n"
"*((__global float *)((__global char *)dst + dst_index_0 + 0)) = data1_0;\n"
"*((__global float *)((__global char *)dst + dst_index_0 + 4)) = data1_1;\n"
"*((__global float *)((__global char *)dst + dst_index_0 + 8)) = data1_2;\n"
"*((__global float *)((__global char *)dst + dst_index_1 + 0)) = data0_0;\n"
"*((__global float *)((__global char *)dst + dst_index_1 + 4)) = data0_1;\n"
"*((__global float *)((__global char *)dst + dst_index_1 + 8)) = data0_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_flip_cols_C3_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x * 3 << 3)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) * 3 << 3) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x * 3 << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) * 3 << 3) + dst_offset);\n"
"double data0_0 = *((__global double *)((__global char *)src + src_index_0 + 0));\n"
"double data0_1 = *((__global double *)((__global char *)src + src_index_0 + 8));\n"
"double data0_2 = *((__global double *)((__global char *)src + src_index_0 + 16));\n"
"double data1_0 = *((__global double *)((__global char *)src + src_index_1 + 0));\n"
"double data1_1 = *((__global double *)((__global char *)src + src_index_1 + 8));\n"
"double data1_2 = *((__global double *)((__global char *)src + src_index_1 + 16));\n"
"*((__global double *)((__global char *)dst + dst_index_0 + 0 )) = data1_0;\n"
"*((__global double *)((__global char *)dst + dst_index_0 + 8 )) = data1_1;\n"
"*((__global double *)((__global char *)dst + dst_index_0 + 16)) = data1_2;\n"
"*((__global double *)((__global char *)dst + dst_index_1 + 0 )) = data0_0;\n"
"*((__global double *)((__global char *)dst + dst_index_1 + 8 )) = data0_1;\n"
"*((__global double *)((__global char *)dst + dst_index_1 + 16)) = data0_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_flip_cols_C4_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"uchar4 data0 = *((__global uchar4 *)(src + src_index_0));\n"
"uchar4 data1 = *((__global uchar4 *)(src + src_index_1));\n"
"*((__global uchar4 *)(dst + dst_index_0)) = data1;\n"
"*((__global uchar4 *)(dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C4_D1 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"char4 data0 = *((__global char4 *)(src + src_index_0));\n"
"char4 data1 = *((__global char4 *)(src + src_index_1));\n"
"*((__global char4 *)(dst + dst_index_0)) = data1;\n"
"*((__global char4 *)(dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C4_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"ushort4 data0 = *((__global ushort4 *)((__global char *)src + src_index_0));\n"
"ushort4 data1 = *((__global ushort4 *)((__global char *)src + src_index_1));\n"
"*((__global ushort4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C4_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"short4 data0 = *((__global short4 *)((__global char *)src + src_index_0));\n"
"short4 data1 = *((__global short4 *)((__global char *)src + src_index_1));\n"
"*((__global short4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global short4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C4_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 4)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 4) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 4)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 4) + dst_offset);\n"
"int4 data0 = *((__global int4 *)((__global char *)src + src_index_0));\n"
"int4 data1 = *((__global int4 *)((__global char *)src + src_index_1));\n"
"*((__global int4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global int4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_cols_C4_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 4)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 4) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 4)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 4) + dst_offset);\n"
"float4 data0 = *((__global float4 *)((__global char *)src + src_index_0));\n"
"float4 data1 = *((__global float4 *)((__global char *)src + src_index_1));\n"
"*((__global float4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global float4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_flip_cols_C4_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < thread_cols && y < rows)\n"
"{\n"
"int src_index_0 = mad24(y, src_step, (x << 5)             + src_offset);\n"
"int src_index_1 = mad24(y, src_step, ((cols - x -1) << 5) + src_offset);\n"
"int dst_index_0 = mad24(y, dst_step, (x << 5)             + dst_offset);\n"
"int dst_index_1 = mad24(y, dst_step, ((cols - x -1) << 5) + dst_offset);\n"
"double4 data0 = *((__global double4 *)((__global char *)src + src_index_0));\n"
"double4 data1 = *((__global double4 *)((__global char *)src + src_index_1));\n"
"*((__global double4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global double4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_flip_rc="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void arithm_flip_rc_C1_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x)           + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, (cols - x -1) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x)           + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, (cols - x -1) + dst_offset);\n"
"uchar data0 = *(src + src_index_0);\n"
"uchar data1 = *(src + src_index_1);\n"
"*(dst + dst_index_0) = data1;\n"
"*(dst + dst_index_1) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C1_D1 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x)           + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, (cols - x -1) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x)           + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, (cols - x -1) + dst_offset);\n"
"char data0 = *(src + src_index_0);\n"
"char data1 = *(src + src_index_1);\n"
"*(dst + dst_index_0) = data1;\n"
"*(dst + dst_index_1) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C1_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 1)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 1) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 1) + dst_offset);\n"
"ushort data0 = *((__global ushort *)((__global char *)src + src_index_0));\n"
"ushort data1 = *((__global ushort *)((__global char *)src + src_index_1));\n"
"*((__global ushort *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global ushort *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C1_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 1)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 1) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 1) + dst_offset);\n"
"short data0 = *((__global short *)((__global char *)src + src_index_0));\n"
"short data1 = *((__global short *)((__global char *)src + src_index_1));\n"
"*((__global short *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global short *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C1_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"int data0 = *((__global int *)((__global char *)src + src_index_0));\n"
"int data1 = *((__global int *)((__global char *)src + src_index_1));\n"
"*((__global int *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global int *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C1_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"float data0 = *((__global float *)((__global char *)src + src_index_0));\n"
"float data1 = *((__global float *)((__global char *)src + src_index_1));\n"
"*((__global float *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global float *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_flip_rc_C1_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"double data0 = *((__global double *)((__global char *)src + src_index_0));\n"
"double data1 = *((__global double *)((__global char *)src + src_index_1));\n"
"*((__global double *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global double *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_flip_rc_C2_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 1)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 1) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 1) + dst_offset);\n"
"uchar2 data0 = *((__global uchar2 *)(src + src_index_0));\n"
"uchar2 data1 = *((__global uchar2 *)(src + src_index_1));\n"
"*((__global uchar2 *)(dst + dst_index_0)) = data1;\n"
"*((__global uchar2 *)(dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C2_D1 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 1)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 1) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 1) + dst_offset);\n"
"char2 data0 = *((__global char2 *)(src + src_index_0));\n"
"char2 data1 = *((__global char2 *)(src + src_index_1));\n"
"*((__global char2 *)(dst + dst_index_0)) = data1;\n"
"*((__global char2 *)(dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C2_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"ushort2 data0 = *((__global ushort2 *)((__global char *)src + src_index_0));\n"
"ushort2 data1 = *((__global ushort2 *)((__global char *)src + src_index_1));\n"
"*((__global ushort2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C2_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"short2 data0 = *((__global short2 *)((__global char *)src + src_index_0));\n"
"short2 data1 = *((__global short2 *)((__global char *)src + src_index_1));\n"
"*((__global short2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global short2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C2_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"int2 data0 = *((__global int2 *)((__global char *)src + src_index_0));\n"
"int2 data1 = *((__global int2 *)((__global char *)src + src_index_1));\n"
"*((__global int2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global int2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C2_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"float2 data0 = *((__global float2 *)((__global char *)src + src_index_0));\n"
"float2 data1 = *((__global float2 *)((__global char *)src + src_index_1));\n"
"*((__global float2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global float2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_flip_rc_C2_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 4)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 4) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 4)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 4) + dst_offset);\n"
"double2 data0 = *((__global double2 *)((__global char *)src + src_index_0));\n"
"double2 data1 = *((__global double2 *)((__global char *)src + src_index_1));\n"
"*((__global double2 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global double2 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_flip_rc_C3_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x * 3)            + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, (cols - x -1) * 3  + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x * 3)           + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, (cols - x -1) * 3 + dst_offset);\n"
"uchar data0_0 = *(src + src_index_0 + 0);\n"
"uchar data0_1 = *(src + src_index_0 + 1);\n"
"uchar data0_2 = *(src + src_index_0 + 2);\n"
"uchar data1_0 = *(src + src_index_1 + 0);\n"
"uchar data1_1 = *(src + src_index_1 + 1);\n"
"uchar data1_2 = *(src + src_index_1 + 2);\n"
"*(dst + dst_index_0 + 0 ) = data1_0;\n"
"*(dst + dst_index_0 + 1 ) = data1_1;\n"
"*(dst + dst_index_0 + 2 ) = data1_2;\n"
"*(dst + dst_index_1 + 0) = data0_0;\n"
"*(dst + dst_index_1 + 1) = data0_1;\n"
"*(dst + dst_index_1 + 2) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C3_D1 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x * 3)            + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, (cols - x -1) * 3  + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x * 3)           + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, (cols - x -1) * 3 + dst_offset);\n"
"char data0_0 = *(src + src_index_0 + 0);\n"
"char data0_1 = *(src + src_index_0 + 1);\n"
"char data0_2 = *(src + src_index_0 + 2);\n"
"char data1_0 = *(src + src_index_1 + 0);\n"
"char data1_1 = *(src + src_index_1 + 1);\n"
"char data1_2 = *(src + src_index_1 + 2);\n"
"*(dst + dst_index_0 + 0 ) = data1_0;\n"
"*(dst + dst_index_0 + 1 ) = data1_1;\n"
"*(dst + dst_index_0 + 2 ) = data1_2;\n"
"*(dst + dst_index_1 + 0) = data0_0;\n"
"*(dst + dst_index_1 + 1) = data0_1;\n"
"*(dst + dst_index_1 + 2) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C3_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x * 3 << 1)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) * 3 << 1) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x * 3 << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) * 3 << 1) + dst_offset);\n"
"ushort data0_0 = *((__global ushort *)((__global char *)src + src_index_0 + 0));\n"
"ushort data0_1 = *((__global ushort *)((__global char *)src + src_index_0 + 2));\n"
"ushort data0_2 = *((__global ushort *)((__global char *)src + src_index_0 + 4));\n"
"ushort data1_0 = *((__global ushort *)((__global char *)src + src_index_1 + 0));\n"
"ushort data1_1 = *((__global ushort *)((__global char *)src + src_index_1 + 2));\n"
"ushort data1_2 = *((__global ushort *)((__global char *)src + src_index_1 + 4));\n"
"*((__global ushort *)((__global char *)dst + dst_index_0 + 0)) = data1_0;\n"
"*((__global ushort *)((__global char *)dst + dst_index_0 + 2)) = data1_1;\n"
"*((__global ushort *)((__global char *)dst + dst_index_0 + 4)) = data1_2;\n"
"*((__global ushort *)((__global char *)dst + dst_index_1 + 0)) = data0_0;\n"
"*((__global ushort *)((__global char *)dst + dst_index_1 + 2)) = data0_1;\n"
"*((__global ushort *)((__global char *)dst + dst_index_1 + 4)) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C3_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x * 3 << 1)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) * 3 << 1) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x * 3 << 1)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) * 3 << 1) + dst_offset);\n"
"short data0_0 = *((__global short *)((__global char *)src + src_index_0 + 0));\n"
"short data0_1 = *((__global short *)((__global char *)src + src_index_0 + 2));\n"
"short data0_2 = *((__global short *)((__global char *)src + src_index_0 + 4));\n"
"short data1_0 = *((__global short *)((__global char *)src + src_index_1 + 0));\n"
"short data1_1 = *((__global short *)((__global char *)src + src_index_1 + 2));\n"
"short data1_2 = *((__global short *)((__global char *)src + src_index_1 + 4));\n"
"*((__global short *)((__global char *)dst + dst_index_0 + 0)) = data1_0;\n"
"*((__global short *)((__global char *)dst + dst_index_0 + 2)) = data1_1;\n"
"*((__global short *)((__global char *)dst + dst_index_0 + 4)) = data1_2;\n"
"*((__global short *)((__global char *)dst + dst_index_1 + 0)) = data0_0;\n"
"*((__global short *)((__global char *)dst + dst_index_1 + 2)) = data0_1;\n"
"*((__global short *)((__global char *)dst + dst_index_1 + 4)) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C3_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x * 3 << 2)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) * 3 << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x * 3 << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) * 3 << 2) + dst_offset);\n"
"int data0_0 = *((__global int *)((__global char *)src + src_index_0 + 0));\n"
"int data0_1 = *((__global int *)((__global char *)src + src_index_0 + 4));\n"
"int data0_2 = *((__global int *)((__global char *)src + src_index_0 + 8));\n"
"int data1_0 = *((__global int *)((__global char *)src + src_index_1 + 0));\n"
"int data1_1 = *((__global int *)((__global char *)src + src_index_1 + 4));\n"
"int data1_2 = *((__global int *)((__global char *)src + src_index_1 + 8));\n"
"*((__global int *)((__global char *)dst + dst_index_0 + 0)) = data1_0;\n"
"*((__global int *)((__global char *)dst + dst_index_0 + 4)) = data1_1;\n"
"*((__global int *)((__global char *)dst + dst_index_0 + 8)) = data1_2;\n"
"*((__global int *)((__global char *)dst + dst_index_1 + 0)) = data0_0;\n"
"*((__global int *)((__global char *)dst + dst_index_1 + 4)) = data0_1;\n"
"*((__global int *)((__global char *)dst + dst_index_1 + 8)) = data0_2;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C3_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x * 3 << 2)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) * 3 << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x * 3 << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) * 3 << 2) + dst_offset);\n"
"float data0_0 = *((__global float *)((__global char *)src + src_index_0 + 0));\n"
"float data0_1 = *((__global float *)((__global char *)src + src_index_0 + 4));\n"
"float data0_2 = *((__global float *)((__global char *)src + src_index_0 + 8));\n"
"float data1_0 = *((__global float *)((__global char *)src + src_index_1 + 0));\n"
"float data1_1 = *((__global float *)((__global char *)src + src_index_1 + 4));\n"
"float data1_2 = *((__global float *)((__global char *)src + src_index_1 + 8));\n"
"*((__global float *)((__global char *)dst + dst_index_0 + 0)) = data1_0;\n"
"*((__global float *)((__global char *)dst + dst_index_0 + 4)) = data1_1;\n"
"*((__global float *)((__global char *)dst + dst_index_0 + 8)) = data1_2;\n"
"*((__global float *)((__global char *)dst + dst_index_1 + 0)) = data0_0;\n"
"*((__global float *)((__global char *)dst + dst_index_1 + 4)) = data0_1;\n"
"*((__global float *)((__global char *)dst + dst_index_1 + 8)) = data0_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_flip_rc_C3_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x * 3 << 3)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) * 3 << 3) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x * 3 << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) * 3 << 3) + dst_offset);\n"
"double data0_0 = *((__global double *)((__global char *)src + src_index_0 + 0 ));\n"
"double data0_1 = *((__global double *)((__global char *)src + src_index_0 + 8 ));\n"
"double data0_2 = *((__global double *)((__global char *)src + src_index_0 + 16));\n"
"double data1_0 = *((__global double *)((__global char *)src + src_index_1 + 0 ));\n"
"double data1_1 = *((__global double *)((__global char *)src + src_index_1 + 8 ));\n"
"double data1_2 = *((__global double *)((__global char *)src + src_index_1 + 16));\n"
"*((__global double *)((__global char *)dst + dst_index_0 + 0 )) = data1_0;\n"
"*((__global double *)((__global char *)dst + dst_index_0 + 8 )) = data1_1;\n"
"*((__global double *)((__global char *)dst + dst_index_0 + 16)) = data1_2;\n"
"*((__global double *)((__global char *)dst + dst_index_1 + 0 )) = data0_0;\n"
"*((__global double *)((__global char *)dst + dst_index_1 + 8 )) = data0_1;\n"
"*((__global double *)((__global char *)dst + dst_index_1 + 16)) = data0_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_flip_rc_C4_D0 (__global uchar *src, int src_step, int src_offset,\n"
"__global uchar *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"uchar4 data0 = *((__global uchar4 *)(src + src_index_0));\n"
"uchar4 data1 = *((__global uchar4 *)(src + src_index_1));\n"
"*((__global uchar4 *)(dst + dst_index_0)) = data1;\n"
"*((__global uchar4 *)(dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C4_D1 (__global char *src, int src_step, int src_offset,\n"
"__global char *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 2)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 2) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 2)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 2) + dst_offset);\n"
"char4 data0 = *((__global char4 *)(src + src_index_0));\n"
"char4 data1 = *((__global char4 *)(src + src_index_1));\n"
"*((__global char4 *)(dst + dst_index_0)) = data1;\n"
"*((__global char4 *)(dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C4_D2 (__global ushort *src, int src_step, int src_offset,\n"
"__global ushort *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"ushort4 data0 = *((__global ushort4 *)((__global char *)src + src_index_0));\n"
"ushort4 data1 = *((__global ushort4 *)((__global char *)src + src_index_1));\n"
"*((__global ushort4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C4_D3 (__global short *src, int src_step, int src_offset,\n"
"__global short *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 3)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 3) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 3)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 3) + dst_offset);\n"
"short4 data0 = *((__global short4 *)((__global char *)src + src_index_0));\n"
"short4 data1 = *((__global short4 *)((__global char *)src + src_index_1));\n"
"*((__global short4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global short4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C4_D4 (__global int *src, int src_step, int src_offset,\n"
"__global int *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 4)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 4) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 4)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 4) + dst_offset);\n"
"int4 data0 = *((__global int4 *)((__global char *)src + src_index_0));\n"
"int4 data1 = *((__global int4 *)((__global char *)src + src_index_1));\n"
"*((__global int4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global int4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"__kernel void arithm_flip_rc_C4_D5 (__global float *src, int src_step, int src_offset,\n"
"__global float *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 4)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 4) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 4)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 4) + dst_offset);\n"
"float4 data0 = *((__global float4 *)((__global char *)src + src_index_0));\n"
"float4 data1 = *((__global float4 *)((__global char *)src + src_index_1));\n"
"*((__global float4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global float4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_flip_rc_C4_D6 (__global double *src, int src_step, int src_offset,\n"
"__global double *dst, int dst_step, int dst_offset,\n"
"int rows, int cols, int thread_rows, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < thread_rows)\n"
"{\n"
"int src_index_0 = mad24(y,            src_step, (x << 5)             + src_offset);\n"
"int src_index_1 = mad24(rows - y - 1, src_step, ((cols - x -1) << 5) + src_offset);\n"
"int dst_index_0 = mad24(y,            dst_step, (x << 5)             + dst_offset);\n"
"int dst_index_1 = mad24(rows - y - 1, dst_step, ((cols - x -1) << 5) + dst_offset);\n"
"double4 data0 = *((__global double4 *)((__global char *)src + src_index_0));\n"
"double4 data1 = *((__global double4 *)((__global char *)src + src_index_1));\n"
"*((__global double4 *)((__global char *)dst + dst_index_0)) = data1;\n"
"*((__global double4 *)((__global char *)dst + dst_index_1)) = data0;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_log="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define INF_FLOAT -88.029694\n"
"#define INF_DOUBLE -709.0895657128241\n"
"__kernel void arithm_log_D5(int rows, int cols, int srcStep, int dstStep, int srcOffset, int dstOffset, __global float *src, __global float *dst)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows )\n"
"{\n"
"x = x << 2;\n"
"int srcIdx = mad24( y, srcStep, x + srcOffset);\n"
"int dstIdx = mad24( y, dstStep, x + dstOffset);\n"
"float src_data = *((__global float *)((__global char *)src + srcIdx));\n"
"float dst_data = (src_data == 0) ? INF_FLOAT : log(fabs(src_data));\n"
"*((__global float *)((__global char *)dst + dstIdx)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_log_D6(int rows, int cols, int srcStep, int dstStep, int srcOffset, int dstOffset, __global double *src, __global double *dst)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows )\n"
"{\n"
"x = x << 3;\n"
"int srcIdx = mad24( y, srcStep, x + srcOffset);\n"
"int dstIdx = mad24( y, dstStep, x + dstOffset);\n"
"double src_data = *((__global double *)((__global char *)src + srcIdx));\n"
"double dst_data = (src_data == 0) ? INF_DOUBLE : log(fabs(src_data));\n"
"*((__global double *)((__global char *)dst + dstIdx)) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_LUT="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel\n"
"void LUT_C1_D0( __global uchar *dst,\n"
"__global const uchar *src,\n"
"__constant uchar *table,\n"
"int rows,\n"
"int cols,\n"
"int channels,\n"
"int whole_rows,\n"
"int whole_cols,\n"
"int src_offset,\n"
"int dst_offset,\n"
"int lut_offset,\n"
"int src_step,\n"
"int dst_step)\n"
"{\n"
"int gidx = get_global_id(0)<<2;\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"__local uchar l[256];\n"
"l[(lidy<<4)+lidx] = table[(lidy<<4)+lidx+lut_offset];\n"
"gidx = gidx >= cols-4?cols-4:gidx;\n"
"gidy = gidy >= rows?rows-1:gidy;\n"
"int src_index = src_offset + mad24(gidy,src_step,gidx);\n"
"int dst_index = dst_offset + mad24(gidy,dst_step,gidx);\n"
"uchar4 p,q;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"p.x = src[src_index];\n"
"p.y = src[src_index+1];\n"
"p.z = src[src_index+2];\n"
"p.w = src[src_index+3];\n"
"q.x = l[p.x];\n"
"q.y = l[p.y];\n"
"q.z = l[p.z];\n"
"q.w = l[p.w];\n"
"*(__global uchar4*)(dst + dst_index) = q;\n"
"}\n"
"__kernel\n"
"void LUT2_C1_D0( __global uchar *dst,\n"
"__global const uchar *src,\n"
"__constant uchar *table,\n"
"int rows,\n"
"int precols,\n"
"int channels,\n"
"int whole_rows,\n"
"int cols,\n"
"int src_offset,\n"
"int dst_offset,\n"
"int lut_offset,\n"
"int src_step,\n"
"int dst_step)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidy = get_local_id(1);\n"
"__local uchar l[256];\n"
"l[lidy] = table[lidy+lut_offset];\n"
"gidx = gidx >= precols ? cols+gidx : gidx;\n"
"gidy = gidy >= rows?rows-1:gidy;\n"
"int src_index = src_offset + mad24(gidy,src_step,gidx);\n"
"int dst_index = dst_offset + mad24(gidy,dst_step,gidx);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"uchar p = src[src_index];\n"
"uchar q = l[p];\n"
"dst[dst_index] = q;\n"
"}\n"
"__kernel\n"
"void LUT_C4_D0( __global uchar4 *dst,\n"
"__global uchar4 *src,\n"
"__constant uchar *table,\n"
"int rows,\n"
"int cols,\n"
"int channels,\n"
"int whole_rows,\n"
"int whole_cols,\n"
"int src_offset,\n"
"int dst_offset,\n"
"int lut_offset,\n"
"int src_step,\n"
"int dst_step)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"int src_index = mad24(gidy,src_step,gidx+src_offset);\n"
"int dst_index = mad24(gidy,dst_step,gidx+dst_offset);\n"
"__local uchar l[256];\n"
"l[lidy*16+lidx] = table[lidy*16+lidx+lut_offset];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gidx<cols && gidy<rows)\n"
"{\n"
"uchar4 p = src[src_index];\n"
"uchar4 q;\n"
"q.x = l[p.x];\n"
"q.y = l[p.y];\n"
"q.z = l[p.z];\n"
"q.w = l[p.w];\n"
"dst[dst_index] = q;\n"
"}\n"
"}\n"
;
const char* arithm_magnitude="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void arithm_magnitude_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"float tmp = sqrt(data1 * data1 + data2 * data2);\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_magnitude_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"double tmp = sqrt(data1 * data1 + data2 * data2);\n"
"*((__global double *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_magnitudeSqr="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void magnitudeSqr_C1_D5 (__global float *src1,int src1_step,int src1_offset,\n"
"__global float *src2, int src2_step,int src2_offset,\n"
"__global float *dst,  int dst_step,int dst_offset,\n"
"int rows,  int cols,int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset - (dst_align << 2));\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset - (dst_align << 2));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 2) -(dst_align << 2));\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"int src2_index_fix = src2_index < 0 ? 0 : src2_index;\n"
"float4 src1_data = vload4(0, (__global float  *)((__global char *)src1 + src1_index_fix));\n"
"float4 src2_data = vload4(0, (__global float *)((__global char *)src2 + src2_index_fix));\n"
"if(src1_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src1_index == -2) ? src1_data.zwxy:src1_data.yzwx;\n"
"src1_data.xyzw = (src1_index == -1) ? src1_data.wxyz:tmp.xyzw;\n"
"}\n"
"if(src2_index < 0)\n"
"{\n"
"float4 tmp;\n"
"tmp.xyzw = (src2_index == -2) ? src2_data.zwxy:src2_data.yzwx;\n"
"src2_data.xyzw = (src2_index == -1) ? src2_data.wxyz:tmp.xyzw;\n"
"}\n"
"float4 dst_data = *((__global float4 *)((__global char *)dst + dst_index));\n"
"float4   tmp_data  ;\n"
"tmp_data.x = src1_data.x * src1_data.x + src2_data.x * src2_data.x;\n"
"tmp_data.y = src1_data.y * src1_data.y + src2_data.y * src2_data.y;\n"
"tmp_data.z = src1_data.z * src1_data.z + src2_data.z * src2_data.z;\n"
"tmp_data.w = src1_data.w * src1_data.w + src2_data.w * src2_data.w;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 8 >= dst_start) && (dst_index + 8 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 12 >= dst_start) && (dst_index + 12 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void magnitudeSqr_C2_D5 (__global float *src1,int src1_step,int src1_offset,\n"
"__global float *dst,  int dst_step,int dst_offset,\n"
"int rows,  int cols,int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align ((dst_offset >> 2) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset - (dst_align << 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 2) -(dst_align << 2));\n"
"int src1_index_fix = src1_index < 0 ? 0 : src1_index;\n"
"float8 src1_data = vload8(0, (__global float  *)((__global char *)src1 + src1_index_fix));\n"
"if(src1_index==-6)\n"
"src1_data.s01234567 = src1_data.s67012345;\n"
"if(src1_index==-4)\n"
"src1_data.s01234567 = src1_data.s45670123;\n"
"if(src1_index== -2)\n"
"src1_data.s01234567 = src1_data.s23456701;\n"
"float4 dst_data = *((__global float4 *)((__global char *)dst + dst_index));\n"
"float4   tmp_data  ;\n"
"tmp_data.x = src1_data.s0 * src1_data.s0 + src1_data.s1 * src1_data.s1;\n"
"tmp_data.y = src1_data.s2 * src1_data.s2 + src1_data.s3 * src1_data.s3;\n"
"tmp_data.z = src1_data.s4 * src1_data.s4 + src1_data.s5 * src1_data.s5;\n"
"tmp_data.w = src1_data.s6 * src1_data.s6 + src1_data.s7 * src1_data.s7;\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 8 >= dst_start) && (dst_index + 8 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 12 >= dst_start) && (dst_index + 12 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_minMax="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#if defined (DEPTH_0)\n"
"#define VEC_TYPE uchar8\n"
"#define CONVERT_TYPE convert_uchar8\n"
"#define MIN_VAL 0\n"
"#define MAX_VAL 255\n"
"#endif\n"
"#if defined (DEPTH_1)\n"
"#define VEC_TYPE char8\n"
"#define CONVERT_TYPE convert_char8\n"
"#define MIN_VAL -128\n"
"#define MAX_VAL 127\n"
"#endif\n"
"#if defined (DEPTH_2)\n"
"#define VEC_TYPE ushort8\n"
"#define CONVERT_TYPE convert_ushort8\n"
"#define MIN_VAL 0\n"
"#define MAX_VAL 65535\n"
"#endif\n"
"#if defined (DEPTH_3)\n"
"#define VEC_TYPE short8\n"
"#define CONVERT_TYPE convert_short8\n"
"#define MIN_VAL -32768\n"
"#define MAX_VAL 32767\n"
"#endif\n"
"#if defined (DEPTH_4)\n"
"#define VEC_TYPE int8\n"
"#define CONVERT_TYPE convert_int8\n"
"#define MIN_VAL INT_MIN\n"
"#define MAX_VAL INT_MAX\n"
"#endif\n"
"#if defined (DEPTH_5)\n"
"#define VEC_TYPE float8\n"
"#define CONVERT_TYPE convert_float8\n"
"#define MIN_VAL (-FLT_MAX)\n"
"#define MAX_VAL FLT_MAX\n"
"#endif\n"
"#if defined (DEPTH_6)\n"
"#define VEC_TYPE double8\n"
"#define CONVERT_TYPE convert_double8\n"
"#define MIN_VAL (-DBL_MAX)\n"
"#define MAX_VAL DBL_MAX\n"
"#endif\n"
"#if defined (REPEAT_S0)\n"
"#define repeat_s(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_S1)\n"
"#define repeat_s(a) a.s0 = a.s1;\n"
"#endif\n"
"#if defined (REPEAT_S2)\n"
"#define repeat_s(a) a.s0 = a.s2;a.s1 = a.s2;\n"
"#endif\n"
"#if defined (REPEAT_S3)\n"
"#define repeat_s(a) a.s0 = a.s3;a.s1 = a.s3;a.s2 = a.s3;\n"
"#endif\n"
"#if defined (REPEAT_S4)\n"
"#define repeat_s(a) a.s0 = a.s4;a.s1 = a.s4;a.s2 = a.s4;a.s3 = a.s4;\n"
"#endif\n"
"#if defined (REPEAT_S5)\n"
"#define repeat_s(a) a.s0 = a.s5;a.s1 = a.s5;a.s2 = a.s5;a.s3 = a.s5;a.s4 = a.s5;\n"
"#endif\n"
"#if defined (REPEAT_S6)\n"
"#define repeat_s(a) a.s0 = a.s6;a.s1 = a.s6;a.s2 = a.s6;a.s3 = a.s6;a.s4 = a.s6;a.s5 = a.s6;\n"
"#endif\n"
"#if defined (REPEAT_S7)\n"
"#define repeat_s(a) a.s0 = a.s7;a.s1 = a.s7;a.s2 = a.s7;a.s3 = a.s7;a.s4 = a.s7;a.s5 = a.s7;a.s6 = a.s7;\n"
"#endif\n"
"#if defined (REPEAT_E0)\n"
"#define repeat_e(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_E1)\n"
"#define repeat_e(a) a.s7 = a.s6;\n"
"#endif\n"
"#if defined (REPEAT_E2)\n"
"#define repeat_e(a) a.s7 = a.s5;a.s6 = a.s5;\n"
"#endif\n"
"#if defined (REPEAT_E3)\n"
"#define repeat_e(a) a.s7 = a.s4;a.s6 = a.s4;a.s5 = a.s4;\n"
"#endif\n"
"#if defined (REPEAT_E4)\n"
"#define repeat_e(a) a.s7 = a.s3;a.s6 = a.s3;a.s5 = a.s3;a.s4 = a.s3;\n"
"#endif\n"
"#if defined (REPEAT_E5)\n"
"#define repeat_e(a) a.s7 = a.s2;a.s6 = a.s2;a.s5 = a.s2;a.s4 = a.s2;a.s3 = a.s2;\n"
"#endif\n"
"#if defined (REPEAT_E6)\n"
"#define repeat_e(a) a.s7 = a.s1;a.s6 = a.s1;a.s5 = a.s1;a.s4 = a.s1;a.s3 = a.s1;a.s2 = a.s1;\n"
"#endif\n"
"#if defined (REPEAT_E7)\n"
"#define repeat_e(a) a.s7 = a.s0;a.s6 = a.s0;a.s5 = a.s0;a.s4 = a.s0;a.s3 = a.s0;a.s2 = a.s0;a.s1 = a.s0;\n"
"#endif\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics:enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics:enable\n"
"__kernel void arithm_op_minMax (int cols,int invalid_cols,int offset,int elemnum,int groupnum,\n"
"__global VEC_TYPE *src, __global VEC_TYPE *dst)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"unsigned int  id = get_global_id(0);\n"
"unsigned int idx = offset + id + (id / cols) * invalid_cols;\n"
"__local VEC_TYPE localmem_max[128],localmem_min[128];\n"
"VEC_TYPE minval,maxval,temp;\n"
"if(id < elemnum)\n"
"{\n"
"temp = src[idx];\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp);\n"
"}\n"
"minval = temp;\n"
"maxval = temp;\n"
"}\n"
"else\n"
"{\n"
"minval = MAX_VAL;\n"
"maxval = MIN_VAL;\n"
"}\n"
"for(id=id + (groupnum << 8); id < elemnum;id = id + (groupnum << 8))\n"
"{\n"
"idx = offset + id + (id / cols) * invalid_cols;\n"
"temp = src[idx];\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp);\n"
"}\n"
"minval = min(minval,temp);\n"
"maxval = max(maxval,temp);\n"
"}\n"
"if(lid > 127)\n"
"{\n"
"localmem_min[lid - 128] = minval;\n"
"localmem_max[lid - 128] = maxval;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 128)\n"
"{\n"
"localmem_min[lid] = min(minval,localmem_min[lid]);\n"
"localmem_max[lid] = max(maxval,localmem_max[lid]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int lsize = 64; lsize > 0; lsize >>= 1)\n"
"{\n"
"if(lid < lsize)\n"
"{\n"
"int lid2 = lsize + lid;\n"
"localmem_min[lid] = min(localmem_min[lid] , localmem_min[lid2]);\n"
"localmem_max[lid] = max(localmem_max[lid] , localmem_max[lid2]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if( lid == 0)\n"
"{\n"
"dst[gid] = localmem_min[0];\n"
"dst[gid + groupnum] = localmem_max[0];\n"
"}\n"
"}\n"
;
const char* arithm_minMax_mask="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#if defined (DEPTH_0)\n"
"#define VEC_TYPE uchar8\n"
"#define TYPE uchar\n"
"#define CONVERT_TYPE convert_uchar8\n"
"#define MIN_VAL 0\n"
"#define MAX_VAL 255\n"
"#endif\n"
"#if defined (DEPTH_1)\n"
"#define VEC_TYPE char8\n"
"#define TYPE char\n"
"#define CONVERT_TYPE convert_char8\n"
"#define MIN_VAL -128\n"
"#define MAX_VAL 127\n"
"#endif\n"
"#if defined (DEPTH_2)\n"
"#define VEC_TYPE ushort8\n"
"#define TYPE ushort\n"
"#define CONVERT_TYPE convert_ushort8\n"
"#define MIN_VAL 0\n"
"#define MAX_VAL 65535\n"
"#endif\n"
"#if defined (DEPTH_3)\n"
"#define VEC_TYPE short8\n"
"#define TYPE short\n"
"#define CONVERT_TYPE convert_short8\n"
"#define MIN_VAL -32768\n"
"#define MAX_VAL 32767\n"
"#endif\n"
"#if defined (DEPTH_4)\n"
"#define VEC_TYPE int8\n"
"#define TYPE int\n"
"#define CONVERT_TYPE convert_int8\n"
"#define MIN_VAL INT_MIN\n"
"#define MAX_VAL INT_MAX\n"
"#endif\n"
"#if defined (DEPTH_5)\n"
"#define VEC_TYPE float8\n"
"#define TYPE float\n"
"#define CONVERT_TYPE convert_float8\n"
"#define MIN_VAL (-FLT_MAX)\n"
"#define MAX_VAL FLT_MAX\n"
"#endif\n"
"#if defined (DEPTH_6)\n"
"#define VEC_TYPE double8\n"
"#define TYPE double\n"
"#define CONVERT_TYPE convert_double8\n"
"#define MIN_VAL (-DBL_MAX)\n"
"#define MAX_VAL DBL_MAX\n"
"#endif\n"
"#if defined (REPEAT_E0)\n"
"#define repeat_me(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_E1)\n"
"#define repeat_me(a) a.s7 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E2)\n"
"#define repeat_me(a) a.s7 = 0;a.s6 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E3)\n"
"#define repeat_me(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E4)\n"
"#define repeat_me(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E5)\n"
"#define repeat_me(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;a.s3 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E6)\n"
"#define repeat_me(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;a.s3 = 0;a.s2 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E7)\n"
"#define repeat_me(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;a.s3 = 0;a.s2 = 0;a.s1 = 0;\n"
"#endif\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics:enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics:enable\n"
"__kernel void arithm_op_minMax_mask (int cols,int invalid_cols,int offset,int elemnum,int groupnum, __global TYPE *src,\n"
"int minvalid_cols,int moffset, __global uchar *mask,__global VEC_TYPE *dst)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"unsigned int  id = get_global_id(0);\n"
"unsigned int idx = id + (id / cols) * invalid_cols;\n"
"unsigned int midx = id + (id / cols) * minvalid_cols;\n"
"__local VEC_TYPE localmem_max[128],localmem_min[128];\n"
"VEC_TYPE minval,maxval,temp,m_temp;\n"
"if(id < elemnum)\n"
"{\n"
"temp = vload8(idx, &src[offset]);\n"
"m_temp = CONVERT_TYPE(vload8(midx,&mask[moffset]));\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_me(m_temp);\n"
"}\n"
"minval = m_temp != (VEC_TYPE)0 ? temp : (VEC_TYPE)MAX_VAL;\n"
"maxval = m_temp != (VEC_TYPE)0 ? temp : (VEC_TYPE)MIN_VAL;\n"
"}\n"
"else\n"
"{\n"
"minval = MAX_VAL;\n"
"maxval = MIN_VAL;\n"
"}\n"
"for(id=id + (groupnum << 8); id < elemnum;id = id + (groupnum << 8))\n"
"{\n"
"idx = id + (id / cols) * invalid_cols;\n"
"midx = id + (id / cols) * minvalid_cols;\n"
"temp = vload8(idx, &src[offset]);\n"
"m_temp = CONVERT_TYPE(vload8(midx,&mask[moffset]));\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_me(m_temp);\n"
"}\n"
"minval = min(minval,m_temp != (VEC_TYPE)0 ? temp : minval);\n"
"maxval = max(maxval,m_temp != (VEC_TYPE)0 ? temp : maxval);\n"
"}\n"
"if(lid > 127)\n"
"{\n"
"localmem_min[lid - 128] = minval;\n"
"localmem_max[lid - 128] = maxval;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 128)\n"
"{\n"
"localmem_min[lid] = min(minval,localmem_min[lid]);\n"
"localmem_max[lid] = max(maxval,localmem_max[lid]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int lsize = 64; lsize > 0; lsize >>= 1)\n"
"{\n"
"if(lid < lsize)\n"
"{\n"
"int lid2 = lsize + lid;\n"
"localmem_min[lid] = min(localmem_min[lid] , localmem_min[lid2]);\n"
"localmem_max[lid] = max(localmem_max[lid] , localmem_max[lid2]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if( lid == 0)\n"
"{\n"
"dst[gid] = localmem_min[0];\n"
"dst[gid + groupnum] = localmem_max[0];\n"
"}\n"
"}\n"
;
const char* arithm_minMaxLoc="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#define RES_TYPE double4\n"
"#define CONVERT_RES_TYPE convert_double4\n"
"#else\n"
"#define RES_TYPE float4\n"
"#define CONVERT_RES_TYPE convert_float4\n"
"#endif\n"
"#if defined (DEPTH_0)\n"
"#define VEC_TYPE uchar4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_uchar4\n"
"#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n"
"#define MIN_VAL 0\n"
"#define MAX_VAL 255\n"
"#endif\n"
"#if defined (DEPTH_1)\n"
"#define VEC_TYPE char4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_char4\n"
"#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n"
"#define MIN_VAL -128\n"
"#define MAX_VAL 127\n"
"#endif\n"
"#if defined (DEPTH_2)\n"
"#define VEC_TYPE ushort4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_ushort4\n"
"#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n"
"#define MIN_VAL 0\n"
"#define MAX_VAL 65535\n"
"#endif\n"
"#if defined (DEPTH_3)\n"
"#define VEC_TYPE short4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_short4\n"
"#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n"
"#define MIN_VAL -32768\n"
"#define MAX_VAL 32767\n"
"#endif\n"
"#if defined (DEPTH_4)\n"
"#define VEC_TYPE int4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_int4\n"
"#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n"
"#define MIN_VAL INT_MIN\n"
"#define MAX_VAL INT_MAX\n"
"#endif\n"
"#if defined (DEPTH_5)\n"
"#define VEC_TYPE float4\n"
"#define VEC_TYPE_LOC float4\n"
"#define CONVERT_TYPE convert_float4\n"
"#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n"
"#define MIN_VAL (-FLT_MAX)\n"
"#define MAX_VAL FLT_MAX\n"
"#endif\n"
"#if defined (DEPTH_6)\n"
"#define VEC_TYPE double4\n"
"#define VEC_TYPE_LOC double4\n"
"#define CONVERT_TYPE convert_double4\n"
"#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n"
"#define MIN_VAL (-DBL_MAX)\n"
"#define MAX_VAL DBL_MAX\n"
"#endif\n"
"#if defined (REPEAT_S0)\n"
"#define repeat_s(a) a=a;\n"
"#endif\n"
"#if defined (REPEAT_S1)\n"
"#define repeat_s(a) a.s0 = a.s1;\n"
"#endif\n"
"#if defined (REPEAT_S2)\n"
"#define repeat_s(a) a.s0 = a.s2;a.s1 = a.s2;\n"
"#endif\n"
"#if defined (REPEAT_S3)\n"
"#define repeat_s(a) a.s0 = a.s3;a.s1 = a.s3;a.s2 = a.s3;\n"
"#endif\n"
"#if defined (REPEAT_E0)\n"
"#define repeat_e(a) a=a;\n"
"#endif\n"
"#if defined (REPEAT_E1)\n"
"#define repeat_e(a) a.s3 = a.s2;\n"
"#endif\n"
"#if defined (REPEAT_E2)\n"
"#define repeat_e(a) a.s3 = a.s1;a.s2 = a.s1;\n"
"#endif\n"
"#if defined (REPEAT_E3)\n"
"#define repeat_e(a) a.s3 = a.s0;a.s2 = a.s0;a.s1 = a.s0;\n"
"#endif\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics:enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics:enable\n"
"__kernel void arithm_op_minMaxLoc (int cols,int invalid_cols,int offset,int elemnum,int groupnum,\n"
"__global VEC_TYPE *src, __global RES_TYPE *dst)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"unsigned int  id = get_global_id(0);\n"
"unsigned int idx = offset + id + (id / cols) * invalid_cols;\n"
"__local VEC_TYPE localmem_max[128],localmem_min[128];\n"
"VEC_TYPE minval,maxval,temp;\n"
"__local VEC_TYPE_LOC localmem_maxloc[128],localmem_minloc[128];\n"
"VEC_TYPE_LOC minloc,maxloc,temploc,negative = -1;\n"
"int idx_c;\n"
"if(id < elemnum)\n"
"{\n"
"temp = src[idx];\n"
"idx_c = idx << 2;\n"
"temploc = (VEC_TYPE_LOC)(idx_c,idx_c+1,idx_c+2,idx_c+3);\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp);\n"
"repeat_s(temploc);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp);\n"
"repeat_e(temploc);\n"
"}\n"
"minval = temp;\n"
"maxval = temp;\n"
"minloc = temploc;\n"
"maxloc = temploc;\n"
"}\n"
"else\n"
"{\n"
"minval = MAX_VAL;\n"
"maxval = MIN_VAL;\n"
"minloc = negative;\n"
"maxloc = negative;\n"
"}\n"
"float4 aaa;\n"
"for(id=id + (groupnum << 8); id < elemnum;id = id + (groupnum << 8))\n"
"{\n"
"idx = offset + id + (id / cols) * invalid_cols;\n"
"temp = src[idx];\n"
"idx_c = idx << 2;\n"
"temploc = (VEC_TYPE_LOC)(idx_c,idx_c+1,idx_c+2,idx_c+3);\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp);\n"
"repeat_s(temploc);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp);\n"
"repeat_e(temploc);\n"
"}\n"
"minval = min(minval,temp);\n"
"maxval = max(maxval,temp);\n"
"minloc = CONDITION_FUNC(minval == temp, temploc , minloc);\n"
"maxloc = CONDITION_FUNC(maxval == temp, temploc , maxloc);\n"
"aaa= convert_float4(maxval == temp);\n"
"maxloc = convert_int4(aaa) ? temploc : maxloc;\n"
"}\n"
"if(lid > 127)\n"
"{\n"
"localmem_min[lid - 128] = minval;\n"
"localmem_max[lid - 128] = maxval;\n"
"localmem_minloc[lid - 128] = minloc;\n"
"localmem_maxloc[lid - 128] = maxloc;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 128)\n"
"{\n"
"localmem_min[lid] = min(minval,localmem_min[lid]);\n"
"localmem_max[lid] = max(maxval,localmem_max[lid]);\n"
"localmem_minloc[lid] = CONDITION_FUNC(localmem_min[lid] == minval, minloc , localmem_minloc[lid]);\n"
"localmem_maxloc[lid] = CONDITION_FUNC(localmem_max[lid] == maxval, maxloc , localmem_maxloc[lid]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int lsize = 64; lsize > 0; lsize >>= 1)\n"
"{\n"
"if(lid < lsize)\n"
"{\n"
"int lid2 = lsize + lid;\n"
"localmem_min[lid] = min(localmem_min[lid] , localmem_min[lid2]);\n"
"localmem_max[lid] = max(localmem_max[lid] , localmem_max[lid2]);\n"
"localmem_minloc[lid] =\n"
"CONDITION_FUNC(localmem_min[lid] == localmem_min[lid2], localmem_minloc[lid2] , localmem_minloc[lid]);\n"
"localmem_maxloc[lid] =\n"
"CONDITION_FUNC(localmem_max[lid] == localmem_max[lid2], localmem_maxloc[lid2] , localmem_maxloc[lid]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if( lid == 0)\n"
"{\n"
"dst[gid] = CONVERT_RES_TYPE(localmem_min[0]);\n"
"dst[gid + groupnum] = CONVERT_RES_TYPE(localmem_max[0]);\n"
"dst[gid + 2 * groupnum] = CONVERT_RES_TYPE(localmem_minloc[0]);\n"
"dst[gid + 3 * groupnum] = CONVERT_RES_TYPE(localmem_maxloc[0]);\n"
"}\n"
"}\n"
"#if defined (REPEAT_S0)\n"
"#define repeat_ms(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_S1)\n"
"#define repeat_ms(a) a.s0 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S2)\n"
"#define repeat_ms(a) a.s0 = 0;a.s1 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S3)\n"
"#define repeat_ms(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E0)\n"
"#define repeat_me(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_E1)\n"
"#define repeat_me(a) a.s3 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E2)\n"
"#define repeat_me(a) a.s3 = 0;a.s2 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E3)\n"
"#define repeat_me(a) a.s3 = 0;a.s2 = 0;a.s1 = 0;\n"
"#endif\n"
;
const char* arithm_minMaxLoc_mask="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#define RES_TYPE double4\n"
"#define CONVERT_RES_TYPE convert_double4\n"
"#else\n"
"#define RES_TYPE float4\n"
"#define CONVERT_RES_TYPE convert_float4\n"
"#endif\n"
"#if defined (DEPTH_0)\n"
"#define TYPE uchar\n"
"#define VEC_TYPE uchar4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_uchar4\n"
"#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n"
"#define MIN_VAL 0\n"
"#define MAX_VAL 255\n"
"#endif\n"
"#if defined (DEPTH_1)\n"
"#define TYPE char\n"
"#define VEC_TYPE char4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_char4\n"
"#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n"
"#define MIN_VAL -128\n"
"#define MAX_VAL 127\n"
"#endif\n"
"#if defined (DEPTH_2)\n"
"#define TYPE ushort\n"
"#define VEC_TYPE ushort4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_ushort4\n"
"#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n"
"#define MIN_VAL 0\n"
"#define MAX_VAL 65535\n"
"#endif\n"
"#if defined (DEPTH_3)\n"
"#define TYPE short\n"
"#define VEC_TYPE short4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_short4\n"
"#define CONDITION_FUNC(a,b,c) (convert_int4(a) ? b : c)\n"
"#define MIN_VAL -32768\n"
"#define MAX_VAL 32767\n"
"#endif\n"
"#if defined (DEPTH_4)\n"
"#define TYPE int\n"
"#define VEC_TYPE int4\n"
"#define VEC_TYPE_LOC int4\n"
"#define CONVERT_TYPE convert_int4\n"
"#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n"
"#define MIN_VAL INT_MIN\n"
"#define MAX_VAL INT_MAX\n"
"#endif\n"
"#if defined (DEPTH_5)\n"
"#define TYPE float\n"
"#define VEC_TYPE float4\n"
"#define VEC_TYPE_LOC float4\n"
"#define CONVERT_TYPE convert_float4\n"
"#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n"
"#define MIN_VAL (-FLT_MAX)\n"
"#define MAX_VAL FLT_MAX\n"
"#endif\n"
"#if defined (DEPTH_6)\n"
"#define TYPE double\n"
"#define VEC_TYPE double4\n"
"#define VEC_TYPE_LOC double4\n"
"#define CONVERT_TYPE convert_double4\n"
"#define CONDITION_FUNC(a,b,c) ((a) ? b : c)\n"
"#define MIN_VAL (-DBL_MAX)\n"
"#define MAX_VAL DBL_MAX\n"
"#endif\n"
"#if defined (REPEAT_E0)\n"
"#define repeat_e(a) a=a;\n"
"#endif\n"
"#if defined (REPEAT_E1)\n"
"#define repeat_e(a) a.s3 = a.s2;\n"
"#endif\n"
"#if defined (REPEAT_E2)\n"
"#define repeat_e(a) a.s3 = a.s1;a.s2 = a.s1;\n"
"#endif\n"
"#if defined (REPEAT_E3)\n"
"#define repeat_e(a) a.s3 = a.s0;a.s2 = a.s0;a.s1 = a.s0;\n"
"#endif\n"
"#if defined (REPEAT_E0)\n"
"#define repeat_me(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_E1)\n"
"#define repeat_me(a) a.s3 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E2)\n"
"#define repeat_me(a) a.s3 = 0;a.s2 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E3)\n"
"#define repeat_me(a) a.s3 = 0;a.s2 = 0;a.s1 = 0;\n"
"#endif\n"
"__kernel void arithm_op_minMaxLoc_mask (int cols,int invalid_cols,int offset,int elemnum,int groupnum,__global TYPE *src,\n"
"int minvalid_cols,int moffset,__global uchar *mask,__global RES_TYPE  *dst)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"unsigned int  id = get_global_id(0);\n"
"unsigned int idx = id + (id / cols) * invalid_cols;\n"
"unsigned int midx = id + (id / cols) * minvalid_cols;\n"
"__local VEC_TYPE lm_max[128],lm_min[128];\n"
"VEC_TYPE minval,maxval,temp,m_temp;\n"
"__local VEC_TYPE_LOC lm_maxloc[128],lm_minloc[128];\n"
"VEC_TYPE_LOC minloc,maxloc,temploc,negative = -1,one = 1,zero = 0;\n"
"if(id < elemnum)\n"
"{\n"
"temp = vload4(idx, &src[offset]);\n"
"m_temp = CONVERT_TYPE(vload4(midx,&mask[moffset]));\n"
"int idx_c = (idx << 2) + offset;\n"
"temploc = (VEC_TYPE_LOC)(idx_c,idx_c+1,idx_c+2,idx_c+3);\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_me(m_temp);\n"
"repeat_e(temploc);\n"
"}\n"
"minval = m_temp != (VEC_TYPE)0 ? temp : (VEC_TYPE)MAX_VAL;\n"
"maxval = m_temp != (VEC_TYPE)0 ? temp : (VEC_TYPE)MIN_VAL;\n"
"minloc = CONDITION_FUNC(m_temp != (VEC_TYPE)0, temploc , negative);\n"
"maxloc = minloc;\n"
"}\n"
"else\n"
"{\n"
"minval = MAX_VAL;\n"
"maxval = MIN_VAL;\n"
"minloc = negative;\n"
"maxloc = negative;\n"
"}\n"
"for(id=id + (groupnum << 8); id < elemnum;id = id + (groupnum << 8))\n"
"{\n"
"idx = id + (id / cols) * invalid_cols;\n"
"midx = id + (id / cols) * minvalid_cols;\n"
"temp = vload4(idx, &src[offset]);\n"
"m_temp = CONVERT_TYPE(vload4(midx,&mask[moffset]));\n"
"int idx_c = (idx << 2) + offset;\n"
"temploc = (VEC_TYPE_LOC)(idx_c,idx_c+1,idx_c+2,idx_c+3);\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_me(m_temp);\n"
"repeat_e(temploc);\n"
"}\n"
"minval = min(minval,m_temp != (VEC_TYPE)0 ? temp : minval);\n"
"maxval = max(maxval,m_temp != (VEC_TYPE)0 ? temp : maxval);\n"
"minloc = CONDITION_FUNC((minval == temp) && (m_temp != (VEC_TYPE)0), temploc , minloc);\n"
"maxloc = CONDITION_FUNC((maxval == temp) && (m_temp != (VEC_TYPE)0), temploc , maxloc);\n"
"}\n"
"if(lid > 127)\n"
"{\n"
"lm_min[lid - 128] = minval;\n"
"lm_max[lid - 128] = maxval;\n"
"lm_minloc[lid - 128] = minloc;\n"
"lm_maxloc[lid - 128] = maxloc;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 128)\n"
"{\n"
"lm_min[lid] = min(minval,lm_min[lid]);\n"
"lm_max[lid] = max(maxval,lm_max[lid]);\n"
"VEC_TYPE con_min = CONVERT_TYPE(minloc != negative ? one : zero);\n"
"VEC_TYPE con_max = CONVERT_TYPE(maxloc != negative ? one : zero);\n"
"lm_minloc[lid] = CONDITION_FUNC((lm_min[lid] == minval) && (con_min != (VEC_TYPE)0), minloc , lm_minloc[lid]);\n"
"lm_maxloc[lid] = CONDITION_FUNC((lm_max[lid] == maxval) && (con_max != (VEC_TYPE)0), maxloc , lm_maxloc[lid]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int lsize = 64; lsize > 0; lsize >>= 1)\n"
"{\n"
"if(lid < lsize)\n"
"{\n"
"int lid2 = lsize + lid;\n"
"lm_min[lid] = min(lm_min[lid] , lm_min[lid2]);\n"
"lm_max[lid] = max(lm_max[lid] , lm_max[lid2]);\n"
"VEC_TYPE con_min = CONVERT_TYPE(lm_minloc[lid2] != negative ? one : zero);\n"
"VEC_TYPE con_max = CONVERT_TYPE(lm_maxloc[lid2] != negative ? one : zero);\n"
"lm_minloc[lid] =\n"
"CONDITION_FUNC((lm_min[lid] == lm_min[lid2]) && (con_min != (VEC_TYPE)0), lm_minloc[lid2] , lm_minloc[lid]);\n"
"lm_maxloc[lid] =\n"
"CONDITION_FUNC((lm_max[lid] == lm_max[lid2]) && (con_max != (VEC_TYPE)0), lm_maxloc[lid2] , lm_maxloc[lid]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if( lid == 0)\n"
"{\n"
"dst[gid] = CONVERT_RES_TYPE(lm_min[0]);\n"
"dst[gid + groupnum] = CONVERT_RES_TYPE(lm_max[0]);\n"
"dst[gid + 2 * groupnum] = CONVERT_RES_TYPE(lm_minloc[0]);\n"
"dst[gid + 3 * groupnum] = CONVERT_RES_TYPE(lm_maxloc[0]);\n"
"}\n"
"}\n"
;
const char* arithm_mul="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"int4 round_int4(float4 v)\n"
"{\n"
"v.s0 = v.s0 + (v.s0 > 0 ? 0.5 : -0.5);\n"
"v.s1 = v.s1 + (v.s1 > 0 ? 0.5 : -0.5);\n"
"v.s2 = v.s2 + (v.s2 > 0 ? 0.5 : -0.5);\n"
"v.s3 = v.s3 + (v.s3 > 0 ? 0.5 : -0.5);\n"
"return convert_int4_sat(v);\n"
"}\n"
"uint4 round_uint4(float4 v)\n"
"{\n"
"v.s0 = v.s0 + (v.s0 > 0 ? 0.5 : -0.5);\n"
"v.s1 = v.s1 + (v.s1 > 0 ? 0.5 : -0.5);\n"
"v.s2 = v.s2 + (v.s2 > 0 ? 0.5 : -0.5);\n"
"v.s3 = v.s3 + (v.s3 > 0 ? 0.5 : -0.5);\n"
"return convert_uint4_sat(v);\n"
"}\n"
"long round_int(float v)\n"
"{\n"
"v = v + (v > 0 ? 0.5 : -0.5);\n"
"return convert_int_sat(v);\n"
"}\n"
"__kernel void arithm_mul_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, float scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data ,src2_data;\n"
"src1_data.x= src1_index+0 >= 0 ? src1[src1_index+0] : 0;\n"
"src1_data.y= src1_index+1 >= 0 ? src1[src1_index+1] : 0;\n"
"src1_data.z= src1_index+2 >= 0 ? src1[src1_index+2] : 0;\n"
"src1_data.w= src1_index+3 >= 0 ? src1[src1_index+3] : 0;\n"
"src2_data.x= src2_index+0 >= 0 ? src2[src2_index+0] : 0;\n"
"src2_data.y= src2_index+1 >= 0 ? src2[src2_index+1] : 0;\n"
"src2_data.z= src2_index+2 >= 0 ? src2[src2_index+2] : 0;\n"
"src2_data.w= src2_index+3 >= 0 ? src2[src2_index+3] : 0;\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"int4 tmp      = convert_int4_sat(src1_data) * convert_int4_sat(src2_data);\n"
"tmp = round_int4(convert_float4(tmp) * scalar);\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_mul_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, float scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"uint4    tmp = convert_uint4_sat(src1_data) * convert_uint4_sat(src2_data);\n"
"tmp = round_uint4(convert_float4(tmp) * scalar);\n"
"ushort4 tmp_data = convert_ushort4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_mul_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, float scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#ifdef dst_align\n"
"#undef dst_align\n"
"#endif\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"int4   tmp = convert_int4_sat(src1_data) * convert_int4_sat(src2_data);\n"
"tmp = round_int4(convert_float4(tmp) * scalar);\n"
"short4 tmp_data = convert_short4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_mul_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, float scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"int tmp  = data1 * data2;\n"
"tmp = round_int((float)tmp * scalar);\n"
"*((__global int *)((__global char *)dst + dst_index)) = convert_int_sat(tmp);\n"
"}\n"
"}\n"
"__kernel void arithm_mul_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, float scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"float tmp = data1 * data2;\n"
"tmp = tmp * scalar;\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_mul_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, double scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"double tmp = data1 * data2;\n"
"tmp = tmp * scalar;\n"
"*((__global double *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_muls_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1, float scalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float tmp = data1 * scalar;\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
;
const char* arithm_nonzero="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#if defined (DEPTH_0)\n"
"#define VEC_TYPE uchar8\n"
"#endif\n"
"#if defined (DEPTH_1)\n"
"#define VEC_TYPE char8\n"
"#endif\n"
"#if defined (DEPTH_2)\n"
"#define VEC_TYPE ushort8\n"
"#endif\n"
"#if defined (DEPTH_3)\n"
"#define VEC_TYPE short8\n"
"#endif\n"
"#if defined (DEPTH_4)\n"
"#define VEC_TYPE int8\n"
"#endif\n"
"#if defined (DEPTH_5)\n"
"#define VEC_TYPE float8\n"
"#endif\n"
"#if defined (DEPTH_6)\n"
"#define VEC_TYPE double8\n"
"#endif\n"
"#if defined (REPEAT_S0)\n"
"#define repeat_s(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_S1)\n"
"#define repeat_s(a) a.s0 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S2)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S3)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S4)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;a.s3 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S5)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;a.s3 = 0;a.s4 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S6)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;a.s3 = 0;a.s4 = 0;a.s5 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S7)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;a.s3 = 0;a.s4 = 0;a.s5 = 0;a.s6 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E0)\n"
"#define repeat_e(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_E1)\n"
"#define repeat_e(a) a.s7 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E2)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E3)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E4)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E5)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;a.s3 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E6)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;a.s3 = 0;a.s2 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E7)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;a.s3 = 0;a.s2 = 0;a.s1 = 0;\n"
"#endif\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics:enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics:enable\n"
"__kernel void arithm_op_nonzero (int cols,int invalid_cols,int offset,int elemnum,int groupnum,\n"
"__global VEC_TYPE *src, __global int8 *dst)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"unsigned int  id = get_global_id(0);\n"
"unsigned int idx = offset + id + (id / cols) * invalid_cols;\n"
"__local int8 localmem_nonzero[128];\n"
"int8 nonzero;\n"
"VEC_TYPE zero=0,one=1,temp;\n"
"if(id < elemnum)\n"
"{\n"
"temp = src[idx];\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp);\n"
"}\n"
"nonzero = convert_int8(temp == zero ? zero:one);\n"
"}\n"
"else\n"
"{\n"
"nonzero = 0;\n"
"}\n"
"for(id=id + (groupnum << 8); id < elemnum;id = id + (groupnum << 8))\n"
"{\n"
"idx = offset + id + (id / cols) * invalid_cols;\n"
"temp = src[idx];\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp);\n"
"}\n"
"nonzero = nonzero + convert_int8(temp == zero ? zero:one);\n"
"}\n"
"if(lid > 127)\n"
"{\n"
"localmem_nonzero[lid - 128] = nonzero;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 128)\n"
"{\n"
"localmem_nonzero[lid] = nonzero + localmem_nonzero[lid];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int lsize = 64; lsize > 0; lsize >>= 1)\n"
"{\n"
"if(lid < lsize)\n"
"{\n"
"int lid2 = lsize + lid;\n"
"localmem_nonzero[lid] = localmem_nonzero[lid] + localmem_nonzero[lid2];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if( lid == 0)\n"
"{\n"
"dst[gid] = localmem_nonzero[0];\n"
"}\n"
"}\n"
;
const char* arithm_phase="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define CV_PI 3.1415926535898\n"
"__kernel void arithm_phase_inradians_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"float tmp = atan2(data2,data1);\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_phase_inradians_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"*((__global double *)((__global char *)dst + dst_index)) = atan2(data2,data1);\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_phase_indegrees_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"float tmp = atan2(data2,data1);\n"
"float tmp_data = 180*tmp/CV_PI;\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_phase_indegrees_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"double tmp = atan2(data2,data1);\n"
"double tmp_data = 180*tmp/CV_PI;\n"
"*((__global double *)((__global char *)dst + dst_index)) = tmp_data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_polarToCart="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define CV_PI   3.1415926535897932384626433832795\n"
"__kernel void arithm_polarToCart_mag_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst1, int dst1_step, int dst1_offset,\n"
"__global float *dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int angInDegree)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst1_index = mad24(y, dst1_step, (x << 2) + dst1_offset);\n"
"int dst2_index = mad24(y, dst2_step, (x << 2) + dst2_offset);\n"
"float x = *((__global float *)((__global char *)src1 + src1_index));\n"
"float y = *((__global float *)((__global char *)src2 + src2_index));\n"
"float ascale = CV_PI/180.0;\n"
"float alpha  = angInDegree == 1 ? y * ascale : y;\n"
"float a = cos(alpha) * x;\n"
"float b = sin(alpha) * x;\n"
"*((__global float *)((__global char *)dst1 + dst1_index)) = a;\n"
"*((__global float *)((__global char *)dst2 + dst2_index)) = b;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_polarToCart_mag_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst1, int dst1_step, int dst1_offset,\n"
"__global double *dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int angInDegree)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst1_index = mad24(y, dst1_step, (x << 3) + dst1_offset);\n"
"int dst2_index = mad24(y, dst2_step, (x << 3) + dst2_offset);\n"
"double x = *((__global double *)((__global char *)src1 + src1_index));\n"
"double y = *((__global double *)((__global char *)src2 + src2_index));\n"
"float ascale = CV_PI/180.0;\n"
"double alpha  = angInDegree == 1 ? y * ascale : y;\n"
"double a = cos(alpha) * x;\n"
"double b = sin(alpha) * x;\n"
"*((__global double *)((__global char *)dst1 + dst1_index)) = a;\n"
"*((__global double *)((__global char *)dst2 + dst2_index)) = b;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_polarToCart_D5 (__global float *src,  int src_step,  int src_offset,\n"
"__global float *dst1, int dst1_step, int dst1_offset,\n"
"__global float *dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int angInDegree)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src_index  = mad24(y, src_step,  (x << 2) + src_offset);\n"
"int dst1_index = mad24(y, dst1_step, (x << 2) + dst1_offset);\n"
"int dst2_index = mad24(y, dst2_step, (x << 2) + dst2_offset);\n"
"float y = *((__global float *)((__global char *)src + src_index));\n"
"float ascale = CV_PI/180.0;\n"
"float alpha  = angInDegree == 1 ? y * ascale : y;\n"
"float a = cos(alpha);\n"
"float b = sin(alpha);\n"
"*((__global float *)((__global char *)dst1 + dst1_index)) = a;\n"
"*((__global float *)((__global char *)dst2 + dst2_index)) = b;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_polarToCart_D6 (__global float *src,  int src_step,  int src_offset,\n"
"__global float *dst1, int dst1_step, int dst1_offset,\n"
"__global float *dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int angInDegree)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src_index  = mad24(y, src_step,  (x << 3) + src_offset);\n"
"int dst1_index = mad24(y, dst1_step, (x << 3) + dst1_offset);\n"
"int dst2_index = mad24(y, dst2_step, (x << 3) + dst2_offset);\n"
"double y = *((__global double *)((__global char *)src + src_index));\n"
"float ascale = CV_PI/180.0;\n"
"double alpha  = angInDegree == 1 ? y * ascale : y;\n"
"double a = cos(alpha);\n"
"double b = sin(alpha);\n"
"*((__global double *)((__global char *)dst1 + dst1_index)) = a;\n"
"*((__global double *)((__global char *)dst2 + dst2_index)) = b;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_pow="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"typedef double F;\n"
"typedef double4 F4;\n"
"#define convert_F4 convert_double4;\n"
"#else\n"
"typedef float F;\n"
"typedef float4 F4;\n"
"#define convert_F4 convert_float4;\n"
"#endif\n"
"__kernel void arithm_pow_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1,\n"
"F p)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float src1_data = *((__global float *)((__global char *)src1 + src1_index));\n"
"float tmp = src1_data > 0 ? exp(p * log(src1_data)) : (src1_data == 0 ? 0 : exp(p * log(fabs(src1_data))));\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_pow_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1,\n"
"F p)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double src1_data = *((__global double *)((__global char *)src1 + src1_index));\n"
"double tmp = src1_data > 0 ? exp(p * log(src1_data)) : (src1_data == 0 ? 0 : exp(p * log(fabs(src1_data))));\n"
"*((__global double *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_sub="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void arithm_sub_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_index));\n"
"short4 tmp      = convert_short4_sat(src1_data) - convert_short4_sat(src2_data);\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"ushort4 src1_data = vload4(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort4 src2_data = vload4(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data = *((__global ushort4 *)((__global char *)dst + dst_index));\n"
"int4    tmp = convert_int4_sat(src1_data) - convert_int4_sat(src2_data);\n"
"ushort4 tmp_data = convert_ushort4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align ((dst_offset >> 1) & 3)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffff8);\n"
"short4 src1_data = vload4(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short4 src2_data = vload4(0, (__global short *)((__global char *)src2 + src2_index));\n"
"short4 dst_data = *((__global short4 *)((__global char *)dst + dst_index));\n"
"int4   tmp = convert_int4_sat(src1_data) - convert_int4_sat(src2_data);\n"
"short4 tmp_data = convert_short4_sat(tmp);\n"
"dst_data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : dst_data.x;\n"
"dst_data.y = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.y : dst_data.y;\n"
"dst_data.z = ((dst_index + 4 >= dst_start) && (dst_index + 4 < dst_end)) ? tmp_data.z : dst_data.z;\n"
"dst_data.w = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end)) ? tmp_data.w : dst_data.w;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = dst_data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_D4 (__global int *src1, int src1_step, int src1_offset,\n"
"__global int *src2, int src2_step, int src2_offset,\n"
"__global int *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"long tmp  = (long)(data1) - (long)(data2);\n"
"*((__global int *)((__global char *)dst + dst_index)) = convert_int_sat(tmp);\n"
"}\n"
"}\n"
"__kernel void arithm_sub_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"float tmp = data1 - data2;\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_sub_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"*((__global double *)((__global char *)dst + dst_index)) = data1 - data2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_sub_with_mask_C1_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"short4 tmp = convert_short4_sat(src1_data) - convert_short4_sat(src2_data);\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C1_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"ushort2 src2_data = vload2(0, (__global ushort *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) - convert_int2_sat(src2_data);\n"
"ushort2 tmp_data = convert_ushort2_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C1_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"short2 src2_data = vload2(0, (__global short *)((__global char *)src2 + src2_index));\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) - convert_int2_sat(src2_data);\n"
"short2 tmp_data = convert_short2_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C1_D4 (__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = *((__global int *)((__global char *)src2 + src2_index));\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"int data = convert_int_sat((long)src_data1 - (long)src_data2);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C1_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float src_data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float src_data2 = *((__global float *)((__global char *)src2 + src2_index));\n"
"float dst_data  = *((__global float *)((__global char *)dst  + dst_index));\n"
"float data = src_data1 - src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_sub_with_mask_C1_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double src_data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double src_data2 = *((__global double *)((__global char *)src2 + src2_index));\n"
"double dst_data  = *((__global double *)((__global char *)dst  + dst_index));\n"
"double data = src_data1 - src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_sub_with_mask_C2_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"uchar4 src2_data = vload4(0, src2 + src2_index);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"short4   tmp = convert_short4_sat(src1_data) - convert_short4_sat(src2_data);\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C2_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"ushort2 src_data2 = *((__global ushort2 *)((__global char *)src2 + src2_index));\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) - convert_int2_sat(src_data2);\n"
"ushort2 data = convert_ushort2_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C2_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"short2 src_data2 = *((__global short2 *)((__global char *)src2 + src2_index));\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) - convert_int2_sat(src_data2);\n"
"short2 data = convert_short2_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C2_D4 (__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int    *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = *((__global int2 *)((__global char *)src2 + src2_index));\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"int2 data = convert_int2_sat(convert_long2_sat(src_data1) - convert_long2_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C2_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float2 src_data1 = *((__global float2 *)((__global char *)src1 + src1_index));\n"
"float2 src_data2 = *((__global float2 *)((__global char *)src2 + src2_index));\n"
"float2 dst_data  = *((__global float2 *)((__global char *)dst  + dst_index));\n"
"float2 data = src_data1 - src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_sub_with_mask_C2_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double2 src_data1 = *((__global double2 *)((__global char *)src1 + src1_index));\n"
"double2 src_data2 = *((__global double2 *)((__global char *)src2 + src2_index));\n"
"double2 dst_data  = *((__global double2 *)((__global char *)dst  + dst_index));\n"
"double2 data = src_data1 - src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_sub_with_mask_C3_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int src2_index = mad24(y, src2_step, (x * 3) + src2_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"uchar4 src2_data_0 = vload4(0, src2 + src2_index + 0);\n"
"uchar4 src2_data_1 = vload4(0, src2 + src2_index + 4);\n"
"uchar4 src2_data_2 = vload4(0, src2 + src2_index + 8);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"uchar4 tmp_data_0 = convert_uchar4_sat(convert_short4_sat(src1_data_0) - convert_short4_sat(src2_data_0));\n"
"uchar4 tmp_data_1 = convert_uchar4_sat(convert_short4_sat(src1_data_1) - convert_short4_sat(src2_data_1));\n"
"uchar4 tmp_data_2 = convert_uchar4_sat(convert_short4_sat(src1_data_2) - convert_short4_sat(src2_data_2));\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C3_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"ushort2 src2_data_0 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 0));\n"
"ushort2 src2_data_1 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 4));\n"
"ushort2 src2_data_2 = vload2(0, (__global ushort *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"ushort2 tmp_data_0 = convert_ushort2_sat(convert_int2_sat(src1_data_0) - convert_int2_sat(src2_data_0));\n"
"ushort2 tmp_data_1 = convert_ushort2_sat(convert_int2_sat(src1_data_1) - convert_int2_sat(src2_data_1));\n"
"ushort2 tmp_data_2 = convert_ushort2_sat(convert_int2_sat(src1_data_2) - convert_int2_sat(src2_data_2));\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C3_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int src2_index = mad24(y, src2_step, (x * 6) + src2_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"short2 src2_data_0 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 0));\n"
"short2 src2_data_1 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 4));\n"
"short2 src2_data_2 = vload2(0, (__global short *)((__global char *)src2 + src2_index + 8));\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"short2 tmp_data_0 = convert_short2_sat(convert_int2_sat(src1_data_0) - convert_int2_sat(src2_data_0));\n"
"short2 tmp_data_1 = convert_short2_sat(convert_int2_sat(src1_data_1) - convert_int2_sat(src2_data_1));\n"
"short2 tmp_data_2 = convert_short2_sat(convert_int2_sat(src1_data_2) - convert_int2_sat(src2_data_2));\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C3_D4 (__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = *((__global int *)((__global char *)src2 + src2_index + 0));\n"
"int src2_data_1 = *((__global int *)((__global char *)src2 + src2_index + 4));\n"
"int src2_data_2 = *((__global int *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"int tmp_data_0 = convert_int_sat((long)src1_data_0 - (long)src2_data_0);\n"
"int tmp_data_1 = convert_int_sat((long)src1_data_1 - (long)src2_data_1);\n"
"int tmp_data_2 = convert_int_sat((long)src1_data_2 - (long)src2_data_2);\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C3_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 12) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"float src1_data_0 = *((__global float *)((__global char *)src1 + src1_index + 0));\n"
"float src1_data_1 = *((__global float *)((__global char *)src1 + src1_index + 4));\n"
"float src1_data_2 = *((__global float *)((__global char *)src1 + src1_index + 8));\n"
"float src2_data_0 = *((__global float *)((__global char *)src2 + src2_index + 0));\n"
"float src2_data_1 = *((__global float *)((__global char *)src2 + src2_index + 4));\n"
"float src2_data_2 = *((__global float *)((__global char *)src2 + src2_index + 8));\n"
"uchar mask_data = * (mask + mask_index);\n"
"float data_0 = *((__global float *)((__global char *)dst + dst_index + 0));\n"
"float data_1 = *((__global float *)((__global char *)dst + dst_index + 4));\n"
"float data_2 = *((__global float *)((__global char *)dst + dst_index + 8));\n"
"float tmp_data_0 = src1_data_0 - src2_data_0;\n"
"float tmp_data_1 = src1_data_1 - src2_data_1;\n"
"float tmp_data_2 = src1_data_2 - src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global float *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global float *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global float *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_sub_with_mask_C3_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x * 24) + src2_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"double src1_data_0 = *((__global double *)((__global char *)src1 + src1_index + 0 ));\n"
"double src1_data_1 = *((__global double *)((__global char *)src1 + src1_index + 8 ));\n"
"double src1_data_2 = *((__global double *)((__global char *)src1 + src1_index + 16));\n"
"double src2_data_0 = *((__global double *)((__global char *)src2 + src2_index + 0 ));\n"
"double src2_data_1 = *((__global double *)((__global char *)src2 + src2_index + 8 ));\n"
"double src2_data_2 = *((__global double *)((__global char *)src2 + src2_index + 16));\n"
"uchar mask_data = * (mask + mask_index);\n"
"double data_0 = *((__global double *)((__global char *)dst + dst_index + 0 ));\n"
"double data_1 = *((__global double *)((__global char *)dst + dst_index + 8 ));\n"
"double data_2 = *((__global double *)((__global char *)dst + dst_index + 16));\n"
"double tmp_data_0 = src1_data_0 - src2_data_0;\n"
"double tmp_data_1 = src1_data_1 - src2_data_1;\n"
"double tmp_data_2 = src1_data_2 - src2_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global double *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global double *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global double *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_sub_with_mask_C4_D0 (__global uchar *src1, int src1_step, int src1_offset,\n"
"__global uchar *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global uchar *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 2) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 src_data2 = *((__global uchar4 *)(src2 + src2_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"uchar4 data = convert_uchar4_sat(convert_short4_sat(src_data1) - convert_short4_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C4_D2 (__global ushort *src1, int src1_step, int src1_offset,\n"
"__global ushort *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global ushort *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 src_data2 = *((__global ushort4 *)((__global char *)src2 + src2_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"ushort4 data = convert_ushort4_sat(convert_int4_sat(src_data1) - convert_int4_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C4_D3 (__global short *src1, int src1_step, int src1_offset,\n"
"__global short *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global short *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 3) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 src_data2 = *((__global short4 *)((__global char *)src2 + src2_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"short4 data = convert_short4_sat(convert_int4_sat(src_data1) - convert_int4_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C4_D4 (__global int   *src1, int src1_step, int src1_offset,\n"
"__global int   *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global int   *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 src_data2 = *((__global int4 *)((__global char *)src2 + src2_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"int4 data = convert_int4_sat(convert_long4_sat(src_data1) - convert_long4_sat(src_data2));\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_sub_with_mask_C4_D5 (__global float *src1, int src1_step, int src1_offset,\n"
"__global float *src2, int src2_step, int src2_offset,\n"
"__global uchar *mask, int mask_step, int mask_offset,\n"
"__global float *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 4) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float4 src_data1 = *((__global float4 *)((__global char *)src1 + src1_index));\n"
"float4 src_data2 = *((__global float4 *)((__global char *)src2 + src2_index));\n"
"float4 dst_data  = *((__global float4 *)((__global char *)dst  + dst_index));\n"
"float4 data = src_data1 - src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_sub_with_mask_C4_D6 (__global double *src1, int src1_step, int src1_offset,\n"
"__global double *src2, int src2_step, int src2_offset,\n"
"__global uchar  *mask, int mask_step, int mask_offset,\n"
"__global double *dst,  int dst_step,  int dst_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int src2_index = mad24(y, src2_step, (x << 5) + src2_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double4 src_data1 = *((__global double4 *)((__global char *)src1 + src1_index));\n"
"double4 src_data2 = *((__global double4 *)((__global char *)src2 + src2_index));\n"
"double4 dst_data  = *((__global double4 *)((__global char *)dst  + dst_index));\n"
"double4 data = src_data1 - src_data2;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_sub_scalar="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void arithm_s_sub_C1_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"int4 src2_data = (int4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"int4 tmp = convert_int4_sat(src1_data) - src2_data;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.x = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C1_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) - src2_data;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"ushort2 tmp_data = convert_ushort2_sat(tmp);\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C1_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"int2   tmp = convert_int2_sat(src1_data) - src2_data;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"short2 tmp_data = convert_short2_sat(tmp);\n"
"data.x = (dst_index + 0 >= dst_start) ? tmp_data.x : data.x;\n"
"data.y = (dst_index + 2 <  dst_end  ) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C1_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"long tmp = (long)src_data1 - (long)src_data2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"int data = convert_int_sat(tmp);\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C1_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"float src_data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float src_data2 = src2.x;\n"
"float tmp = src_data1 - src_data2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"*((__global float *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_sub_C1_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"double src_data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double src2_data = src2.x;\n"
"double data = src_data1 - src2_data;\n"
"data = isMatSubScalar ? data : -data;\n"
"*((__global double *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_sub_C2_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"int4 src2_data = (int4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"int4 tmp = convert_int4_sat(src1_data) - src2_data;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.xy = (dst_index + 0 >= dst_start) ? tmp_data.xy : data.xy;\n"
"data.zw = (dst_index + 2 <  dst_end  ) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C2_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2    = (int2)(src2.x, src2.y);\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) - src_data2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"ushort2 data = convert_ushort2_sat(tmp);\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C2_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) - src_data2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"short2 data = convert_short2_sat(tmp);\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C2_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"long2 tmp = convert_long2_sat(src_data1) - convert_long2_sat(src_data2);\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"int2 data = convert_int2_sat(tmp);\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C2_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"float2 src_data1 = *((__global float2 *)((__global char *)src1 + src1_index));\n"
"float2 src_data2 = (float2)(src2.x, src2.y);\n"
"float2 dst_data  = *((__global float2 *)((__global char *)dst  + dst_index));\n"
"float2 tmp = src_data1 - src_data2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"*((__global float2 *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_sub_C2_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"double2 src_data1 = *((__global double2 *)((__global char *)src1 + src1_index));\n"
"double2 src_data2 = (double2)(src2.x, src2.y);\n"
"double2 dst_data  = *((__global double2 *)((__global char *)dst  + dst_index));\n"
"double2 data = src_data1 - src_data2;\n"
"data = isMatSubScalar ? data : -data;\n"
"*((__global double2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_sub_C3_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"int4 src2_data_0 = (int4)(src2.x, src2.y, src2.z, src2.x);\n"
"int4 src2_data_1 = (int4)(src2.y, src2.z, src2.x, src2.y);\n"
"int4 src2_data_2 = (int4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"int4 tmp_0 = convert_int4_sat(src1_data_0) - src2_data_0;\n"
"int4 tmp_1 = convert_int4_sat(src1_data_1) - src2_data_1;\n"
"int4 tmp_2 = convert_int4_sat(src1_data_2) - src2_data_2;\n"
"tmp_0 = isMatSubScalar ? tmp_0 : -tmp_0;\n"
"tmp_1 = isMatSubScalar ? tmp_1 : -tmp_1;\n"
"tmp_2 = isMatSubScalar ? tmp_2 : -tmp_2;\n"
"uchar4 tmp_data_0 = convert_uchar4_sat(tmp_0);\n"
"uchar4 tmp_data_1 = convert_uchar4_sat(tmp_1);\n"
"uchar4 tmp_data_2 = convert_uchar4_sat(tmp_2);\n"
"data_0.xyz = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C3_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"int2 tmp_0 = convert_int2_sat(src1_data_0) - src2_data_0;\n"
"int2 tmp_1 = convert_int2_sat(src1_data_1) - src2_data_1;\n"
"int2 tmp_2 = convert_int2_sat(src1_data_2) - src2_data_2;\n"
"tmp_0 = isMatSubScalar ? tmp_0 : -tmp_0;\n"
"tmp_1 = isMatSubScalar ? tmp_1 : -tmp_1;\n"
"tmp_2 = isMatSubScalar ? tmp_2 : -tmp_2;\n"
"ushort2 tmp_data_0 = convert_ushort2_sat(tmp_0);\n"
"ushort2 tmp_data_1 = convert_ushort2_sat(tmp_1);\n"
"ushort2 tmp_data_2 = convert_ushort2_sat(tmp_2);\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C3_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"int2 tmp_0 = convert_int2_sat(src1_data_0) - src2_data_0;\n"
"int2 tmp_1 = convert_int2_sat(src1_data_1) - src2_data_1;\n"
"int2 tmp_2 = convert_int2_sat(src1_data_2) - src2_data_2;\n"
"tmp_0 = isMatSubScalar ? tmp_0 : -tmp_0;\n"
"tmp_1 = isMatSubScalar ? tmp_1 : -tmp_1;\n"
"tmp_2 = isMatSubScalar ? tmp_2 : -tmp_2;\n"
"short2 tmp_data_0 = convert_short2_sat(tmp_0);\n"
"short2 tmp_data_1 = convert_short2_sat(tmp_1);\n"
"short2 tmp_data_2 = convert_short2_sat(tmp_2);\n"
"data_0.xy = ((dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C3_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"long tmp_0 = (long)src1_data_0 - (long)src2_data_0;\n"
"long tmp_1 = (long)src1_data_1 - (long)src2_data_1;\n"
"long tmp_2 = (long)src1_data_2 - (long)src2_data_2;\n"
"tmp_0 = isMatSubScalar ? tmp_0 : -tmp_0;\n"
"tmp_1 = isMatSubScalar ? tmp_1 : -tmp_1;\n"
"tmp_2 = isMatSubScalar ? tmp_2 : -tmp_2;\n"
"int tmp_data_0 = convert_int_sat(tmp_0);\n"
"int tmp_data_1 = convert_int_sat(tmp_1);\n"
"int tmp_data_2 = convert_int_sat(tmp_2);\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= tmp_data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= tmp_data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= tmp_data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C3_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"float src1_data_0 = *((__global float *)((__global char *)src1 + src1_index + 0));\n"
"float src1_data_1 = *((__global float *)((__global char *)src1 + src1_index + 4));\n"
"float src1_data_2 = *((__global float *)((__global char *)src1 + src1_index + 8));\n"
"float src2_data_0 = src2.x;\n"
"float src2_data_1 = src2.y;\n"
"float src2_data_2 = src2.z;\n"
"float data_0 = *((__global float *)((__global char *)dst + dst_index + 0));\n"
"float data_1 = *((__global float *)((__global char *)dst + dst_index + 4));\n"
"float data_2 = *((__global float *)((__global char *)dst + dst_index + 8));\n"
"float tmp_0 = src1_data_0 - src2_data_0;\n"
"float tmp_1 = src1_data_1 - src2_data_1;\n"
"float tmp_2 = src1_data_2 - src2_data_2;\n"
"tmp_0 = isMatSubScalar ? tmp_0 : -tmp_0;\n"
"tmp_1 = isMatSubScalar ? tmp_1 : -tmp_1;\n"
"tmp_2 = isMatSubScalar ? tmp_2 : -tmp_2;\n"
"*((__global float *)((__global char *)dst + dst_index + 0))= tmp_0;\n"
"*((__global float *)((__global char *)dst + dst_index + 4))= tmp_1;\n"
"*((__global float *)((__global char *)dst + dst_index + 8))= tmp_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_sub_C3_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"double src1_data_0 = *((__global double *)((__global char *)src1 + src1_index + 0 ));\n"
"double src1_data_1 = *((__global double *)((__global char *)src1 + src1_index + 8 ));\n"
"double src1_data_2 = *((__global double *)((__global char *)src1 + src1_index + 16));\n"
"double src2_data_0 = src2.x;\n"
"double src2_data_1 = src2.y;\n"
"double src2_data_2 = src2.z;\n"
"double data_0 = *((__global double *)((__global char *)dst + dst_index + 0 ));\n"
"double data_1 = *((__global double *)((__global char *)dst + dst_index + 8 ));\n"
"double data_2 = *((__global double *)((__global char *)dst + dst_index + 16));\n"
"double tmp_data_0 = src1_data_0 - src2_data_0;\n"
"double tmp_data_1 = src1_data_1 - src2_data_1;\n"
"double tmp_data_2 = src1_data_2 - src2_data_2;\n"
"tmp_data_0 = isMatSubScalar ? tmp_data_0 : -tmp_data_0;\n"
"tmp_data_1 = isMatSubScalar ? tmp_data_1 : -tmp_data_1;\n"
"tmp_data_2 = isMatSubScalar ? tmp_data_2 : -tmp_data_2;\n"
"*((__global double *)((__global char *)dst + dst_index + 0 ))= tmp_data_0;\n"
"*((__global double *)((__global char *)dst + dst_index + 8 ))= tmp_data_1;\n"
"*((__global double *)((__global char *)dst + dst_index + 16))= tmp_data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_sub_C4_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"int4 tmp = convert_int4_sat(src_data1) - src2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"uchar4 data = convert_uchar4_sat(tmp);\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C4_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"int4 tmp = convert_int4_sat(src_data1) - src2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"ushort4 data = convert_ushort4_sat(tmp);\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C4_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"int4 tmp = convert_int4_sat(src_data1) - src2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"short4 data = convert_short4_sat(tmp);\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C4_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"long4 tmp = convert_long4_sat(src_data1) - convert_long4_sat(src2);\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"int4 data = convert_int4_sat(tmp);\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_C4_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"float4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"float4 src_data1 = *((__global float4 *)((__global char *)src1 + src1_index));\n"
"float4 tmp = src_data1 - src2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = tmp;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_sub_C4_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"double4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"double4 src_data1 = *((__global double4 *)((__global char *)src1 + src1_index));\n"
"double4 data = src_data1 - src2;\n"
"data = isMatSubScalar ? data : -data;\n"
"*((__global double4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_sub_scalar_mask="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void arithm_s_sub_with_mask_C1_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align (dst_offset & 3)\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - dst_align);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + x & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"int4 src2_data = (int4)(src2.x, src2.x, src2.x, src2.x);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"int4 tmp = convert_int4_sat(src1_data) - src2_data;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 1 >= dst_start) && (dst_index + 1 < dst_end)) ? tmp_data.y : data.y;\n"
"data.z = ((mask_data.z) && (dst_index + 2 >= dst_start) && (dst_index + 2 < dst_end)) ? tmp_data.z : data.z;\n"
"data.w = ((mask_data.w) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end)) ? tmp_data.w : data.w;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C1_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar  *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 src1_data = vload2(0, (__global ushort *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data = *((__global ushort2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) - src2_data;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"ushort2 tmp_data = convert_ushort2_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global ushort2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C1_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 src1_data = vload2(0, (__global short *)((__global char *)src1 + src1_index));\n"
"int2 src2_data = (int2)(src2.x, src2.x);\n"
"uchar2  mask_data = vload2(0, mask + mask_index);\n"
"short2 data = *((__global short2 *)((__global uchar *)dst + dst_index));\n"
"int2    tmp = convert_int2_sat(src1_data) - src2_data;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"short2 tmp_data = convert_short2_sat(tmp);\n"
"data.x = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.x : data.x;\n"
"data.y = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.y : data.y;\n"
"*((__global short2 *)((__global uchar *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C1_D4 (__global   int   *src1, int src1_step, int src1_offset,\n"
"__global   int   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int src_data1 = *((__global int *)((__global char *)src1 + src1_index));\n"
"int src_data2 = src2.x;\n"
"int dst_data  = *((__global int *)((__global char *)dst  + dst_index));\n"
"long tmp = (long)src_data1 - (long)src_data2;\n"
"tmp = isMatSubScalar ? tmp : - tmp;\n"
"int data = convert_int_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C1_D5 (__global   float   *src1, int src1_step, int src1_offset,\n"
"__global   float   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"float4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float src_data1 = *((__global float *)((__global char *)src1 + src1_index));\n"
"float src_data2 = src2.x;\n"
"float dst_data  = *((__global float *)((__global char *)dst  + dst_index));\n"
"float data = src_data1 - src_data2;\n"
"data = isMatSubScalar ? data : -data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_sub_with_mask_C1_D6 (__global   double   *src1, int src1_step, int src1_offset,\n"
"__global   double   *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"double4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double src_data1 = *((__global double *)((__global char *)src1 + src1_index));\n"
"double src_data2 = src2.x;\n"
"double dst_data  = *((__global double *)((__global char *)dst  + dst_index));\n"
"double data = src_data1 - src_data2;\n"
"data = isMatSubScalar ? data : -data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_sub_with_mask_C2_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align ((dst_offset >> 1) & 1)\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - (dst_align << 1));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"uchar4 src1_data = vload4(0, src1 + src1_index);\n"
"int4 src2_data = (int4)(src2.x, src2.y, src2.x, src2.y);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"uchar4 data = *((__global uchar4 *)(dst + dst_index));\n"
"int4   tmp = convert_int4_sat(src1_data) - src2_data;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"uchar4 tmp_data = convert_uchar4_sat(tmp);\n"
"data.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data.xy : data.xy;\n"
"data.zw = ((mask_data.y) && (dst_index + 2 <  dst_end  )) ? tmp_data.zw : data.zw;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C2_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort2 src_data1 = *((__global ushort2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"ushort2 dst_data  = *((__global ushort2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) - src_data2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"ushort2 data = convert_ushort2_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C2_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short2 src_data1 = *((__global short2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"short2 dst_data  = *((__global short2 *)((__global char *)dst  + dst_index));\n"
"int2    tmp = convert_int2_sat(src_data1) - src_data2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"short2 data = convert_short2_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C2_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int2 src_data1 = *((__global int2 *)((__global char *)src1 + src1_index));\n"
"int2 src_data2 = (int2)(src2.x, src2.y);\n"
"int2 dst_data  = *((__global int2 *)((__global char *)dst  + dst_index));\n"
"long2 tmp = convert_long2_sat(src_data1) - convert_long2_sat(src_data2);\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"int2 data = convert_int2_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C2_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"float4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float2 src_data1 = *((__global float2 *)((__global char *)src1 + src1_index));\n"
"float2 src_data2 = (float2)(src2.x, src2.y);\n"
"float2 dst_data  = *((__global float2 *)((__global char *)dst  + dst_index));\n"
"float2 data = src_data1 - src_data2;\n"
"data = isMatSubScalar ? data : -data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_sub_with_mask_C2_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"double4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double2 src_data1 = *((__global double2 *)((__global char *)src1 + src1_index));\n"
"double2 src_data2 = (double2)(src2.x, src2.y);\n"
"double2 dst_data  = *((__global double2 *)((__global char *)dst  + dst_index));\n"
"double2 data = src_data1 - src_data2;\n"
"data = isMatSubScalar ? data : -data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double2 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_sub_with_mask_C3_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 2;\n"
"#define dst_align (((dst_offset % dst_step) / 3 ) & 3)\n"
"int src1_index = mad24(y, src1_step, (x * 3) + src1_offset - (dst_align * 3));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 3) - (dst_align * 3));\n"
"uchar4 src1_data_0 = vload4(0, src1 + src1_index + 0);\n"
"uchar4 src1_data_1 = vload4(0, src1 + src1_index + 4);\n"
"uchar4 src1_data_2 = vload4(0, src1 + src1_index + 8);\n"
"int4 src2_data_0 = (int4)(src2.x, src2.y, src2.z, src2.x);\n"
"int4 src2_data_1 = (int4)(src2.y, src2.z, src2.x, src2.y);\n"
"int4 src2_data_2 = (int4)(src2.z, src2.x, src2.y, src2.z);\n"
"uchar4 mask_data = vload4(0, mask + mask_index);\n"
"uchar4 data_0 = *((__global uchar4 *)(dst + dst_index + 0));\n"
"uchar4 data_1 = *((__global uchar4 *)(dst + dst_index + 4));\n"
"uchar4 data_2 = *((__global uchar4 *)(dst + dst_index + 8));\n"
"int4 tmp_0 = convert_int4_sat(src1_data_0) - src2_data_0;\n"
"int4 tmp_1 = convert_int4_sat(src1_data_1) - src2_data_1;\n"
"int4 tmp_2 = convert_int4_sat(src1_data_2) - src2_data_2;\n"
"tmp_0 = isMatSubScalar ? tmp_0 : -tmp_0;\n"
"tmp_1 = isMatSubScalar ? tmp_1 : -tmp_1;\n"
"tmp_2 = isMatSubScalar ? tmp_2 : -tmp_2;\n"
"uchar4 tmp_data_0 = convert_uchar4_sat(tmp_0);\n"
"uchar4 tmp_data_1 = convert_uchar4_sat(tmp_1);\n"
"uchar4 tmp_data_2 = convert_uchar4_sat(tmp_2);\n"
"data_0.xyz = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xyz : data_0.xyz;\n"
"data_0.w   = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_0.w : data_0.w;\n"
"data_1.xy  = ((mask_data.y) && (dst_index + 3 >= dst_start) && (dst_index + 3 < dst_end))\n"
"? tmp_data_1.xy : data_1.xy;\n"
"data_1.zw  = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.zw : data_1.zw;\n"
"data_2.x   = ((mask_data.z) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.x : data_2.x;\n"
"data_2.yzw = ((mask_data.w) && (dst_index + 9 >= dst_start) && (dst_index + 9 < dst_end))\n"
"? tmp_data_2.yzw : data_2.yzw;\n"
"*((__global uchar4 *)(dst + dst_index + 0)) = data_0;\n"
"*((__global uchar4 *)(dst + dst_index + 4)) = data_1;\n"
"*((__global uchar4 *)(dst + dst_index + 8)) = data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C3_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"ushort2 src1_data_0 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 0));\n"
"ushort2 src1_data_1 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 4));\n"
"ushort2 src1_data_2 = vload2(0, (__global ushort *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"ushort2 data_0 = *((__global ushort2 *)((__global char *)dst + dst_index + 0));\n"
"ushort2 data_1 = *((__global ushort2 *)((__global char *)dst + dst_index + 4));\n"
"ushort2 data_2 = *((__global ushort2 *)((__global char *)dst + dst_index + 8));\n"
"int2 tmp_0 = convert_int2_sat(src1_data_0) - src2_data_0;\n"
"int2 tmp_1 = convert_int2_sat(src1_data_1) - src2_data_1;\n"
"int2 tmp_2 = convert_int2_sat(src1_data_2) - src2_data_2;\n"
"tmp_0 = isMatSubScalar ? tmp_0 : -tmp_0;\n"
"tmp_1 = isMatSubScalar ? tmp_1 : -tmp_1;\n"
"tmp_2 = isMatSubScalar ? tmp_2 : -tmp_2;\n"
"ushort2 tmp_data_0 = convert_ushort2_sat(tmp_0);\n"
"ushort2 tmp_data_1 = convert_ushort2_sat(tmp_1);\n"
"ushort2 tmp_data_2 = convert_ushort2_sat(tmp_2);\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global ushort2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C3_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"x = x << 1;\n"
"#define dst_align (((dst_offset % dst_step) / 6 ) & 1)\n"
"int src1_index = mad24(y, src1_step, (x * 6) + src1_offset - (dst_align * 6));\n"
"int mask_index = mad24(y, mask_step, x + mask_offset - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 6) - (dst_align * 6));\n"
"short2 src1_data_0 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 0));\n"
"short2 src1_data_1 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 4));\n"
"short2 src1_data_2 = vload2(0, (__global short *)((__global char *)src1 + src1_index + 8));\n"
"int2 src2_data_0 = (int2)(src2.x, src2.y);\n"
"int2 src2_data_1 = (int2)(src2.z, src2.x);\n"
"int2 src2_data_2 = (int2)(src2.y, src2.z);\n"
"uchar2 mask_data = vload2(0, mask + mask_index);\n"
"short2 data_0 = *((__global short2 *)((__global char *)dst + dst_index + 0));\n"
"short2 data_1 = *((__global short2 *)((__global char *)dst + dst_index + 4));\n"
"short2 data_2 = *((__global short2 *)((__global char *)dst + dst_index + 8));\n"
"int2 tmp_0 = convert_int2_sat(src1_data_0) - src2_data_0;\n"
"int2 tmp_1 = convert_int2_sat(src1_data_1) - src2_data_1;\n"
"int2 tmp_2 = convert_int2_sat(src1_data_2) - src2_data_2;\n"
"tmp_0 = isMatSubScalar ? tmp_0 : -tmp_0;\n"
"tmp_1 = isMatSubScalar ? tmp_1 : -tmp_1;\n"
"tmp_2 = isMatSubScalar ? tmp_2 : -tmp_2;\n"
"short2 tmp_data_0 = convert_short2_sat(tmp_0);\n"
"short2 tmp_data_1 = convert_short2_sat(tmp_1);\n"
"short2 tmp_data_2 = convert_short2_sat(tmp_2);\n"
"data_0.xy = ((mask_data.x) && (dst_index + 0 >= dst_start)) ? tmp_data_0.xy : data_0.xy;\n"
"data_1.x  = ((mask_data.x) && (dst_index + 0 >= dst_start) && (dst_index + 0 < dst_end))\n"
"? tmp_data_1.x : data_1.x;\n"
"data_1.y  = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_1.y : data_1.y;\n"
"data_2.xy = ((mask_data.y) && (dst_index + 6 >= dst_start) && (dst_index + 6 < dst_end))\n"
"? tmp_data_2.xy : data_2.xy;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global short2 *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C3_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"int src1_data_0 = *((__global int *)((__global char *)src1 + src1_index + 0));\n"
"int src1_data_1 = *((__global int *)((__global char *)src1 + src1_index + 4));\n"
"int src1_data_2 = *((__global int *)((__global char *)src1 + src1_index + 8));\n"
"int src2_data_0 = src2.x;\n"
"int src2_data_1 = src2.y;\n"
"int src2_data_2 = src2.z;\n"
"uchar mask_data = * (mask + mask_index);\n"
"int data_0 = *((__global int *)((__global char *)dst + dst_index + 0));\n"
"int data_1 = *((__global int *)((__global char *)dst + dst_index + 4));\n"
"int data_2 = *((__global int *)((__global char *)dst + dst_index + 8));\n"
"long tmp_0 = (long)src1_data_0 - (long)src2_data_0;\n"
"long tmp_1 = (long)src1_data_1 - (long)src2_data_1;\n"
"long tmp_2 = (long)src1_data_2 - (long)src2_data_2;\n"
"tmp_0 = isMatSubScalar ? tmp_0 : -tmp_0;\n"
"tmp_1 = isMatSubScalar ? tmp_1 : -tmp_1;\n"
"tmp_2 = isMatSubScalar ? tmp_2 : -tmp_2;\n"
"int tmp_data_0 = convert_int_sat(tmp_0);\n"
"int tmp_data_1 = convert_int_sat(tmp_1);\n"
"int tmp_data_2 = convert_int_sat(tmp_2);\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global int *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global int *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global int *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C3_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"float4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 12) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 12));\n"
"float src1_data_0 = *((__global float *)((__global char *)src1 + src1_index + 0));\n"
"float src1_data_1 = *((__global float *)((__global char *)src1 + src1_index + 4));\n"
"float src1_data_2 = *((__global float *)((__global char *)src1 + src1_index + 8));\n"
"float src2_data_0 = src2.x;\n"
"float src2_data_1 = src2.y;\n"
"float src2_data_2 = src2.z;\n"
"uchar mask_data = * (mask + mask_index);\n"
"float data_0 = *((__global float *)((__global char *)dst + dst_index + 0));\n"
"float data_1 = *((__global float *)((__global char *)dst + dst_index + 4));\n"
"float data_2 = *((__global float *)((__global char *)dst + dst_index + 8));\n"
"float tmp_data_0 = src1_data_0 - src2_data_0;\n"
"float tmp_data_1 = src1_data_1 - src2_data_1;\n"
"float tmp_data_2 = src1_data_2 - src2_data_2;\n"
"tmp_data_0 = isMatSubScalar ? tmp_data_0 : -tmp_data_0;\n"
"tmp_data_1 = isMatSubScalar ? tmp_data_1 : -tmp_data_1;\n"
"tmp_data_2 = isMatSubScalar ? tmp_data_2 : -tmp_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global float *)((__global char *)dst + dst_index + 0))= data_0;\n"
"*((__global float *)((__global char *)dst + dst_index + 4))= data_1;\n"
"*((__global float *)((__global char *)dst + dst_index + 8))= data_2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_sub_with_mask_C3_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar  *mask, int mask_step, int mask_offset,\n"
"double4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x * 24) + src1_offset);\n"
"int mask_index = mad24(y, mask_step, x + mask_offset);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x * 24));\n"
"double src1_data_0 = *((__global double *)((__global char *)src1 + src1_index + 0 ));\n"
"double src1_data_1 = *((__global double *)((__global char *)src1 + src1_index + 8 ));\n"
"double src1_data_2 = *((__global double *)((__global char *)src1 + src1_index + 16));\n"
"double src2_data_0 = src2.x;\n"
"double src2_data_1 = src2.y;\n"
"double src2_data_2 = src2.z;\n"
"uchar mask_data = * (mask + mask_index);\n"
"double data_0 = *((__global double *)((__global char *)dst + dst_index + 0 ));\n"
"double data_1 = *((__global double *)((__global char *)dst + dst_index + 8 ));\n"
"double data_2 = *((__global double *)((__global char *)dst + dst_index + 16));\n"
"double tmp_data_0 = src1_data_0 - src2_data_0;\n"
"double tmp_data_1 = src1_data_1 - src2_data_1;\n"
"double tmp_data_2 = src1_data_2 - src2_data_2;\n"
"tmp_data_0 = isMatSubScalar ? tmp_data_0 : -tmp_data_0;\n"
"tmp_data_1 = isMatSubScalar ? tmp_data_1 : -tmp_data_1;\n"
"tmp_data_2 = isMatSubScalar ? tmp_data_2 : -tmp_data_2;\n"
"data_0 = mask_data ? tmp_data_0 : data_0;\n"
"data_1 = mask_data ? tmp_data_1 : data_1;\n"
"data_2 = mask_data ? tmp_data_2 : data_2;\n"
"*((__global double *)((__global char *)dst + dst_index + 0 ))= data_0;\n"
"*((__global double *)((__global char *)dst + dst_index + 8 ))= data_1;\n"
"*((__global double *)((__global char *)dst + dst_index + 16))= data_2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void arithm_s_sub_with_mask_C4_D0 (__global   uchar *src1, int src1_step, int src1_offset,\n"
"__global   uchar *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 2) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 2) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"uchar4 src_data1 = *((__global uchar4 *)(src1 + src1_index));\n"
"uchar4 dst_data  = *((__global uchar4 *)(dst  + dst_index));\n"
"int4 tmp = convert_int4_sat(src_data1) - src2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"uchar4 data = convert_uchar4_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global uchar4 *)(dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C4_D2 (__global   ushort *src1, int src1_step, int src1_offset,\n"
"__global   ushort *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)src1 + src1_index));\n"
"ushort4 dst_data  = *((__global ushort4 *)((__global char *)dst  + dst_index));\n"
"int4    tmp = convert_int4_sat(src_data1) - src2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"ushort4 data = convert_ushort4_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global ushort4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C4_D3 (__global   short *src1, int src1_step, int src1_offset,\n"
"__global   short *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 3) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 3) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"short4 src_data1 = *((__global short4 *)((__global char *)src1 + src1_index));\n"
"short4 dst_data  = *((__global short4 *)((__global char *)dst  + dst_index));\n"
"int4    tmp = convert_int4_sat(src_data1) - src2;\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"short4 data = convert_short4_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global short4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C4_D4 (__global   int *src1, int src1_step, int src1_offset,\n"
"__global   int *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"int4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"int4 src_data1 = *((__global int4 *)((__global char *)src1 + src1_index));\n"
"int4 dst_data  = *((__global int4 *)((__global char *)dst  + dst_index));\n"
"long4 tmp = convert_long4_sat(src_data1) - convert_long4_sat(src2);\n"
"tmp = isMatSubScalar ? tmp : -tmp;\n"
"int4 data = convert_int4_sat(tmp);\n"
"data = mask_data ? data : dst_data;\n"
"*((__global int4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"__kernel void arithm_s_sub_with_mask_C4_D5 (__global   float *src1, int src1_step, int src1_offset,\n"
"__global   float *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"float4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 4) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 4) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"float4 src_data1 = *((__global float4 *)((__global char *)src1 + src1_index));\n"
"float4 dst_data  = *((__global float4 *)((__global char *)dst  + dst_index));\n"
"float4 data = src_data1 - src2;\n"
"data = isMatSubScalar ? data : -data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global float4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void arithm_s_sub_with_mask_C4_D6 (__global   double *src1, int src1_step, int src1_offset,\n"
"__global   double *dst,  int dst_step,  int dst_offset,\n"
"__global   uchar *mask, int mask_step, int mask_offset,\n"
"double4 src2, int rows, int cols, int dst_step1, int isMatSubScalar)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < cols && y < rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, (x << 5) + src1_offset);\n"
"int mask_index = mad24(y, mask_step,  x       + mask_offset);\n"
"int dst_index  = mad24(y, dst_step,  (x << 5) + dst_offset);\n"
"uchar mask_data = *(mask + mask_index);\n"
"double4 src_data1 = *((__global double4 *)((__global char *)src1 + src1_index));\n"
"double4 dst_data  = *((__global double4 *)((__global char *)dst  + dst_index));\n"
"double4 data = src_data1 - src2;\n"
"data = isMatSubScalar ? data : -data;\n"
"data = mask_data ? data : dst_data;\n"
"*((__global double4 *)((__global char *)dst + dst_index)) = data;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* arithm_sum="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#define RES_TYPE double8\n"
"#define CONVERT_RES_TYPE convert_double8\n"
"#else\n"
"#define RES_TYPE float8\n"
"#define CONVERT_RES_TYPE convert_float8\n"
"#endif\n"
"#if defined (DEPTH_0)\n"
"#define VEC_TYPE uchar8\n"
"#endif\n"
"#if defined (DEPTH_1)\n"
"#define VEC_TYPE char8\n"
"#endif\n"
"#if defined (DEPTH_2)\n"
"#define VEC_TYPE ushort8\n"
"#endif\n"
"#if defined (DEPTH_3)\n"
"#define VEC_TYPE short8\n"
"#endif\n"
"#if defined (DEPTH_4)\n"
"#define VEC_TYPE int8\n"
"#endif\n"
"#if defined (DEPTH_5)\n"
"#define VEC_TYPE float8\n"
"#endif\n"
"#if defined (DEPTH_6)\n"
"#define VEC_TYPE double8\n"
"#endif\n"
"#if defined (FUNC_TYPE_0)\n"
"#define FUNC(a,b) b += a;\n"
"#endif\n"
"#if defined (FUNC_TYPE_1)\n"
"#define FUNC(a,b) b = b + (a >= 0 ? a : -a);\n"
"#endif\n"
"#if defined (FUNC_TYPE_2)\n"
"#define FUNC(a,b) b = b + a * a;\n"
"#endif\n"
"#if defined (REPEAT_S0)\n"
"#define repeat_s(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_S1)\n"
"#define repeat_s(a) a.s0 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S2)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S3)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S4)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;a.s3 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S5)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;a.s3 = 0;a.s4 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S6)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;a.s3 = 0;a.s4 = 0;a.s5 = 0;\n"
"#endif\n"
"#if defined (REPEAT_S7)\n"
"#define repeat_s(a) a.s0 = 0;a.s1 = 0;a.s2 = 0;a.s3 = 0;a.s4 = 0;a.s5 = 0;a.s6 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E0)\n"
"#define repeat_e(a) a = a;\n"
"#endif\n"
"#if defined (REPEAT_E1)\n"
"#define repeat_e(a) a.s7 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E2)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E3)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E4)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E5)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;a.s3 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E6)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;a.s3 = 0;a.s2 = 0;\n"
"#endif\n"
"#if defined (REPEAT_E7)\n"
"#define repeat_e(a) a.s7 = 0;a.s6 = 0;a.s5 = 0;a.s4 = 0;a.s3 = 0;a.s2 = 0;a.s1 = 0;\n"
"#endif\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics:enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics:enable\n"
"__kernel void arithm_op_sum (int cols,int invalid_cols,int offset,int elemnum,int groupnum,\n"
"__global VEC_TYPE *src, __global RES_TYPE *dst)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"unsigned int  id = get_global_id(0);\n"
"unsigned int idx = offset + id + (id / cols) * invalid_cols;\n"
"__local RES_TYPE localmem_sum[128];\n"
"RES_TYPE sum = 0,temp;\n"
"if(id < elemnum)\n"
"{\n"
"temp = CONVERT_RES_TYPE(src[idx]);\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp);\n"
"}\n"
"FUNC(temp,sum);\n"
"}\n"
"else\n"
"{\n"
"sum = 0;\n"
"}\n"
"for(id=id + (groupnum << 8); id < elemnum;id = id + (groupnum << 8))\n"
"{\n"
"idx = offset + id + (id / cols) * invalid_cols;\n"
"temp = CONVERT_RES_TYPE(src[idx]);\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp);\n"
"}\n"
"FUNC(temp,sum);\n"
"}\n"
"if(lid > 127)\n"
"{\n"
"localmem_sum[lid - 128] = sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 128)\n"
"{\n"
"localmem_sum[lid] = sum + localmem_sum[lid];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int lsize = 64; lsize > 0; lsize >>= 1)\n"
"{\n"
"if(lid < lsize)\n"
"{\n"
"int lid2 = lsize + lid;\n"
"localmem_sum[lid] = localmem_sum[lid] + localmem_sum[lid2];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if( lid == 0)\n"
"{\n"
"dst[gid] = localmem_sum[0];\n"
"}\n"
"}\n"
;
const char* arithm_sum_3="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#define RES_TYPE double4\n"
"#define CONVERT_RES_TYPE convert_double4\n"
"#else\n"
"#define RES_TYPE float4\n"
"#define CONVERT_RES_TYPE convert_float4\n"
"#endif\n"
"#if defined (DEPTH_0)\n"
"#define VEC_TYPE uchar4\n"
"#endif\n"
"#if defined (DEPTH_1)\n"
"#define VEC_TYPE char4\n"
"#endif\n"
"#if defined (DEPTH_2)\n"
"#define VEC_TYPE ushort4\n"
"#endif\n"
"#if defined (DEPTH_3)\n"
"#define VEC_TYPE short4\n"
"#endif\n"
"#if defined (DEPTH_4)\n"
"#define VEC_TYPE int4\n"
"#endif\n"
"#if defined (DEPTH_5)\n"
"#define VEC_TYPE float4\n"
"#endif\n"
"#if defined (DEPTH_6)\n"
"#define VEC_TYPE double4\n"
"#endif\n"
"#if defined (FUNC_TYPE_0)\n"
"#define FUNC(a,b) b += a;\n"
"#endif\n"
"#if defined (FUNC_TYPE_1)\n"
"#define FUNC(a,b) b = b + (a >= 0 ? a : -a);\n"
"#endif\n"
"#if defined (FUNC_TYPE_2)\n"
"#define FUNC(a,b) b = b + a * a;\n"
"#endif\n"
"#if defined (REPEAT_S0)\n"
"#define repeat_s(a,b,c) a=a; b =b; c=c;\n"
"#endif\n"
"#if defined (REPEAT_S1)\n"
"#define repeat_s(a,b,c) a.s0=0; b=b; c=c;\n"
"#endif\n"
"#if defined (REPEAT_S2)\n"
"#define repeat_s(a,b,c) a.s0=0; a.s1=0; b=b; c=c;\n"
"#endif\n"
"#if defined (REPEAT_S3)\n"
"#define repeat_s(a,b,c) a.s0=0; a.s1=0; a.s2=0; b=b; c=c;\n"
"#endif\n"
"#if defined (REPEAT_S4)\n"
"#define repeat_s(a,b,c) a=0;b=b; c=c;\n"
"#endif\n"
"#if defined (REPEAT_S5)\n"
"#define repeat_s(a,b,c) a=0; b.s0=0;c=c;\n"
"#endif\n"
"#if defined (REPEAT_S6)\n"
"#define repeat_s(a,b,c) a=0; b.s0=0; b.s1=0; c=c;\n"
"#endif\n"
"#if defined (REPEAT_S7)\n"
"#define repeat_s(a,b,c) a=0; b.s0=0; b.s1=0; b.s2=0; c=c;\n"
"#endif\n"
"#if defined (REPEAT_S8)\n"
"#define repeat_s(a,b,c) a=0; b=0; c=c;\n"
"#endif\n"
"#if defined (REPEAT_S9)\n"
"#define repeat_s(a,b,c) a=0; b=0; c.s0=0;\n"
"#endif\n"
"#if defined (REPEAT_S10)\n"
"#define repeat_s(a,b,c) a=0; b=0; c.s0=0; c.s1=0;\n"
"#endif\n"
"#if defined (REPEAT_S11)\n"
"#define repeat_s(a,b,c) a=0; b=0; c.s0=0; c.s1=0; c.s2=0;\n"
"#endif\n"
"#if defined (REPEAT_E0)\n"
"#define repeat_e(a,b,c) a=a; b =b; c=c;\n"
"#endif\n"
"#if defined (REPEAT_E1)\n"
"#define repeat_e(a,b,c) a=a; b=b; c.s3=0;\n"
"#endif\n"
"#if defined (REPEAT_E2)\n"
"#define repeat_e(a,b,c) a=a; b=b; c.s3=0; c.s2=0;\n"
"#endif\n"
"#if defined (REPEAT_E3)\n"
"#define repeat_e(a,b,c) a=a; b=b; c.s3=0; c.s2=0; c.s1=0;\n"
"#endif\n"
"#if defined (REPEAT_E4)\n"
"#define repeat_e(a,b,c) a=a; b=b; c=0;\n"
"#endif\n"
"#if defined (REPEAT_E5)\n"
"#define repeat_e(a,b,c) a=a; b.s3=0; c=0;\n"
"#endif\n"
"#if defined (REPEAT_E6)\n"
"#define repeat_e(a,b,c) a=a; b.s3=0; b.s2=0; c=0;\n"
"#endif\n"
"#if defined (REPEAT_E7)\n"
"#define repeat_e(a,b,c) a=a; b.s3=0; b.s2=0; b.s1=0; c=0;\n"
"#endif\n"
"#if defined (REPEAT_E8)\n"
"#define repeat_e(a,b,c) a=a; b=0; c=0;\n"
"#endif\n"
"#if defined (REPEAT_E9)\n"
"#define repeat_e(a,b,c) a.s3=0; b=0; c=0;\n"
"#endif\n"
"#if defined (REPEAT_E10)\n"
"#define repeat_e(a,b,c) a.s3=0; a.s2=0; b=0; c=0;\n"
"#endif\n"
"#if defined (REPEAT_E11)\n"
"#define repeat_e(a,b,c) a.s3=0; a.s2=0; a.s1=0; b=0; c=0;\n"
"#endif\n"
"__kernel void arithm_op_sum_3 (int cols,int invalid_cols,int offset,int elemnum,int groupnum,\n"
"__global VEC_TYPE *src, __global RES_TYPE *dst)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"unsigned int id = get_global_id(0);\n"
"unsigned int idx = offset + id + (id  / cols) * invalid_cols;\n"
"idx = idx * 3;\n"
"__local RES_TYPE localmem_sum1[128];\n"
"__local RES_TYPE localmem_sum2[128];\n"
"__local RES_TYPE localmem_sum3[128];\n"
"RES_TYPE sum1 = 0,sum2 = 0,sum3 = 0,temp1,temp2,temp3;\n"
"if(id < elemnum)\n"
"{\n"
"temp1 = CONVERT_RES_TYPE(src[idx]);\n"
"temp2 = CONVERT_RES_TYPE(src[idx+1]);\n"
"temp3 = CONVERT_RES_TYPE(src[idx+2]);\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp1,temp2,temp3);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp1,temp2,temp3);\n"
"}\n"
"FUNC(temp1,sum1);\n"
"FUNC(temp2,sum2);\n"
"FUNC(temp3,sum3);\n"
"}\n"
"else\n"
"{\n"
"sum1 = 0;\n"
"sum2 = 0;\n"
"sum3 = 0;\n"
"}\n"
"for(id=id + (groupnum << 8); id < elemnum;id = id + (groupnum << 8))\n"
"{\n"
"idx = offset + id + (id / cols) * invalid_cols;\n"
"idx = idx * 3;\n"
"temp1 = CONVERT_RES_TYPE(src[idx]);\n"
"temp2 = CONVERT_RES_TYPE(src[idx+1]);\n"
"temp3 = CONVERT_RES_TYPE(src[idx+2]);\n"
"if(id % cols == 0 )\n"
"{\n"
"repeat_s(temp1,temp2,temp3);\n"
"}\n"
"if(id % cols == cols - 1)\n"
"{\n"
"repeat_e(temp1,temp2,temp3);\n"
"}\n"
"FUNC(temp1,sum1);\n"
"FUNC(temp2,sum2);\n"
"FUNC(temp3,sum3);\n"
"}\n"
"if(lid > 127)\n"
"{\n"
"localmem_sum1[lid - 128] = sum1;\n"
"localmem_sum2[lid - 128] = sum2;\n"
"localmem_sum3[lid - 128] = sum3;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 128)\n"
"{\n"
"localmem_sum1[lid] = sum1 + localmem_sum1[lid];\n"
"localmem_sum2[lid] = sum2 + localmem_sum2[lid];\n"
"localmem_sum3[lid] = sum3 + localmem_sum3[lid];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int lsize = 64; lsize > 0; lsize >>= 1)\n"
"{\n"
"if(lid < lsize)\n"
"{\n"
"int lid2 = lsize + lid;\n"
"localmem_sum1[lid] = localmem_sum1[lid] + localmem_sum1[lid2];\n"
"localmem_sum2[lid] = localmem_sum2[lid] + localmem_sum2[lid2];\n"
"localmem_sum3[lid] = localmem_sum3[lid] + localmem_sum3[lid2];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if( lid == 0)\n"
"{\n"
"dst[gid*3]   = localmem_sum1[0];\n"
"dst[gid*3+1] = localmem_sum2[0];\n"
"dst[gid*3+2] = localmem_sum3[0];\n"
"}\n"
"}\n"
;
const char* arithm_transpose="#define TILE_DIM      32\n"
"#define BLOCK_ROWS    8\n"
"#define LDS_STEP     (TILE_DIM + 1)\n"
"__kernel void transpose_C1_D0(__global uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int src_rows, int src_cols)\n"
"{\n"
"int gp_x = get_group_id(0),   gp_y = get_group_id(1);\n"
"int gs_x = get_num_groups(0), gs_y = get_num_groups(1);\n"
"int groupId_x, groupId_y;\n"
"if(src_rows == src_cols)\n"
"{\n"
"groupId_y = gp_x;\n"
"groupId_x = (gp_x + gp_y) % gs_x;\n"
"}\n"
"else\n"
"{\n"
"int bid = gp_x + gs_x * gp_y;\n"
"groupId_y =  bid % gs_y;\n"
"groupId_x = ((bid / gs_y) + groupId_y) % gs_x;\n"
"}\n"
"int lx = get_local_id(0);\n"
"int ly = get_local_id(1);\n"
"int x = groupId_x * TILE_DIM + lx;\n"
"int y = groupId_y * TILE_DIM + ly;\n"
"int x_index = groupId_y * TILE_DIM + lx;\n"
"int y_index = groupId_x * TILE_DIM + ly;\n"
"__local uchar title[TILE_DIM * LDS_STEP];\n"
"if(x < src_cols && y < src_rows)\n"
"{\n"
"int index_src = mad24(y, src_step, x);\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if(y + i < src_rows)\n"
"{\n"
"title[(ly + i) * LDS_STEP + lx] =*(src + src_offset + index_src);\n"
"index_src = mad24(BLOCK_ROWS, src_step, index_src);\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(x_index < src_rows && y_index < src_cols)\n"
"{\n"
"int index_dst = mad24(y_index, dst_step, x_index);\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if((y_index + i) < src_cols)\n"
"{\n"
"*(dst + dst_offset + index_dst ) = title[lx * LDS_STEP + ly + i];\n"
"index_dst +=  dst_step * BLOCK_ROWS ;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel void transpose_C1_D4(__global int* src, int src_step, int src_offset,\n"
"__global int* dst, int dst_step, int dst_offset,\n"
"int src_rows, int src_cols)\n"
"{\n"
"int gp_x = get_group_id(0),   gp_y = get_group_id(1);\n"
"int gs_x = get_num_groups(0), gs_y = get_num_groups(1);\n"
"int groupId_x, groupId_y;\n"
"if(src_rows == src_cols)\n"
"{\n"
"groupId_y = gp_x;\n"
"groupId_x = (gp_x + gp_y) % gs_x;\n"
"}\n"
"else\n"
"{\n"
"int bid = gp_x + gs_x * gp_y;\n"
"groupId_y =  bid % gs_y;\n"
"groupId_x = ((bid / gs_y) + groupId_y) % gs_x;\n"
"}\n"
"int lx = get_local_id(0);\n"
"int ly = get_local_id(1);\n"
"int x = groupId_x * TILE_DIM + lx;\n"
"int y = groupId_y * TILE_DIM + ly;\n"
"int x_index = groupId_y * TILE_DIM + lx;\n"
"int y_index = groupId_x * TILE_DIM + ly;\n"
"__local int title[TILE_DIM * LDS_STEP];\n"
"if(x < src_cols && y < src_rows)\n"
"{\n"
"int index_src = mad24(y, src_step, (x << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if(y + i < src_rows)\n"
"{\n"
"title[(ly + i) * LDS_STEP + lx] = *((__global int *)((__global char*)src + src_offset + index_src));\n"
"index_src = mad24(BLOCK_ROWS, src_step, index_src);\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(x_index < src_rows && y_index < src_cols)\n"
"{\n"
"int index_dst = mad24(y_index, dst_step, (x_index << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if((y_index + i) < src_cols)\n"
"{\n"
"*((__global int*)((__global char*)dst + dst_offset + index_dst )) = title[lx * LDS_STEP + ly + i];\n"
"index_dst +=  dst_step * BLOCK_ROWS ;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel void transpose_C1_D5(__global float* src, int src_step, int src_offset,\n"
"__global float* dst, int dst_step, int dst_offset,\n"
"int src_rows, int src_cols)\n"
"{\n"
"int gp_x = get_group_id(0),   gp_y = get_group_id(1);\n"
"int gs_x = get_num_groups(0), gs_y = get_num_groups(1);\n"
"int groupId_x, groupId_y;\n"
"if(src_rows == src_cols)\n"
"{\n"
"groupId_y = gp_x;\n"
"groupId_x = (gp_x + gp_y) % gs_x;\n"
"}\n"
"else\n"
"{\n"
"int bid = gp_x + gs_x * gp_y;\n"
"groupId_y =  bid % gs_y;\n"
"groupId_x = ((bid / gs_y) + groupId_y) % gs_x;\n"
"}\n"
"int lx = get_local_id(0);\n"
"int ly = get_local_id(1);\n"
"int x = groupId_x * TILE_DIM + lx;\n"
"int y = groupId_y * TILE_DIM + ly;\n"
"int x_index = groupId_y * TILE_DIM + lx;\n"
"int y_index = groupId_x * TILE_DIM + ly;\n"
"__local float title[TILE_DIM * LDS_STEP];\n"
"if(x < src_cols && y < src_rows)\n"
"{\n"
"int index_src = mad24(y, src_step, (x << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if(y + i < src_rows)\n"
"{\n"
"title[(ly + i) * LDS_STEP + lx] = *((__global float *)((__global char*)src + src_offset + index_src));\n"
"index_src = mad24(BLOCK_ROWS, src_step, index_src);\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(x_index < src_rows && y_index < src_cols)\n"
"{\n"
"int index_dst = mad24(y_index, dst_step, (x_index << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if((y_index + i) < src_cols)\n"
"{\n"
"*((__global float*)((__global char*)dst + dst_offset + index_dst )) = title[lx * LDS_STEP + ly + i];\n"
"index_dst +=  dst_step * BLOCK_ROWS ;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel void transpose_C2_D2(__global ushort* src, int src_step, int src_offset,\n"
"__global ushort* dst, int dst_step, int dst_offset,\n"
"int src_rows, int src_cols)\n"
"{\n"
"int gp_x = get_group_id(0),   gp_y = get_group_id(1);\n"
"int gs_x = get_num_groups(0), gs_y = get_num_groups(1);\n"
"int groupId_x, groupId_y;\n"
"if(src_rows == src_cols)\n"
"{\n"
"groupId_y = gp_x;\n"
"groupId_x = (gp_x + gp_y) % gs_x;\n"
"}\n"
"else\n"
"{\n"
"int bid = gp_x + gs_x * gp_y;\n"
"groupId_y =  bid % gs_y;\n"
"groupId_x = ((bid / gs_y) + groupId_y) % gs_x;\n"
"}\n"
"int lx = get_local_id(0);\n"
"int ly = get_local_id(1);\n"
"int x = groupId_x * TILE_DIM + lx;\n"
"int y = groupId_y * TILE_DIM + ly;\n"
"int x_index = groupId_y * TILE_DIM + lx;\n"
"int y_index = groupId_x * TILE_DIM + ly;\n"
"__local ushort2 title[TILE_DIM * LDS_STEP];\n"
"if(x < src_cols && y < src_rows)\n"
"{\n"
"int index_src = mad24(y, src_step, (x << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if(y + i < src_rows)\n"
"{\n"
"title[(ly + i) * LDS_STEP + lx] = *((__global ushort2 *)((__global char*)src + src_offset + index_src));\n"
"index_src = mad24(BLOCK_ROWS, src_step, index_src);\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(x_index < src_rows && y_index < src_cols)\n"
"{\n"
"int index_dst = mad24(y_index, dst_step, (x_index << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if((y_index + i) < src_cols)\n"
"{\n"
"*((__global ushort2*)((__global char*)dst + dst_offset + index_dst )) = title[lx * LDS_STEP + ly + i];\n"
"index_dst +=  dst_step * BLOCK_ROWS ;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel void transpose_C2_D3(__global short* src, int src_step, int src_offset,\n"
"__global short* dst, int dst_step, int dst_offset,\n"
"int src_rows, int src_cols)\n"
"{\n"
"int gp_x = get_group_id(0),   gp_y = get_group_id(1);\n"
"int gs_x = get_num_groups(0), gs_y = get_num_groups(1);\n"
"int groupId_x, groupId_y;\n"
"if(src_rows == src_cols)\n"
"{\n"
"groupId_y = gp_x;\n"
"groupId_x = (gp_x + gp_y) % gs_x;\n"
"}\n"
"else\n"
"{\n"
"int bid = gp_x + gs_x * gp_y;\n"
"groupId_y =  bid % gs_y;\n"
"groupId_x = ((bid / gs_y) + groupId_y) % gs_x;\n"
"}\n"
"int lx = get_local_id(0);\n"
"int ly = get_local_id(1);\n"
"int x = groupId_x * TILE_DIM + lx;\n"
"int y = groupId_y * TILE_DIM + ly;\n"
"int x_index = groupId_y * TILE_DIM + lx;\n"
"int y_index = groupId_x * TILE_DIM + ly;\n"
"__local short2 title[TILE_DIM * LDS_STEP];\n"
"if(x < src_cols && y < src_rows)\n"
"{\n"
"int index_src = mad24(y, src_step, (x << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if(y + i < src_rows)\n"
"{\n"
"title[(ly + i) * LDS_STEP + lx] = *((__global short2 *)((__global char*)src + src_offset + index_src));\n"
"index_src = mad24(BLOCK_ROWS, src_step, index_src);\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(x_index < src_rows && y_index < src_cols)\n"
"{\n"
"int index_dst = mad24(y_index, dst_step, (x_index << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if((y_index + i) < src_cols)\n"
"{\n"
"*((__global short2*)((__global char*)dst + dst_offset + index_dst )) = title[lx * LDS_STEP + ly + i];\n"
"index_dst +=  dst_step * BLOCK_ROWS ;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel void transpose_C4_D0(__global uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int src_rows, int src_cols)\n"
"{\n"
"int gp_x = get_group_id(0),   gp_y = get_group_id(1);\n"
"int gs_x = get_num_groups(0), gs_y = get_num_groups(1);\n"
"int groupId_x, groupId_y;\n"
"if(src_rows == src_cols)\n"
"{\n"
"groupId_y = gp_x;\n"
"groupId_x = (gp_x + gp_y) % gs_x;\n"
"}\n"
"else\n"
"{\n"
"int bid = gp_x + gs_x * gp_y;\n"
"groupId_y =  bid % gs_y;\n"
"groupId_x = ((bid / gs_y) + groupId_y) % gs_x;\n"
"}\n"
"int lx = get_local_id(0);\n"
"int ly = get_local_id(1);\n"
"int x = groupId_x * TILE_DIM + lx;\n"
"int y = groupId_y * TILE_DIM + ly;\n"
"int x_index = groupId_y * TILE_DIM + lx;\n"
"int y_index = groupId_x * TILE_DIM + ly;\n"
"__local uchar4 title[TILE_DIM * LDS_STEP];\n"
"if(x < src_cols && y < src_rows)\n"
"{\n"
"int index_src = mad24(y, src_step, (x << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if(y + i < src_rows)\n"
"{\n"
"title[(ly + i) * LDS_STEP + lx] = *((__global uchar4 *)(src + src_offset + index_src));\n"
"index_src = mad24(BLOCK_ROWS, src_step, index_src);\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(x_index < src_rows && y_index < src_cols)\n"
"{\n"
"int index_dst = mad24(y_index, dst_step, (x_index << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if((y_index + i) < src_cols)\n"
"{\n"
"*((__global uchar4*)(dst + dst_offset + index_dst )) = title[lx * LDS_STEP + ly + i];\n"
"index_dst +=  dst_step * BLOCK_ROWS ;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel void transpose_C4_D1(__global char* src, int src_step, int src_offset,\n"
"__global char* dst, int dst_step, int dst_offset,\n"
"int src_rows, int src_cols)\n"
"{\n"
"int gp_x = get_group_id(0),   gp_y = get_group_id(1);\n"
"int gs_x = get_num_groups(0), gs_y = get_num_groups(1);\n"
"int groupId_x, groupId_y;\n"
"if(src_rows == src_cols)\n"
"{\n"
"groupId_y = gp_x;\n"
"groupId_x = (gp_x + gp_y) % gs_x;\n"
"}\n"
"else\n"
"{\n"
"int bid = gp_x + gs_x * gp_y;\n"
"groupId_y =  bid % gs_y;\n"
"groupId_x = ((bid / gs_y) + groupId_y) % gs_x;\n"
"}\n"
"int lx = get_local_id(0);\n"
"int ly = get_local_id(1);\n"
"int x = groupId_x * TILE_DIM + lx;\n"
"int y = groupId_y * TILE_DIM + ly;\n"
"int x_index = groupId_y * TILE_DIM + lx;\n"
"int y_index = groupId_x * TILE_DIM + ly;\n"
"__local char4 title[TILE_DIM * LDS_STEP];\n"
"if(x < src_cols && y < src_rows)\n"
"{\n"
"int index_src = mad24(y, src_step, (x << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if(y + i < src_rows)\n"
"{\n"
"title[(ly + i) * LDS_STEP + lx] = *((__global char4 *)(src + src_offset + index_src));\n"
"index_src = mad24(BLOCK_ROWS, src_step, index_src);\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(x_index < src_rows && y_index < src_cols)\n"
"{\n"
"int index_dst = mad24(y_index, dst_step, (x_index << 2));\n"
"#pragma unroll\n"
"for(int i = 0; i < TILE_DIM; i += BLOCK_ROWS)\n"
"{\n"
"if((y_index + i) < src_cols)\n"
"{\n"
"*((__global char4*)(dst + dst_offset + index_dst )) = title[lx * LDS_STEP + ly + i];\n"
"index_dst +=  dst_step * BLOCK_ROWS ;\n"
"}\n"
"}\n"
"}\n"
"}\n"
;
const char* blend_linear="__kernel void BlendLinear_C1_D0(\n"
"__global uchar4 *dst,\n"
"__global uchar4 *img1,\n"
"__global uchar4 *img2,\n"
"__global float4 *weight1,\n"
"__global float4 *weight2,\n"
"int rows,\n"
"int cols,\n"
"int istep,\n"
"int wstep\n"
")\n"
"{\n"
"int idx = get_global_id(0);\n"
"int idy = get_global_id(1);\n"
"if (idx << 2 < cols && idy < rows)\n"
"{\n"
"int pos = mad24(idy,istep >> 2,idx);\n"
"int wpos = mad24(idy,wstep >> 2,idx);\n"
"float4 w1 = weight1[wpos], w2 = weight2[wpos];\n"
"dst[pos] = convert_uchar4((convert_float4(img1[pos]) * w1 +\n"
"convert_float4(img2[pos]) * w2) / (w1 + w2 + 1e-5f));\n"
"}\n"
"}\n"
"__kernel void BlendLinear_C4_D0(\n"
"__global uchar4 *dst,\n"
"__global uchar4 *img1,\n"
"__global uchar4 *img2,\n"
"__global float *weight1,\n"
"__global float *weight2,\n"
"int rows,\n"
"int cols,\n"
"int istep,\n"
"int wstep\n"
")\n"
"{\n"
"int idx = get_global_id(0);\n"
"int idy = get_global_id(1);\n"
"if (idx < cols && idy < rows)\n"
"{\n"
"int pos = mad24(idy,istep >> 2,idx);\n"
"int wpos = mad24(idy,wstep, idx);\n"
"float w1 = weight1[wpos];\n"
"float w2 = weight2[wpos];\n"
"dst[pos] = convert_uchar4((convert_float4(img1[pos]) * w1 +\n"
"convert_float4(img2[pos]) * w2) / (w1 + w2 + 1e-5f));\n"
"}\n"
"}\n"
"__kernel void BlendLinear_C1_D5(\n"
"__global float4 *dst,\n"
"__global float4 *img1,\n"
"__global float4 *img2,\n"
"__global float4 *weight1,\n"
"__global float4 *weight2,\n"
"int rows,\n"
"int cols,\n"
"int istep,\n"
"int wstep\n"
")\n"
"{\n"
"int idx = get_global_id(0);\n"
"int idy = get_global_id(1);\n"
"if (idx << 2 < cols && idy < rows)\n"
"{\n"
"int pos = mad24(idy,istep >> 2,idx);\n"
"int wpos = mad24(idy,wstep >> 2,idx);\n"
"float4 w1 = weight1[wpos], w2 = weight2[wpos];\n"
"dst[pos] = (img1[pos] * w1 + img2[pos] * w2) / (w1 + w2 + 1e-5f);\n"
"}\n"
"}\n"
"__kernel void BlendLinear_C4_D5(\n"
"__global float4 *dst,\n"
"__global float4 *img1,\n"
"__global float4 *img2,\n"
"__global float *weight1,\n"
"__global float *weight2,\n"
"int rows,\n"
"int cols,\n"
"int istep,\n"
"int wstep\n"
")\n"
"{\n"
"int idx = get_global_id(0);\n"
"int idy = get_global_id(1);\n"
"if (idx < cols && idy < rows)\n"
"{\n"
"int pos = mad24(idy,istep >> 2,idx);\n"
"int wpos = mad24(idy,wstep, idx);\n"
"float w1 = weight1[wpos];\n"
"float w2 = weight2[wpos];\n"
"dst[pos] = (img1[pos] * w1 + img2[pos] * w2) / (w1 + w2 + 1e-5f);\n"
"}\n"
"}\n"
;
const char* brute_force_match="#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics:enable\n"
"#define MAX_FLOAT 1e7f\n"
"int bit1Count(float x)\n"
"{\n"
"int c = 0;\n"
"int ix = (int)x;\n"
"for (int i = 0 ; i < 32 ; i++)\n"
"{\n"
"c += ix & 0x1;\n"
"ix >>= 1;\n"
"}\n"
"return (float)c;\n"
"}\n"
"float reduce_block(__local float *s_query,\n"
"__local float *s_train,\n"
"int block_size,\n"
"int lidx,\n"
"int lidy,\n"
"int distType\n"
")\n"
"{\n"
"float result = 0;\n"
"switch(distType)\n"
"{\n"
"case 0:\n"
"for (int j = 0 ; j < block_size ; j++)\n"
"{\n"
"result += fabs(s_query[lidy * block_size + j] -  s_train[j * block_size + lidx]);\n"
"}\n"
"break;\n"
"case 1:\n"
"for (int j = 0 ; j < block_size ; j++)\n"
"{\n"
"float qr = s_query[lidy * block_size + j] -  s_train[j * block_size + lidx];\n"
"result += qr * qr;\n"
"}\n"
"break;\n"
"case 2:\n"
"for (int j = 0 ; j < block_size ; j++)\n"
"{\n"
"result += bit1Count((uint)s_query[lidy * block_size + j] ^ (uint)s_train[(uint)j * block_size + lidx]);\n"
"}\n"
"break;\n"
"}\n"
"return result;\n"
"}\n"
"float reduce_multi_block(__local float *s_query,\n"
"__local float *s_train,\n"
"int max_desc_len,\n"
"int block_size,\n"
"int block_index,\n"
"int lidx,\n"
"int lidy,\n"
"int distType\n"
")\n"
"{\n"
"float result = 0;\n"
"switch(distType)\n"
"{\n"
"case 0:\n"
"for (int j = 0 ; j < block_size ; j++)\n"
"{\n"
"result += fabs(s_query[lidy * max_desc_len + block_index * block_size + j] -  s_train[j * block_size + lidx]);\n"
"}\n"
"break;\n"
"case 1:\n"
"for (int j = 0 ; j < block_size ; j++)\n"
"{\n"
"float qr = s_query[lidy * max_desc_len + block_index * block_size + j] -  s_train[j * block_size + lidx];\n"
"result += qr * qr;\n"
"}\n"
"break;\n"
"case 2:\n"
"for (int j = 0 ; j < block_size ; j++)\n"
"{\n"
"result += bit1Count((uint)s_query[lidy * max_desc_len + block_index * block_size + j] ^ (uint)s_train[j * block_size + lidx]);\n"
"}\n"
"break;\n"
"}\n"
"return result;\n"
"}\n"
"__kernel void BruteForceMatch_UnrollMatch_D5(\n"
"__global float *query,\n"
"__global float *train,\n"
"__global int *bestTrainIdx,\n"
"__global float *bestDistance,\n"
"__local float *sharebuffer,\n"
"int block_size,\n"
"int max_desc_len,\n"
"int query_rows,\n"
"int query_cols,\n"
"int train_rows,\n"
"int train_cols,\n"
"int step,\n"
"int distType\n"
")\n"
"{\n"
"const int lidx = get_local_id(0);\n"
"const int lidy = get_local_id(1);\n"
"const int groupidx = get_group_id(0);\n"
"__local float *s_query = sharebuffer;\n"
"__local float *s_train = sharebuffer + block_size * max_desc_len;\n"
"int queryIdx = groupidx * block_size + lidy;\n"
"for (int i = 0 ;  i <  max_desc_len / block_size; i ++)\n"
"{\n"
"int loadx = lidx + i * block_size;\n"
"s_query[lidy * max_desc_len + loadx] = loadx < query_cols ? query[min(queryIdx, query_rows - 1)  * (step / sizeof(float)) + loadx] : 0;\n"
"}\n"
"float myBestDistance = MAX_FLOAT;\n"
"int myBestTrainIdx = -1;\n"
"volatile int imgIdx = 0;\n"
"for (int t = 0 ; t < (train_rows + block_size - 1) / block_size ; t++)\n"
"{\n"
"float result = 0;\n"
"for (int i = 0 ; i < max_desc_len / block_size ; i++)\n"
"{\n"
"const int loadx = lidx + i * block_size;\n"
"s_train[lidx * block_size + lidy] = loadx < train_cols ? train[min(t * block_size + lidy, train_rows - 1) * (step / sizeof(float)) + loadx] : 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"result += reduce_multi_block(s_query, s_train, max_desc_len, block_size, i, lidx, lidy, distType);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"int trainIdx = t * block_size + lidx;\n"
"if (queryIdx < query_rows && trainIdx < train_rows && result < myBestDistance)\n"
"{\n"
"myBestDistance = result;\n"
"myBestTrainIdx = trainIdx;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"__local float *s_distance = (__local float*)(sharebuffer);\n"
"__local int* s_trainIdx = (__local int *)(sharebuffer + block_size * block_size);\n"
"s_distance += lidy * block_size;\n"
"s_trainIdx += lidy * block_size;\n"
"s_distance[lidx] = myBestDistance;\n"
"s_trainIdx[lidx] = myBestTrainIdx;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int k = 0 ; k < block_size; k++)\n"
"{\n"
"if (myBestDistance > s_distance[k])\n"
"{\n"
"myBestDistance = s_distance[k];\n"
"myBestTrainIdx = s_trainIdx[k];\n"
"}\n"
"}\n"
"if (queryIdx < query_rows && lidx == 0)\n"
"{\n"
"bestTrainIdx[queryIdx] = myBestTrainIdx;\n"
"bestDistance[queryIdx] = myBestDistance;\n"
"}\n"
"}\n"
"__kernel void BruteForceMatch_Match_D5(\n"
"__global float *query,\n"
"__global float *train,\n"
"__global int *bestTrainIdx,\n"
"__global float *bestDistance,\n"
"__local float *sharebuffer,\n"
"int block_size,\n"
"int query_rows,\n"
"int query_cols,\n"
"int train_rows,\n"
"int train_cols,\n"
"int step,\n"
"int distType\n"
")\n"
"{\n"
"const int lidx = get_local_id(0);\n"
"const int lidy = get_local_id(1);\n"
"const int groupidx = get_group_id(0);\n"
"const int queryIdx = groupidx * block_size + lidy;\n"
"float myBestDistance = MAX_FLOAT;\n"
"int myBestTrainIdx = -1;\n"
"__local float *s_query = sharebuffer;\n"
"__local float *s_train = sharebuffer + block_size * block_size;\n"
"for (int t = 0 ;  t < (train_rows + block_size - 1) / block_size ; t++)\n"
"{\n"
"float result = 0;\n"
"for (int i = 0 ; i < (query_cols + block_size - 1) / block_size ; i++)\n"
"{\n"
"const int loadx = lidx + i * block_size;\n"
"s_query[lidy * block_size + lidx] = 0;\n"
"s_train[lidx * block_size + lidy] = 0;\n"
"if (loadx < query_cols)\n"
"{\n"
"s_query[lidy * block_size + lidx] = query[min(queryIdx, query_rows - 1) * (step / sizeof(float)) + loadx];\n"
"s_train[lidx * block_size + lidy] = train[min(t * block_size + lidy, train_rows - 1) * (step / sizeof(float)) + loadx];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"result += reduce_block(s_query, s_train, block_size, lidx, lidy, distType);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"const int trainIdx = t * block_size + lidx;\n"
"if (queryIdx < query_rows && trainIdx < train_rows && result < myBestDistance )\n"
"{\n"
"myBestDistance = result;\n"
"myBestTrainIdx = trainIdx;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"__local float *s_distance = (__local float *)sharebuffer;\n"
"__local int *s_trainIdx = (__local int *)(sharebuffer + block_size * block_size);\n"
"s_distance += lidy * block_size;\n"
"s_trainIdx += lidy * block_size;\n"
"s_distance[lidx] = myBestDistance;\n"
"s_trainIdx[lidx] = myBestTrainIdx;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int k = 0 ; k < block_size; k++)\n"
"{\n"
"if (myBestDistance > s_distance[k])\n"
"{\n"
"myBestDistance = s_distance[k];\n"
"myBestTrainIdx = s_trainIdx[k];\n"
"}\n"
"}\n"
"if (queryIdx < query_rows && lidx == 0)\n"
"{\n"
"bestTrainIdx[queryIdx] = myBestTrainIdx;\n"
"bestDistance[queryIdx] = myBestDistance;\n"
"}\n"
"}\n"
"__kernel void BruteForceMatch_RadiusUnrollMatch_D5(\n"
"__global float *query,\n"
"__global float *train,\n"
"float maxDistance,\n"
"__global int *bestTrainIdx,\n"
"__global float *bestDistance,\n"
"__global int *nMatches,\n"
"__local float *sharebuffer,\n"
"int block_size,\n"
"int max_desc_len,\n"
"int query_rows,\n"
"int query_cols,\n"
"int train_rows,\n"
"int train_cols,\n"
"int bestTrainIdx_cols,\n"
"int step,\n"
"int ostep,\n"
"int distType\n"
")\n"
"{\n"
"const int lidx = get_local_id(0);\n"
"const int lidy = get_local_id(1);\n"
"const int groupidx = get_group_id(0);\n"
"const int groupidy = get_group_id(1);\n"
"const int queryIdx = groupidy * block_size + lidy;\n"
"const int trainIdx = groupidx * block_size + lidx;\n"
"__local float *s_query = sharebuffer;\n"
"__local float *s_train = sharebuffer + block_size * block_size;\n"
"float result = 0;\n"
"for (int i = 0 ; i < max_desc_len / block_size ; ++i)\n"
"{\n"
"const int loadx = lidx + i * block_size;\n"
"s_query[lidy * block_size + lidx] = loadx < query_cols ? query[min(queryIdx, query_rows - 1)  * (step / sizeof(float)) + loadx] : 0;\n"
"s_train[lidx * block_size + lidy] = loadx < query_cols ? train[min(groupidx * block_size + lidy, train_rows - 1)  * (step / sizeof(float)) + loadx] : 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"result += reduce_block(s_query, s_train, block_size, lidx, lidy, distType);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (queryIdx < query_rows && trainIdx < train_rows && result < maxDistance)\n"
"{\n"
"unsigned int ind = atom_inc(nMatches + queryIdx);\n"
"if(ind < bestTrainIdx_cols)\n"
"{\n"
"bestTrainIdx[queryIdx * (ostep / sizeof(int)) + ind] = trainIdx;\n"
"bestDistance[queryIdx * (ostep / sizeof(float)) + ind] = result;\n"
"}\n"
"}\n"
"}\n"
"__kernel void BruteForceMatch_RadiusMatch_D5(\n"
"__global float *query,\n"
"__global float *train,\n"
"float maxDistance,\n"
"__global int *bestTrainIdx,\n"
"__global float *bestDistance,\n"
"__global int *nMatches,\n"
"__local float *sharebuffer,\n"
"int block_size,\n"
"int query_rows,\n"
"int query_cols,\n"
"int train_rows,\n"
"int train_cols,\n"
"int bestTrainIdx_cols,\n"
"int step,\n"
"int ostep,\n"
"int distType\n"
")\n"
"{\n"
"const int lidx = get_local_id(0);\n"
"const int lidy = get_local_id(1);\n"
"const int groupidx = get_group_id(0);\n"
"const int groupidy = get_group_id(1);\n"
"const int queryIdx = groupidy * block_size + lidy;\n"
"const int trainIdx = groupidx * block_size + lidx;\n"
"__local float *s_query = sharebuffer;\n"
"__local float *s_train = sharebuffer + block_size * block_size;\n"
"float result = 0;\n"
"for (int i = 0 ; i < (query_cols + block_size - 1) / block_size ; ++i)\n"
"{\n"
"const int loadx = lidx + i * block_size;\n"
"s_query[lidy * block_size + lidx] = loadx < query_cols ? query[min(queryIdx, query_rows - 1)  * (step / sizeof(float)) + loadx] : 0;\n"
"s_train[lidx * block_size + lidy] = loadx < query_cols ? train[min(groupidx * block_size + lidy, train_rows - 1)  * (step / sizeof(float)) + loadx] : 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"result += reduce_block(s_query, s_train, block_size, lidx, lidy, distType);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (queryIdx < query_rows && trainIdx < train_rows && result < maxDistance)\n"
"{\n"
"unsigned int ind = atom_inc(nMatches + queryIdx);\n"
"if(ind < bestTrainIdx_cols)\n"
"{\n"
"bestTrainIdx[queryIdx * (ostep / sizeof(int)) + ind] = trainIdx;\n"
"bestDistance[queryIdx * (ostep / sizeof(float)) + ind] = result;\n"
"}\n"
"}\n"
"}\n"
"__kernel void BruteForceMatch_knnUnrollMatch_D5(\n"
"__global float *query,\n"
"__global float *train,\n"
"__global int2 *bestTrainIdx,\n"
"__global float2 *bestDistance,\n"
"__local float *sharebuffer,\n"
"int block_size,\n"
"int max_desc_len,\n"
"int query_rows,\n"
"int query_cols,\n"
"int train_rows,\n"
"int train_cols,\n"
"int step,\n"
"int distType\n"
")\n"
"{\n"
"const int lidx = get_local_id(0);\n"
"const int lidy = get_local_id(1);\n"
"const int groupidx = get_group_id(0);\n"
"const int queryIdx = groupidx * block_size + lidy;\n"
"local float *s_query = sharebuffer;\n"
"local float *s_train = sharebuffer + block_size * max_desc_len;\n"
"for (int i = 0 ;  i <  max_desc_len / block_size; i ++)\n"
"{\n"
"int loadx = lidx + i * block_size;\n"
"s_query[lidy * max_desc_len + loadx] = loadx < query_cols ? query[min(queryIdx, query_rows - 1)  * (step / sizeof(float)) + loadx] : 0;\n"
"}\n"
"float myBestDistance1 = MAX_FLOAT;\n"
"float myBestDistance2 = MAX_FLOAT;\n"
"int myBestTrainIdx1 = -1;\n"
"int myBestTrainIdx2 = -1;\n"
"volatile int imgIdx = 0;\n"
"for (int t = 0 ; t < (train_rows + block_size - 1) / block_size ; t++)\n"
"{\n"
"float result = 0;\n"
"for (int i = 0 ; i < max_desc_len / block_size ; i++)\n"
"{\n"
"const int loadX = lidx + i * block_size;\n"
"const int loadx = lidx + i * block_size;\n"
"s_train[lidx * block_size + lidy] = loadx < train_cols ? train[min(t * block_size + lidy, train_rows - 1) * (step / sizeof(float)) + loadx] : 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"result += reduce_multi_block(s_query, s_train, max_desc_len, block_size, i, lidx, lidy, distType);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"const int trainIdx = t * block_size + lidx;\n"
"if (queryIdx < query_rows && trainIdx < train_rows)\n"
"{\n"
"if (result < myBestDistance1)\n"
"{\n"
"myBestDistance2 = myBestDistance1;\n"
"myBestTrainIdx2 = myBestTrainIdx1;\n"
"myBestDistance1 = result;\n"
"myBestTrainIdx1 = trainIdx;\n"
"}\n"
"else if (result < myBestDistance2)\n"
"{\n"
"myBestDistance2 = result;\n"
"myBestTrainIdx2 = trainIdx;\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"local float *s_distance = (local float *)sharebuffer;\n"
"local int *s_trainIdx = (local int *)(sharebuffer + block_size * block_size);\n"
"s_distance += lidy * block_size;\n"
"s_trainIdx += lidy * block_size;\n"
"s_distance[lidx] = myBestDistance1;\n"
"s_trainIdx[lidx] = myBestTrainIdx1;\n"
"float bestDistance1 = MAX_FLOAT;\n"
"float bestDistance2 = MAX_FLOAT;\n"
"int bestTrainIdx1 = -1;\n"
"int bestTrainIdx2 = -1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lidx == 0)\n"
"{\n"
"for (int i = 0 ; i < block_size ; i++)\n"
"{\n"
"float val = s_distance[i];\n"
"if (val < bestDistance1)\n"
"{\n"
"bestDistance2 = bestDistance1;\n"
"bestTrainIdx2 = bestTrainIdx1;\n"
"bestDistance1 = val;\n"
"bestTrainIdx1 = s_trainIdx[i];\n"
"}\n"
"else if (val < bestDistance2)\n"
"{\n"
"bestDistance2 = val;\n"
"bestTrainIdx2 = s_trainIdx[i];\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"s_distance[lidx] = myBestDistance2;\n"
"s_trainIdx[lidx] = myBestTrainIdx2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lidx == 0)\n"
"{\n"
"for (int i = 0 ; i < block_size ; i++)\n"
"{\n"
"float val = s_distance[i];\n"
"if (val < bestDistance2)\n"
"{\n"
"bestDistance2 = val;\n"
"bestTrainIdx2 = s_trainIdx[i];\n"
"}\n"
"}\n"
"}\n"
"myBestDistance1 = bestDistance1;\n"
"myBestDistance2 = bestDistance2;\n"
"myBestTrainIdx1 = bestTrainIdx1;\n"
"myBestTrainIdx2 = bestTrainIdx2;\n"
"if (queryIdx < query_rows && lidx == 0)\n"
"{\n"
"bestTrainIdx[queryIdx] = (int2)(myBestTrainIdx1, myBestTrainIdx2);\n"
"bestDistance[queryIdx] = (float2)(myBestDistance1, myBestDistance2);\n"
"}\n"
"}\n"
"__kernel void BruteForceMatch_knnMatch_D5(\n"
"__global float *query,\n"
"__global float *train,\n"
"__global int2 *bestTrainIdx,\n"
"__global float2 *bestDistance,\n"
"__local float *sharebuffer,\n"
"int block_size,\n"
"int query_rows,\n"
"int query_cols,\n"
"int train_rows,\n"
"int train_cols,\n"
"int step,\n"
"int distType\n"
")\n"
"{\n"
"const int lidx = get_local_id(0);\n"
"const int lidy = get_local_id(1);\n"
"const int groupidx = get_group_id(0);\n"
"const int queryIdx = groupidx * block_size + lidy;\n"
"local float *s_query = sharebuffer;\n"
"local float *s_train = sharebuffer + block_size * block_size;\n"
"float myBestDistance1 = MAX_FLOAT;\n"
"float myBestDistance2 = MAX_FLOAT;\n"
"int myBestTrainIdx1 = -1;\n"
"int myBestTrainIdx2 = -1;\n"
"for (int  t = 0 ; t < (train_rows + block_size - 1) / block_size ; t++)\n"
"{\n"
"float result = 0.0f;\n"
"for (int i = 0 ; i < (query_cols + block_size -1) / block_size ; i++)\n"
"{\n"
"const int loadx = lidx + i * block_size;\n"
"s_query[lidy * block_size + lidx] = 0;\n"
"s_train[lidx * block_size + lidy] = 0;\n"
"if (loadx < query_cols)\n"
"{\n"
"s_query[lidy * block_size + lidx] = query[min(queryIdx, query_rows - 1) * (step / sizeof(float)) + loadx];\n"
"s_train[lidx * block_size + lidy] = train[min(t * block_size + lidy, train_rows - 1) * (step / sizeof(float)) + loadx];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"result += reduce_block(s_query, s_train, block_size, lidx, lidy, distType);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"const int trainIdx = t * block_size + lidx;\n"
"if (queryIdx < query_rows && trainIdx < train_rows )\n"
"{\n"
"if (result < myBestDistance1)\n"
"{\n"
"myBestDistance2 = myBestDistance1;\n"
"myBestTrainIdx2 = myBestTrainIdx1;\n"
"myBestDistance1 = result;\n"
"myBestTrainIdx1 = trainIdx;\n"
"}\n"
"else if (result < myBestDistance2)\n"
"{\n"
"myBestDistance2 = result;\n"
"myBestTrainIdx2 = trainIdx;\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"__local float *s_distance = (__local float *)sharebuffer;\n"
"__local int *s_trainIdx = (__local int *)(sharebuffer + block_size * block_size);\n"
"s_distance += lidy * block_size;\n"
"s_trainIdx += lidy * block_size;\n"
"s_distance[lidx] = myBestDistance1;\n"
"s_trainIdx[lidx] = myBestTrainIdx1;\n"
"float bestDistance1 = MAX_FLOAT;\n"
"float bestDistance2 = MAX_FLOAT;\n"
"int bestTrainIdx1 = -1;\n"
"int bestTrainIdx2 = -1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lidx == 0)\n"
"{\n"
"for (int i = 0 ; i < block_size ; i++)\n"
"{\n"
"float val = s_distance[i];\n"
"if (val < bestDistance1)\n"
"{\n"
"bestDistance2 = bestDistance1;\n"
"bestTrainIdx2 = bestTrainIdx1;\n"
"bestDistance1 = val;\n"
"bestTrainIdx1 = s_trainIdx[i];\n"
"}\n"
"else if (val < bestDistance2)\n"
"{\n"
"bestDistance2 = val;\n"
"bestTrainIdx2 = s_trainIdx[i];\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"s_distance[lidx] = myBestDistance2;\n"
"s_trainIdx[lidx] = myBestTrainIdx2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lidx == 0)\n"
"{\n"
"for (int i = 0 ; i < block_size ; i++)\n"
"{\n"
"float val = s_distance[i];\n"
"if (val < bestDistance2)\n"
"{\n"
"bestDistance2 = val;\n"
"bestTrainIdx2 = s_trainIdx[i];\n"
"}\n"
"}\n"
"}\n"
"myBestDistance1 = bestDistance1;\n"
"myBestDistance2 = bestDistance2;\n"
"myBestTrainIdx1 = bestTrainIdx1;\n"
"myBestTrainIdx2 = bestTrainIdx2;\n"
"if (queryIdx < query_rows && lidx == 0)\n"
"{\n"
"bestTrainIdx[queryIdx] = (int2)(myBestTrainIdx1, myBestTrainIdx2);\n"
"bestDistance[queryIdx] = (float2)(myBestDistance1, myBestDistance2);\n"
"}\n"
"}\n"
"kernel void BruteForceMatch_calcDistanceUnrolled_D5(\n"
"__global float *query,\n"
"__global float *train,\n"
"__global float *allDist,\n"
"__local float *sharebuffer,\n"
"int block_size,\n"
"int max_desc_len,\n"
"int query_rows,\n"
"int query_cols,\n"
"int train_rows,\n"
"int train_cols,\n"
"int step,\n"
"int distType)\n"
"{\n"
"}\n"
"kernel void BruteForceMatch_calcDistance_D5(\n"
"__global float *query,\n"
"__global float *train,\n"
"__global float *allDist,\n"
"__local float *sharebuffer,\n"
"int block_size,\n"
"int query_rows,\n"
"int query_cols,\n"
"int train_rows,\n"
"int train_cols,\n"
"int step,\n"
"int distType)\n"
"{\n"
"}\n"
"kernel void BruteForceMatch_findBestMatch_D5(\n"
"__global float *allDist,\n"
"__global int *bestTrainIdx,\n"
"__global float *bestDistance,\n"
"int k,\n"
"int block_size\n"
")\n"
"{\n"
"}\n"
;
const char* build_warps="__kernel\n"
"void buildWarpPlaneMaps\n"
"(\n"
"__global float * map_x,\n"
"__global float * map_y,\n"
"__constant float * KRT,\n"
"int tl_u,\n"
"int tl_v,\n"
"int cols,\n"
"int rows,\n"
"int step_x,\n"
"int step_y,\n"
"float scale\n"
")\n"
"{\n"
"int du = get_global_id(0);\n"
"int dv = get_global_id(1);\n"
"step_x /= sizeof(float);\n"
"step_y /= sizeof(float);\n"
"__constant float * ck_rinv = KRT;\n"
"__constant float * ct      = KRT + 9;\n"
"if (du < cols && dv < rows)\n"
"{\n"
"float u = tl_u + du;\n"
"float v = tl_v + dv;\n"
"float x, y;\n"
"float x_ = u / scale - ct[0];\n"
"float y_ = v / scale - ct[1];\n"
"float z;\n"
"x = ck_rinv[0] * x_ + ck_rinv[1] * y_ + ck_rinv[2] * (1 - ct[2]);\n"
"y = ck_rinv[3] * x_ + ck_rinv[4] * y_ + ck_rinv[5] * (1 - ct[2]);\n"
"z = ck_rinv[6] * x_ + ck_rinv[7] * y_ + ck_rinv[8] * (1 - ct[2]);\n"
"x /= z;\n"
"y /= z;\n"
"map_x[dv * step_x + du] = x;\n"
"map_y[dv * step_y + du] = y;\n"
"}\n"
"}\n"
"__kernel\n"
"void buildWarpCylindricalMaps\n"
"(\n"
"__global float * map_x,\n"
"__global float * map_y,\n"
"__constant float * ck_rinv,\n"
"int tl_u,\n"
"int tl_v,\n"
"int cols,\n"
"int rows,\n"
"int step_x,\n"
"int step_y,\n"
"float scale\n"
")\n"
"{\n"
"int du = get_global_id(0);\n"
"int dv = get_global_id(1);\n"
"step_x /= sizeof(float);\n"
"step_y /= sizeof(float);\n"
"if (du < cols && dv < rows)\n"
"{\n"
"float u = tl_u + du;\n"
"float v = tl_v + dv;\n"
"float x, y;\n"
"u /= scale;\n"
"float x_ = sin(u);\n"
"float y_ = v / scale;\n"
"float z_ = cos(u);\n"
"float z;\n"
"x = ck_rinv[0] * x_ + ck_rinv[1] * y_ + ck_rinv[2] * z_;\n"
"y = ck_rinv[3] * x_ + ck_rinv[4] * y_ + ck_rinv[5] * z_;\n"
"z = ck_rinv[6] * x_ + ck_rinv[7] * y_ + ck_rinv[8] * z_;\n"
"if (z > 0) { x /= z; y /= z; }\n"
"else x = y = -1;\n"
"map_x[dv * step_x + du] = x;\n"
"map_y[dv * step_y + du] = y;\n"
"}\n"
"}\n"
"__kernel\n"
"void buildWarpSphericalMaps\n"
"(\n"
"__global float * map_x,\n"
"__global float * map_y,\n"
"__constant float * ck_rinv,\n"
"int tl_u,\n"
"int tl_v,\n"
"int cols,\n"
"int rows,\n"
"int step_x,\n"
"int step_y,\n"
"float scale\n"
")\n"
"{\n"
"int du = get_global_id(0);\n"
"int dv = get_global_id(1);\n"
"step_x /= sizeof(float);\n"
"step_y /= sizeof(float);\n"
"if (du < cols && dv < rows)\n"
"{\n"
"float u = tl_u + du;\n"
"float v = tl_v + dv;\n"
"float x, y;\n"
"v /= scale;\n"
"u /= scale;\n"
"float sinv = sin(v);\n"
"float x_ = sinv * sin(u);\n"
"float y_ = - cos(v);\n"
"float z_ = sinv * cos(u);\n"
"float z;\n"
"x = ck_rinv[0] * x_ + ck_rinv[1] * y_ + ck_rinv[2] * z_;\n"
"y = ck_rinv[3] * x_ + ck_rinv[4] * y_ + ck_rinv[5] * z_;\n"
"z = ck_rinv[6] * x_ + ck_rinv[7] * y_ + ck_rinv[8] * z_;\n"
"if (z > 0) { x /= z; y /= z; }\n"
"else x = y = -1;\n"
"map_x[dv * step_x + du] = x;\n"
"map_y[dv * step_y + du] = y;\n"
"}\n"
"}\n"
"__kernel\n"
"void buildWarpAffineMaps\n"
"(\n"
"__global float * xmap,\n"
"__global float * ymap,\n"
"__constant float * c_warpMat,\n"
"int cols,\n"
"int rows,\n"
"int step_x,\n"
"int step_y\n"
")\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"step_x /= sizeof(float);\n"
"step_y /= sizeof(float);\n"
"if (x < cols && y < rows)\n"
"{\n"
"const float xcoo = c_warpMat[0] * x + c_warpMat[1] * y + c_warpMat[2];\n"
"const float ycoo = c_warpMat[3] * x + c_warpMat[4] * y + c_warpMat[5];\n"
"map_x[y * step_x + x] = xcoo;\n"
"map_y[y * step_y + x] = ycoo;\n"
"}\n"
"}\n"
"__kernel\n"
"void buildWarpPerspectiveMaps\n"
"(\n"
"__global float * xmap,\n"
"__global float * ymap,\n"
"__constant float * c_warpMat,\n"
"int cols,\n"
"int rows,\n"
"int step_x,\n"
"int step_y\n"
")\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"step_x /= sizeof(float);\n"
"step_y /= sizeof(float);\n"
"if (x < cols && y < rows)\n"
"{\n"
"const float coeff = 1.0f / (c_warpMat[6] * x + c_warpMat[7] * y + c_warpMat[8]);\n"
"const float xcoo = coeff * (c_warpMat[0] * x + c_warpMat[1] * y + c_warpMat[2]);\n"
"const float ycoo = coeff * (c_warpMat[3] * x + c_warpMat[4] * y + c_warpMat[5]);\n"
"map_x[y * step_x + x] = xcoo;\n"
"map_y[y * step_y + x] = ycoo;\n"
"}\n"
"}\n"
;
const char* convertC3C4="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void convertC3C4(__global const GENTYPE4 * restrict src, __global GENTYPE4 *dst, int cols, int rows,\n"
"int dstStep_in_piexl,int pixel_end)\n"
"{\n"
"int id = get_global_id(0);\n"
"int3 pixelid = (int3)(mul24(id,3),mad24(id,3,1),mad24(id,3,2));\n"
"pixelid = clamp(pixelid,0,pixel_end);\n"
"GENTYPE4 pixel0, pixel1, pixel2, outpix0,outpix1,outpix2,outpix3;\n"
"pixel0 = src[pixelid.x];\n"
"pixel1 = src[pixelid.y];\n"
"pixel2 = src[pixelid.z];\n"
"outpix0 = (GENTYPE4)(pixel0.x,pixel0.y,pixel0.z,0);\n"
"outpix1 = (GENTYPE4)(pixel0.w,pixel1.x,pixel1.y,0);\n"
"outpix2 = (GENTYPE4)(pixel1.z,pixel1.w,pixel2.x,0);\n"
"outpix3 = (GENTYPE4)(pixel2.y,pixel2.z,pixel2.w,0);\n"
"int4 outy = (id<<2)/cols;\n"
"int4 outx = (id<<2)%cols;\n"
"outx.y++;\n"
"outx.z+=2;\n"
"outx.w+=3;\n"
"outy = select(outy,outy+1,outx>=cols);\n"
"outx = select(outx,outx-cols,outx>=cols);\n"
"int4 addr = mad24(outy,(int4)dstStep_in_piexl,outx);\n"
"if(outx.w<cols && outy.w<rows)\n"
"{\n"
"dst[addr.x] = outpix0;\n"
"dst[addr.y] = outpix1;\n"
"dst[addr.z] = outpix2;\n"
"dst[addr.w] = outpix3;\n"
"}\n"
"else if(outx.z<cols && outy.z<rows)\n"
"{\n"
"dst[addr.x] = outpix0;\n"
"dst[addr.y] = outpix1;\n"
"dst[addr.z] = outpix2;\n"
"}\n"
"else if(outx.y<cols && outy.y<rows)\n"
"{\n"
"dst[addr.x] = outpix0;\n"
"dst[addr.y] = outpix1;\n"
"}\n"
"else if(outx.x<cols && outy.x<rows)\n"
"{\n"
"dst[addr.x] = outpix0;\n"
"}\n"
"}\n"
"__kernel void convertC4C3(__global const GENTYPE4 * restrict src, __global GENTYPE4 *dst, int cols, int rows,\n"
"int srcStep_in_pixel,int pixel_end)\n"
"{\n"
"int id = get_global_id(0)<<2;\n"
"int y = id / cols;\n"
"int x = id % cols;\n"
"int4 x4 = (int4)(x,x+1,x+2,x+3);\n"
"int4 y4 = select((int4)y,(int4)(y+1),x4>=(int4)cols);\n"
"y4=clamp(y4,(int4)0,(int4)(rows-1));\n"
"x4 = select(x4,x4-(int4)cols,x4>=(int4)cols);\n"
"int4 addr = mad24(y4,(int4)srcStep_in_pixel,x4);\n"
"GENTYPE4 pixel0,pixel1,pixel2,pixel3, outpixel1, outpixel2;\n"
"pixel0 = src[addr.x];\n"
"pixel1 = src[addr.y];\n"
"pixel2 = src[addr.z];\n"
"pixel3 = src[addr.w];\n"
"pixel0.w = pixel1.x;\n"
"outpixel1.x = pixel1.y;\n"
"outpixel1.y = pixel1.z;\n"
"outpixel1.z = pixel2.x;\n"
"outpixel1.w = pixel2.y;\n"
"outpixel2.x = pixel2.z;\n"
"outpixel2.y = pixel3.x;\n"
"outpixel2.z = pixel3.y;\n"
"outpixel2.w = pixel3.z;\n"
"int4 outaddr = mul24(id>>2 , 3);\n"
"outaddr.y++;\n"
"outaddr.z+=2;\n"
"if(outaddr.z <= pixel_end)\n"
"{\n"
"dst[outaddr.x] = pixel0;\n"
"dst[outaddr.y] = outpixel1;\n"
"dst[outaddr.z] = outpixel2;\n"
"}\n"
"else if(outaddr.y <= pixel_end)\n"
"{\n"
"dst[outaddr.x] = pixel0;\n"
"dst[outaddr.y] = outpixel1;\n"
"}\n"
"else if(outaddr.x <= pixel_end)\n"
"{\n"
"dst[outaddr.x] = pixel0;\n"
"}\n"
"}\n"
;
const char* cvt_color="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define DATA_TYPE UNDEFINED\n"
"#if defined (DEPTH_0)\n"
"#undef  DATA_TYPE\n"
"#define DATA_TYPE uchar\n"
"#define MAX_NUM  255\n"
"#define HALF_MAX 128\n"
"#define SAT_CAST(num) convert_uchar_sat(num)\n"
"#endif\n"
"#if defined (DEPTH_2)\n"
"#undef  DATA_TYPE\n"
"#define DATA_TYPE ushort\n"
"#define MAX_NUM  65535\n"
"#define HALF_MAX 32768\n"
"#define SAT_CAST(num) convert_ushort_sat(num)\n"
"#endif\n"
"#if defined (DEPTH_5)\n"
"#undef  DATA_TYPE\n"
"#define DATA_TYPE float\n"
"#define MAX_NUM  1.0f\n"
"#define HALF_MAX 0.5f\n"
"#define SAT_CAST(num) (num)\n"
"#endif\n"
"#define CV_DESCALE(x,n) (((x) + (1 << ((n)-1))) >> (n))\n"
"enum\n"
"{\n"
"yuv_shift  = 14,\n"
"xyz_shift  = 12,\n"
"R2Y        = 4899,\n"
"G2Y        = 9617,\n"
"B2Y        = 1868,\n"
"BLOCK_SIZE = 256\n"
"};\n"
"__kernel void RGB2Gray(int cols,int rows,int src_step,int dst_step,int channels,\n"
"int bidx, __global const DATA_TYPE* src, __global DATA_TYPE* dst)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"src_step /= sizeof(DATA_TYPE);\n"
"dst_step /= sizeof(DATA_TYPE);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = y * src_step + x * channels;\n"
"int dst_idx = y * dst_step + x;\n"
"#if defined (DEPTH_5)\n"
"dst[dst_idx] = src[src_idx + bidx] * 0.114f + src[src_idx + 1] * 0.587f + src[src_idx + (bidx^2)] * 0.299f;\n"
"#else\n"
"dst[dst_idx] = (DATA_TYPE)CV_DESCALE((src[src_idx + bidx] * B2Y + src[src_idx + 1] * G2Y + src[src_idx + (bidx^2)] * R2Y), yuv_shift);\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void Gray2RGB(int cols,int rows,int src_step,int dst_step,\n"
"__global const DATA_TYPE* src, __global DATA_TYPE* dst)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"src_step /= sizeof(DATA_TYPE);\n"
"dst_step /= sizeof(DATA_TYPE);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = y * src_step + x;\n"
"int dst_idx = y * dst_step + x * 4;\n"
"DATA_TYPE val = src[src_idx];\n"
"dst[dst_idx++] = val;\n"
"dst[dst_idx++] = val;\n"
"dst[dst_idx++] = val;\n"
"dst[dst_idx] = MAX_NUM;\n"
"}\n"
"}\n"
"__constant float c_RGB2YUVCoeffs_f[5]  = { 0.114f, 0.587f, 0.299f, 0.492f, 0.877f };\n"
"__constant int   c_RGB2YUVCoeffs_i[5]  = { B2Y, G2Y, R2Y, 8061, 14369 };\n"
"__kernel void RGB2YUV(int cols,int rows,int src_step,int dst_step,int channels,\n"
"int bidx, __global const DATA_TYPE* src, __global DATA_TYPE* dst)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"src_step /= sizeof(DATA_TYPE);\n"
"dst_step /= sizeof(DATA_TYPE);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = y * src_step + x * channels;\n"
"int dst_idx = y * dst_step + x * channels;\n"
"dst += dst_idx;\n"
"const DATA_TYPE rgb[] = {src[src_idx], src[src_idx + 1], src[src_idx + 2]};\n"
"#if defined (DEPTH_5)\n"
"__constant float * coeffs = c_RGB2YUVCoeffs_f;\n"
"const DATA_TYPE Y  = rgb[0] * coeffs[bidx] + rgb[1] * coeffs[1] + rgb[2] * coeffs[bidx^2];\n"
"const DATA_TYPE Cr = (rgb[bidx] - Y) * coeffs[3] + HALF_MAX;\n"
"const DATA_TYPE Cb = (rgb[bidx^2] - Y) * coeffs[4] + HALF_MAX;\n"
"#else\n"
"__constant int * coeffs = c_RGB2YUVCoeffs_i;\n"
"const int delta = HALF_MAX * (1 << yuv_shift);\n"
"const int Y =  CV_DESCALE(rgb[0] * coeffs[bidx] + rgb[1] * coeffs[1] + rgb[2] * coeffs[bidx^2], yuv_shift);\n"
"const int Cr = CV_DESCALE((rgb[bidx] - Y) * coeffs[3] + delta, yuv_shift);\n"
"const int Cb = CV_DESCALE((rgb[bidx^2] - Y) * coeffs[4] + delta, yuv_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST( Y );\n"
"dst[1] = SAT_CAST( Cr );\n"
"dst[2] = SAT_CAST( Cb );\n"
"}\n"
"}\n"
"__constant float c_YUV2RGBCoeffs_f[5] = { 2.032f, -0.395f, -0.581f, 1.140f };\n"
"__constant int   c_YUV2RGBCoeffs_i[5] = { 33292, -6472, -9519, 18678 };\n"
"__kernel void YUV2RGB(int cols,int rows,int src_step,int dst_step,int channels,\n"
"int bidx, __global const DATA_TYPE* src, __global DATA_TYPE* dst)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"src_step /= sizeof(DATA_TYPE);\n"
"dst_step /= sizeof(DATA_TYPE);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = y * src_step + x * channels;\n"
"int dst_idx = y * dst_step + x * channels;\n"
"dst += dst_idx;\n"
"const DATA_TYPE yuv[] = {src[src_idx], src[src_idx + 1], src[src_idx + 2]};\n"
"#if defined (DEPTH_5)\n"
"__constant float * coeffs = c_YUV2RGBCoeffs_f;\n"
"const float b = yuv[0] + (yuv[2] - HALF_MAX) * coeffs[3];\n"
"const float g = yuv[0] + (yuv[2] - HALF_MAX) * coeffs[2] + (yuv[1] - HALF_MAX) * coeffs[1];\n"
"const float r = yuv[0] + (yuv[1] - HALF_MAX) * coeffs[0];\n"
"#else\n"
"__constant int * coeffs = c_YUV2RGBCoeffs_i;\n"
"const int b = yuv[0] + CV_DESCALE((yuv[2] - HALF_MAX) * coeffs[3], yuv_shift);\n"
"const int g = yuv[0] + CV_DESCALE((yuv[2] - HALF_MAX) * coeffs[2] + (yuv[1] - HALF_MAX) * coeffs[1], yuv_shift);\n"
"const int r = yuv[0] + CV_DESCALE((yuv[1] - HALF_MAX) * coeffs[0], yuv_shift);\n"
"#endif\n"
"dst[bidx^2] = SAT_CAST( b );\n"
"dst[1]      = SAT_CAST( g );\n"
"dst[bidx]   = SAT_CAST( r );\n"
"}\n"
"}\n"
"__constant int ITUR_BT_601_CY = 1220542;\n"
"__constant int ITUR_BT_601_CUB = 2116026;\n"
"__constant int ITUR_BT_601_CUG = 409993;\n"
"__constant int ITUR_BT_601_CVG = 852492;\n"
"__constant int ITUR_BT_601_CVR = 1673527;\n"
"__constant int ITUR_BT_601_SHIFT = 20;\n"
"__kernel void YUV2RGBA_NV12(int cols,int rows,int src_step,int dst_step,\n"
"int bidx, int width, int height, __global const uchar* src, __global uchar* dst)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (y < height / 2 && x < width / 2 )\n"
"{\n"
"__global const uchar* ysrc = src + (y << 1)       * src_step + (x << 1);\n"
"__global const uchar* usrc = src + (height + y)   * src_step + (x << 1);\n"
"__global uchar*       dst1 = dst + (y << 1)       * dst_step + (x << 3);\n"
"__global uchar*       dst2 = dst + ((y << 1) + 1) * dst_step + (x << 3);\n"
"int Y1 = ysrc[0];\n"
"int Y2 = ysrc[1];\n"
"int Y3 = ysrc[src_step];\n"
"int Y4 = ysrc[src_step + 1];\n"
"int U  = usrc[0] - 128;\n"
"int V  = usrc[1] - 128;\n"
"int ruv = (1 << (ITUR_BT_601_SHIFT - 1)) + ITUR_BT_601_CVR * V;\n"
"int guv = (1 << (ITUR_BT_601_SHIFT - 1)) - ITUR_BT_601_CVG * V - ITUR_BT_601_CUG * U;\n"
"int buv = (1 << (ITUR_BT_601_SHIFT - 1)) + ITUR_BT_601_CUB * U;\n"
"Y1 = max(0, Y1 - 16) * ITUR_BT_601_CY;\n"
"dst1[2 - bidx]     = convert_uchar_sat((Y1 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst1[1]        = convert_uchar_sat((Y1 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst1[bidx] = convert_uchar_sat((Y1 + buv) >> ITUR_BT_601_SHIFT);\n"
"dst1[3]        = 255;\n"
"Y2 = max(0, Y2 - 16) * ITUR_BT_601_CY;\n"
"dst1[6 - bidx] = convert_uchar_sat((Y2 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst1[5]        = convert_uchar_sat((Y2 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst1[4 + bidx] = convert_uchar_sat((Y2 + buv) >> ITUR_BT_601_SHIFT);\n"
"dst1[7]        = 255;\n"
"Y3 = max(0, Y3 - 16) * ITUR_BT_601_CY;\n"
"dst2[2 - bidx]     = convert_uchar_sat((Y3 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst2[1]        = convert_uchar_sat((Y3 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst2[bidx] = convert_uchar_sat((Y3 + buv) >> ITUR_BT_601_SHIFT);\n"
"dst2[3]        = 255;\n"
"Y4 = max(0, Y4 - 16) * ITUR_BT_601_CY;\n"
"dst2[6 - bidx] = convert_uchar_sat((Y4 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst2[5]        = convert_uchar_sat((Y4 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst2[4 + bidx] = convert_uchar_sat((Y4 + buv) >> ITUR_BT_601_SHIFT);\n"
"dst2[7]        = 255;\n"
"}\n"
"}\n"
"__constant float c_RGB2YCrCbCoeffs_f[5] = {0.299f, 0.587f, 0.114f, 0.713f, 0.564f};\n"
"__constant int   c_RGB2YCrCbCoeffs_i[5] = {R2Y, G2Y, B2Y, 11682, 9241};\n"
"__kernel void RGB2YCrCb(int cols,int rows,int src_step,int dst_step,int channels,\n"
"int bidx, __global const DATA_TYPE* src, __global DATA_TYPE* dst)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"src_step /= sizeof(DATA_TYPE);\n"
"dst_step /= sizeof(DATA_TYPE);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int src_idx = y * src_step + x * channels;\n"
"int dst_idx = y * dst_step + x * channels;\n"
"dst += dst_idx;\n"
"const DATA_TYPE rgb[] = {src[src_idx], src[src_idx + 1], src[src_idx + 2]};\n"
"#if defined (DEPTH_5)\n"
"__constant float * coeffs = c_RGB2YCrCbCoeffs_f;\n"
"const DATA_TYPE Y  = rgb[0] * coeffs[bidx^2] + rgb[1] * coeffs[1] + rgb[2] * coeffs[bidx];\n"
"const DATA_TYPE Cr = (rgb[bidx^2] - Y) * coeffs[3] + HALF_MAX;\n"
"const DATA_TYPE Cb = (rgb[bidx] - Y) * coeffs[4] + HALF_MAX;\n"
"#else\n"
"__constant int * coeffs = c_RGB2YCrCbCoeffs_i;\n"
"const int delta = HALF_MAX * (1 << yuv_shift);\n"
"const int Y =  CV_DESCALE(rgb[0] * coeffs[bidx^2] + rgb[1] * coeffs[1] + rgb[2] * coeffs[bidx], yuv_shift);\n"
"const int Cr = CV_DESCALE((rgb[bidx^2] - Y) * coeffs[3] + delta, yuv_shift);\n"
"const int Cb = CV_DESCALE((rgb[bidx] - Y) * coeffs[4] + delta, yuv_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST( Y );\n"
"dst[1] = SAT_CAST( Cr );\n"
"dst[2] = SAT_CAST( Cb );\n"
"}\n"
"}\n"
;
const char* filter_sep_col="#define READ_TIMES_COL ((2*(RADIUSY+LSIZE1)-1)/LSIZE1)\n"
"#define RADIUS 1\n"
"#if CN ==1\n"
"#define ALIGN (((RADIUS)+3)>>2<<2)\n"
"#elif CN==2\n"
"#define ALIGN (((RADIUS)+1)>>1<<1)\n"
"#elif CN==3\n"
"#define ALIGN (((RADIUS)+3)>>2<<2)\n"
"#elif CN==4\n"
"#define ALIGN (RADIUS)\n"
"#define READ_TIMES_ROW ((2*(RADIUS+LSIZE0)-1)/LSIZE0)\n"
"#endif\n"
"#ifdef BORDER_CONSTANT\n"
"#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"#endif\n"
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i,l_edge,r_edge)  (i) < (l_edge) ? (l_edge) : (i)\n"
"#define ADDR_R(i,r_edge,addr)   (i) >= (r_edge) ? (r_edge)-1 : (addr)\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i,l_edge,r_edge)  (i) < (l_edge) ? -(i)-1 : (i)\n"
"#define ADDR_R(i,r_edge,addr) (i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr)\n"
"#endif\n"
"#ifdef BORDER_REFLECT_101\n"
"#define ADDR_L(i,l_edge,r_edge)  (i) < (l_edge) ? -(i) : (i)\n"
"#define ADDR_R(i,r_edge,addr) (i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr)\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i,l_edge,r_edge)  (i) < (l_edge) ? (i)+(r_edge) : (i)\n"
"#define ADDR_R(i,r_edge,addr)   (i) >= (r_edge) ?   (i)-(r_edge) : (addr)\n"
"#endif\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void col_filter\n"
"(__global const GENTYPE_SRC * restrict src,\n"
"__global GENTYPE_DST * dst,\n"
"const int dst_cols,\n"
"const int dst_rows,\n"
"const int src_whole_cols,\n"
"const int src_whole_rows,\n"
"const int src_step_in_pixel,\n"
"const int dst_step_in_pixel,\n"
"const int dst_offset_in_pixel,\n"
"__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSY+1)))))\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_addr = mad24(y,src_step_in_pixel,x);\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"int i;\n"
"GENTYPE_SRC sum;\n"
"GENTYPE_SRC temp[READ_TIMES_COL];\n"
"__local GENTYPE_SRC LDS_DAT[LSIZE1*READ_TIMES_COL][LSIZE0+1];\n"
"for(i = 0;i<READ_TIMES_COL;i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE1*src_step_in_pixel;\n"
"current_addr = current_addr < end_addr ? current_addr : 0;\n"
"temp[i] = src[current_addr];\n"
"}\n"
"for(i = 0;i<READ_TIMES_COL;i++)\n"
"{\n"
"LDS_DAT[l_y+i*LSIZE1][l_x] = temp[i];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = LDS_DAT[l_y+RADIUSY][l_x]*mat_kernel[RADIUSY];\n"
"for(i=1;i<=RADIUSY;i++)\n"
"{\n"
"temp[0]=LDS_DAT[l_y+RADIUSY-i][l_x];\n"
"temp[1]=LDS_DAT[l_y+RADIUSY+i][l_x];\n"
"sum += temp[0] * mat_kernel[RADIUSY-i]+temp[1] * mat_kernel[RADIUSY+i];\n"
"}\n"
"if((x<dst_cols) & (y<dst_rows))\n"
"{\n"
"start_addr = mad24(y,dst_step_in_pixel,x+dst_offset_in_pixel);\n"
"dst[start_addr] = convert_to_DST(sum);\n"
"}\n"
"}\n"
;
const char* filter_sep_row="#define READ_TIMES_ROW ((2*(RADIUSX+LSIZE0)-1)/LSIZE0)\n"
"#define READ_TIMES_COL ((2*(RADIUSY+LSIZE1)-1)/LSIZE1)\n"
"#define RADIUS 1\n"
"#if CN ==1\n"
"#define ALIGN (((RADIUS)+3)>>2<<2)\n"
"#elif CN==2\n"
"#define ALIGN (((RADIUS)+1)>>1<<1)\n"
"#elif CN==3\n"
"#define ALIGN (((RADIUS)+3)>>2<<2)\n"
"#elif CN==4\n"
"#define ALIGN (RADIUS)\n"
"#endif\n"
"#ifdef BORDER_CONSTANT\n"
"#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"#endif\n"
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i,l_edge,r_edge,addr)  (i) < (l_edge) ? (l_edge) : (addr)\n"
"#define ADDR_R(i,r_edge,addr)   (i) >= (r_edge) ? (r_edge)-1 : (addr)\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i,l_edge,r_edge,addr)  (i) < (l_edge) ? -(i)-1 : (addr)\n"
"#define ADDR_R(i,r_edge,addr) (i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr)\n"
"#endif\n"
"#ifdef BORDER_REFLECT_101\n"
"#define ADDR_L(i,l_edge,r_edge,addr)  (i) < (l_edge) ? -(i) : (addr)\n"
"#define ADDR_R(i,r_edge,addr) (i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr)\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i,l_edge,r_edge,addr)  (i) < (l_edge) ? (i)+(r_edge) : (addr)\n"
"#define ADDR_R(i,r_edge,addr)   (i) >= (r_edge) ?   (i)-(r_edge) : (addr)\n"
"#endif\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C1_D0\n"
"(__global const uchar * restrict src,\n"
"__global float * dst,\n"
"const int dst_cols,\n"
"const int dst_rows,\n"
"const int src_whole_cols,\n"
"const int src_whole_rows,\n"
"const int src_step_in_pixel,\n"
"const int src_offset_x,\n"
"const int src_offset_y,\n"
"const int dst_step_in_pixel,\n"
"const int radiusy,\n"
"__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSX+1)))))\n"
"{\n"
"int x = get_global_id(0)<<2;\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x+src_offset_x-RADIUSX & 0xfffffffc;\n"
"int offset = src_offset_x-RADIUSX & 3;\n"
"int start_y = y+src_offset_y-radiusy;\n"
"int start_addr = mad24(start_y,src_step_in_pixel,start_x);\n"
"int i;\n"
"float4 sum;\n"
"uchar4 temp[READ_TIMES_ROW];\n"
"__local uchar4 LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE0*4;\n"
"current_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\n"
"temp[i] = *(__global uchar4*)&src[current_addr];\n"
"}\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"temp[i].x= ELEM(start_x+i*LSIZE0*4,0,src_whole_cols,0,temp[i].x);\n"
"temp[i].y= ELEM(start_x+i*LSIZE0*4+1,0,src_whole_cols,0,temp[i].y);\n"
"temp[i].z= ELEM(start_x+i*LSIZE0*4+2,0,src_whole_cols,0,temp[i].z);\n"
"temp[i].w= ELEM(start_x+i*LSIZE0*4+3,0,src_whole_cols,0,temp[i].w);\n"
"temp[i]= ELEM(start_y,0,src_whole_rows,(uchar4)0,temp[i]);\n"
"}\n"
"#else\n"
"int not_all_in_range = (start_x<0) | (start_x + READ_TIMES_ROW*LSIZE0*4+4>src_whole_cols)| (start_y<0) | (start_y >= src_whole_rows);\n"
"int4 index[READ_TIMES_ROW];\n"
"int4 addr;\n"
"int s_y;\n"
"if(not_all_in_range)\n"
"{\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"index[i].x= ADDR_L(start_x+i*LSIZE0*4,0,src_whole_cols,start_x+i*LSIZE0*4);\n"
"index[i].x= ADDR_R(start_x+i*LSIZE0*4,src_whole_cols,index[i].x);\n"
"index[i].y= ADDR_L(start_x+i*LSIZE0*4+1,0,src_whole_cols,start_x+i*LSIZE0*4+1);\n"
"index[i].y= ADDR_R(start_x+i*LSIZE0*4+1,src_whole_cols,index[i].y);\n"
"index[i].z= ADDR_L(start_x+i*LSIZE0*4+2,0,src_whole_cols,start_x+i*LSIZE0*4+2);\n"
"index[i].z= ADDR_R(start_x+i*LSIZE0*4+2,src_whole_cols,index[i].z);\n"
"index[i].w= ADDR_L(start_x+i*LSIZE0*4+3,0,src_whole_cols,start_x+i*LSIZE0*4+3);\n"
"index[i].w= ADDR_R(start_x+i*LSIZE0*4+3,src_whole_cols,index[i].w);\n"
"}\n"
"s_y= ADDR_L(start_y,0,src_whole_rows,start_y);\n"
"s_y= ADDR_R(start_y,src_whole_rows,s_y);\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"addr = mad24((int4)s_y,(int4)src_step_in_pixel,index[i]);\n"
"temp[i].x = src[addr.x];\n"
"temp[i].y = src[addr.y];\n"
"temp[i].z = src[addr.z];\n"
"temp[i].w = src[addr.w];\n"
"}\n"
"}\n"
"else\n"
"{\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"temp[i] = *(__global uchar4*)&src[start_addr+i*LSIZE0*4];\n"
"}\n"
"}\n"
"#endif\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"LDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =convert_float4(vload4(0,(__local uchar*)&LDS_DAT[l_y][l_x]+RADIUSX+offset))*mat_kernel[RADIUSX];\n"
"for(i=1;i<=RADIUSX;i++)\n"
"{\n"
"temp[0]=vload4(0,(__local uchar*)&LDS_DAT[l_y][l_x]+RADIUSX+offset-i);\n"
"temp[1]=vload4(0,(__local uchar*)&LDS_DAT[l_y][l_x]+RADIUSX+offset+i);\n"
"sum += convert_float4(temp[0])*mat_kernel[RADIUSX-i]+convert_float4(temp[1])*mat_kernel[RADIUSX+i];\n"
"}\n"
"start_addr = mad24(y,dst_step_in_pixel,x);\n"
"if((x+3<dst_cols) & (y<dst_rows))\n"
"{\n"
"*(__global float4*)&dst[start_addr] = sum;\n"
"}\n"
"else if((x+2<dst_cols) & (y<dst_rows))\n"
"{\n"
"dst[start_addr] = sum.x;\n"
"dst[start_addr+1] = sum.y;\n"
"dst[start_addr+2] = sum.z;\n"
"}\n"
"else if((x+1<dst_cols) & (y<dst_rows))\n"
"{\n"
"dst[start_addr] = sum.x;\n"
"dst[start_addr+1] = sum.y;\n"
"}\n"
"else if((x<dst_cols) & (y<dst_rows))\n"
"{\n"
"dst[start_addr] = sum.x;\n"
"}\n"
"}\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C4_D0\n"
"(__global const uchar4 * restrict src,\n"
"__global float4 * dst,\n"
"const int dst_cols,\n"
"const int dst_rows,\n"
"const int src_whole_cols,\n"
"const int src_whole_rows,\n"
"const int src_step_in_pixel,\n"
"const int src_offset_x,\n"
"const int src_offset_y,\n"
"const int dst_step_in_pixel,\n"
"const int radiusy,\n"
"__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSX+1)))))\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x+src_offset_x-RADIUSX;\n"
"int start_y = y+src_offset_y-radiusy;\n"
"int start_addr = mad24(start_y,src_step_in_pixel,start_x);\n"
"int i;\n"
"float4 sum;\n"
"uchar4 temp[READ_TIMES_ROW];\n"
"__local uchar4 LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE0;\n"
"current_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\n"
"temp[i] = src[current_addr];\n"
"}\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"temp[i]= ELEM(start_x+i*LSIZE0,0,src_whole_cols,(uchar4)0,temp[i]);\n"
"temp[i]= ELEM(start_y,0,src_whole_rows,(uchar4)0,temp[i]);\n"
"}\n"
"#else\n"
"int index[READ_TIMES_ROW];\n"
"int s_x,s_y;\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"s_x= ADDR_L(start_x+i*LSIZE0,0,src_whole_cols,start_x+i*LSIZE0);\n"
"s_x= ADDR_R(start_x+i*LSIZE0,src_whole_cols,s_x);\n"
"s_y= ADDR_L(start_y,0,src_whole_rows,start_y);\n"
"s_y= ADDR_R(start_y,src_whole_rows,s_y);\n"
"index[i]=mad24(s_y,src_step_in_pixel,s_x);\n"
"}\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"temp[i] = src[index[i]];\n"
"}\n"
"#endif\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"LDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =convert_float4(LDS_DAT[l_y][l_x+RADIUSX])*mat_kernel[RADIUSX];\n"
"for(i=1;i<=RADIUSX;i++)\n"
"{\n"
"temp[0]=LDS_DAT[l_y][l_x+RADIUSX-i];\n"
"temp[1]=LDS_DAT[l_y][l_x+RADIUSX+i];\n"
"sum += convert_float4(temp[0])*mat_kernel[RADIUSX-i]+convert_float4(temp[1])*mat_kernel[RADIUSX+i];\n"
"}\n"
"if((x<dst_cols) & (y<dst_rows))\n"
"{\n"
"start_addr = mad24(y,dst_step_in_pixel,x);\n"
"dst[start_addr] = sum;\n"
"}\n"
"}\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C1_D5\n"
"(__global const float * restrict src,\n"
"__global float * dst,\n"
"const int dst_cols,\n"
"const int dst_rows,\n"
"const int src_whole_cols,\n"
"const int src_whole_rows,\n"
"const int src_step_in_pixel,\n"
"const int src_offset_x,\n"
"const int src_offset_y,\n"
"const int dst_step_in_pixel,\n"
"const int radiusy,\n"
"__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSX+1)))))\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x+src_offset_x-RADIUSX;\n"
"int start_y = y+src_offset_y-radiusy;\n"
"int start_addr = mad24(start_y,src_step_in_pixel,start_x);\n"
"int i;\n"
"float sum;\n"
"float temp[READ_TIMES_ROW];\n"
"__local float LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE0;\n"
"current_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\n"
"temp[i] = src[current_addr];\n"
"}\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"temp[i]= ELEM(start_x+i*LSIZE0,0,src_whole_cols,0,temp[i]);\n"
"temp[i]= ELEM(start_y,0,src_whole_rows,0,temp[i]);\n"
"}\n"
"#else\n"
"int index[READ_TIMES_ROW];\n"
"int s_x,s_y;\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"s_x= ADDR_L(start_x+i*LSIZE0,0,src_whole_cols,start_x+i*LSIZE0);\n"
"s_x= ADDR_R(start_x+i*LSIZE0,src_whole_cols,s_x);\n"
"s_y= ADDR_L(start_y,0,src_whole_rows,start_y);\n"
"s_y= ADDR_R(start_y,src_whole_rows,s_y);\n"
"index[i]=mad24(s_y,src_step_in_pixel,s_x);\n"
"}\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"temp[i] = src[index[i]];\n"
"}\n"
"#endif\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"LDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =LDS_DAT[l_y][l_x+RADIUSX]*mat_kernel[RADIUSX];\n"
"for(i=1;i<=RADIUSX;i++)\n"
"{\n"
"temp[0]=LDS_DAT[l_y][l_x+RADIUSX-i];\n"
"temp[1]=LDS_DAT[l_y][l_x+RADIUSX+i];\n"
"sum += temp[0]*mat_kernel[RADIUSX-i]+temp[1]*mat_kernel[RADIUSX+i];\n"
"}\n"
"if((x<dst_cols) & (y<dst_rows))\n"
"{\n"
"start_addr = mad24(y,dst_step_in_pixel,x);\n"
"dst[start_addr] = sum;\n"
"}\n"
"}\n"
"__kernel __attribute__((reqd_work_group_size(LSIZE0,LSIZE1,1))) void row_filter_C4_D5\n"
"(__global const float4 * restrict src,\n"
"__global float4 * dst,\n"
"const int dst_cols,\n"
"const int dst_rows,\n"
"const int src_whole_cols,\n"
"const int src_whole_rows,\n"
"const int src_step_in_pixel,\n"
"const int src_offset_x,\n"
"const int src_offset_y,\n"
"const int dst_step_in_pixel,\n"
"const int radiusy,\n"
"__constant float * mat_kernel __attribute__((max_constant_size(4*(2*RADIUSX+1)))))\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x+src_offset_x-RADIUSX;\n"
"int start_y = y+src_offset_y-radiusy;\n"
"int start_addr = mad24(start_y,src_step_in_pixel,start_x);\n"
"int i;\n"
"float4 sum;\n"
"float4 temp[READ_TIMES_ROW];\n"
"__local float4 LDS_DAT[LSIZE1][READ_TIMES_ROW*LSIZE0+1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"int current_addr = start_addr+i*LSIZE0;\n"
"current_addr = ((current_addr < end_addr) && (current_addr > 0)) ? current_addr : 0;\n"
"temp[i] = src[current_addr];\n"
"}\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"temp[i]= ELEM(start_x+i*LSIZE0,0,src_whole_cols,0,temp[i]);\n"
"temp[i]= ELEM(start_y,0,src_whole_rows,0,temp[i]);\n"
"}\n"
"#else\n"
"int index[READ_TIMES_ROW];\n"
"int s_x,s_y;\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"s_x= ADDR_L(start_x+i*LSIZE0,0,src_whole_cols,start_x+i*LSIZE0);\n"
"s_x= ADDR_R(start_x+i*LSIZE0,src_whole_cols,s_x);\n"
"s_y= ADDR_L(start_y,0,src_whole_rows,start_y);\n"
"s_y= ADDR_R(start_y,src_whole_rows,s_y);\n"
"index[i]=mad24(s_y,src_step_in_pixel,s_x);\n"
"}\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"temp[i] = src[index[i]];\n"
"}\n"
"#endif\n"
"for(i = 0;i<READ_TIMES_ROW;i++)\n"
"{\n"
"LDS_DAT[l_y][l_x+i*LSIZE0]=temp[i];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =LDS_DAT[l_y][l_x+RADIUSX]*mat_kernel[RADIUSX];\n"
"for(i=1;i<=RADIUSX;i++)\n"
"{\n"
"temp[0]=LDS_DAT[l_y][l_x+RADIUSX-i];\n"
"temp[1]=LDS_DAT[l_y][l_x+RADIUSX+i];\n"
"sum += temp[0]*mat_kernel[RADIUSX-i]+temp[1]*mat_kernel[RADIUSX+i];\n"
"}\n"
"if((x<dst_cols) & (y<dst_rows))\n"
"{\n"
"start_addr = mad24(y,dst_step_in_pixel,x);\n"
"dst[start_addr] = sum;\n"
"}\n"
"}\n"
;
const char* filtering_boxFilter="#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (t_edge)   :(i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (b_edge)-1 :(addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)-1 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-1+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT_101\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)                 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-2+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (i)+(b_edge) : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (i)-(b_edge) : (addr))\n"
"#endif\n"
"#define THREADS 256\n"
"#define ELEM(i, l_edge, r_edge, elem1, elem2) (i) >= (l_edge) && (i) < (r_edge) ? (elem1) : (elem2)\n"
"__kernel void boxFilter_C1_D0(__global const uchar * restrict src, __global uchar *dst, float alpha,\n"
"int src_offset, int src_whole_rows, int src_whole_cols, int src_step,\n"
"int dst_offset, int dst_rows, int dst_cols, int dst_step\n"
")\n"
"{\n"
"int col = get_local_id(0);\n"
"const int gX = get_group_id(0);\n"
"const int gY = get_group_id(1);\n"
"int src_x_off = src_offset % src_step;\n"
"int src_y_off = src_offset / src_step;\n"
"int dst_x_off = dst_offset % dst_step;\n"
"int dst_y_off = dst_offset / dst_step;\n"
"int head_off = dst_x_off%4;\n"
"int startX = ((gX * (THREADS-ksX+1)-anX) * 4) - head_off + src_x_off;\n"
"int startY = (gY << 1) - anY + src_y_off;\n"
"int dst_startX = (gX * (THREADS-ksX+1) * 4) - head_off + dst_x_off;\n"
"int dst_startY = (gY << 1) + dst_y_off;\n"
"uint4 data[ksY+1];\n"
"__local uint4 temp[(THREADS<<1)];\n"
"#ifdef BORDER_CONSTANT\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"if(startY+i >=0 && startY+i < src_whole_rows && startX+col*4 >=0 && startX+col*4+3<src_whole_cols)\n"
"data[i] = convert_uint4(vload4(col,(__global uchar*)(src+(startY+i)*src_step + startX)));\n"
"else\n"
"{\n"
"data[i]=0;\n"
"int con = startY+i >=0 && startY+i < src_whole_rows && startX+col*4 >=0 && startX+col*4<src_whole_cols;\n"
"if(con)data[i].s0 = *(src+(startY+i)*src_step + startX + col*4);\n"
"con = startY+i >=0 && startY+i < src_whole_rows && startX+col*4+1 >=0 && startX+col*4+1<src_whole_cols;\n"
"if(con)data[i].s1 = *(src+(startY+i)*src_step + startX + col*4+1) ;\n"
"con = startY+i >=0 && startY+i < src_whole_rows && startX+col*4+2 >=0 && startX+col*4+2<src_whole_cols;\n"
"if(con)data[i].s2 = *(src+(startY+i)*src_step + startX + col*4+2);\n"
"con = startY+i >=0 && startY+i < src_whole_rows && startX+col*4+3 >=0 && startX+col*4+3<src_whole_cols;\n"
"if(con)data[i].s3 = *(src+(startY+i)*src_step + startX + col*4+3);\n"
"}\n"
"}\n"
"#else\n"
"int not_all_in_range;\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"not_all_in_range = (startX+col*4<0) | (startX+col*4+3>src_whole_cols-1)\n"
"| (startY+i<0) | (startY+i>src_whole_rows-1);\n"
"if(not_all_in_range)\n"
"{\n"
"int selected_row;\n"
"int4 selected_col;\n"
"selected_row = ADDR_H(startY+i, 0, src_whole_rows);\n"
"selected_row = ADDR_B(startY+i, src_whole_rows, selected_row);\n"
"selected_col.x = ADDR_L(startX+col*4, 0, src_whole_cols);\n"
"selected_col.x = ADDR_R(startX+col*4, src_whole_cols, selected_col.x);\n"
"selected_col.y = ADDR_L(startX+col*4+1, 0, src_whole_cols);\n"
"selected_col.y = ADDR_R(startX+col*4+1, src_whole_cols, selected_col.y);\n"
"selected_col.z = ADDR_L(startX+col*4+2, 0, src_whole_cols);\n"
"selected_col.z = ADDR_R(startX+col*4+2, src_whole_cols, selected_col.z);\n"
"selected_col.w = ADDR_L(startX+col*4+3, 0, src_whole_cols);\n"
"selected_col.w = ADDR_R(startX+col*4+3, src_whole_cols, selected_col.w);\n"
"data[i].x = *(src + selected_row * src_step + selected_col.x);\n"
"data[i].y = *(src + selected_row * src_step + selected_col.y);\n"
"data[i].z = *(src + selected_row * src_step + selected_col.z);\n"
"data[i].w = *(src + selected_row * src_step + selected_col.w);\n"
"}\n"
"else\n"
"{\n"
"data[i] =  convert_uint4(vload4(col,(__global uchar*)(src+(startY+i)*src_step + startX)));\n"
"}\n"
"}\n"
"#endif\n"
"uint4 sum0 = 0, sum1 = 0, sum2 = 0;\n"
"for(int i=1; i < ksY; i++)\n"
"{\n"
"sum0 += (data[i]);\n"
"}\n"
"sum1 = sum0 + (data[0]);\n"
"sum2 = sum0 + (data[ksY]);\n"
"temp[col] = sum1;\n"
"temp[col+THREADS] = sum2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(col >= anX && col < (THREADS-ksX+anX+1))\n"
"{\n"
"int posX = dst_startX - dst_x_off + (col-anX)*4;\n"
"int posY = (gY << 1);\n"
"uint4 tmp_sum1=0, tmp_sum2=0;\n"
"for(int i=-anX; i<=anX; i++)\n"
"{\n"
"tmp_sum1 += vload4(col, (__local uint*)temp+i);\n"
"}\n"
"for(int i=-anX; i<=anX; i++)\n"
"{\n"
"tmp_sum2 += vload4(col, (__local uint*)(temp+THREADS)+i);\n"
"}\n"
"if(posY < dst_rows && posX < dst_cols)\n"
"{\n"
"if(posX >= 0 && posX < dst_cols)\n"
"*(dst+dst_startY * dst_step + dst_startX + (col-anX)*4) = tmp_sum1.x/alpha;\n"
"if(posX+1 >= 0 && posX+1 < dst_cols)\n"
"*(dst+dst_startY * dst_step + dst_startX+1 + (col-anX)*4) = tmp_sum1.y/alpha;\n"
"if(posX+2 >= 0 && posX+2 < dst_cols)\n"
"*(dst+dst_startY * dst_step + dst_startX+2 + (col-anX)*4) = tmp_sum1.z/alpha;\n"
"if(posX+3 >= 0 && posX+3 < dst_cols)\n"
"*(dst+dst_startY * dst_step + dst_startX+3 + (col-anX)*4) = tmp_sum1.w/alpha;\n"
"}\n"
"if(posY+1 < dst_rows && posX < dst_cols)\n"
"{\n"
"dst_startY+=1;\n"
"if(posX >= 0 && posX < dst_cols)\n"
"*(dst+dst_startY * dst_step + dst_startX + (col-anX)*4) = tmp_sum2.x/alpha;\n"
"if(posX+1 >= 0 && posX+1 < dst_cols)\n"
"*(dst+dst_startY * dst_step + dst_startX+1 + (col-anX)*4) = tmp_sum2.y/alpha;\n"
"if(posX+2 >= 0 && posX+2 < dst_cols)\n"
"*(dst+dst_startY * dst_step + dst_startX+2 + (col-anX)*4) = tmp_sum2.z/alpha;\n"
"if(posX+3 >= 0 && posX+3 < dst_cols)\n"
"*(dst+dst_startY * dst_step + dst_startX+3 + (col-anX)*4) = tmp_sum2.w/alpha;\n"
"}\n"
"}\n"
"}\n"
"__kernel void boxFilter_C4_D0(__global const uchar4 * restrict src, __global uchar4 *dst, float alpha,\n"
"int src_offset, int src_whole_rows, int src_whole_cols, int src_step,\n"
"int dst_offset, int dst_rows, int dst_cols, int dst_step\n"
")\n"
"{\n"
"int col = get_local_id(0);\n"
"const int gX = get_group_id(0);\n"
"const int gY = get_group_id(1);\n"
"int src_x_off = (src_offset % src_step) >> 2;\n"
"int src_y_off = src_offset / src_step;\n"
"int dst_x_off = (dst_offset % dst_step) >> 2;\n"
"int dst_y_off = dst_offset / dst_step;\n"
"int startX = gX * (THREADS-ksX+1) - anX + src_x_off;\n"
"int startY = (gY << 1) - anY + src_y_off;\n"
"int dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\n"
"int dst_startY = (gY << 1) + dst_y_off;\n"
"int end_addr = src_whole_cols-4;\n"
"uint4 data[ksY+1];\n"
"__local uint4 temp[2][THREADS];\n"
"#ifdef BORDER_CONSTANT\n"
"bool con;\n"
"uint4 ss;\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"con = startX+col >= 0 && startX+col < src_whole_cols && startY+i >= 0 && startY+i < src_whole_rows;\n"
"int cur_col = clamp(startX + col, 0, src_whole_cols);\n"
"if(con)\n"
"ss = convert_uint4(src[(startY+i)*(src_step>>2) + cur_col]);\n"
"data[i] = con ? ss : 0;\n"
"}\n"
"#else\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"int selected_row;\n"
"int selected_col;\n"
"selected_row = ADDR_H(startY+i, 0, src_whole_rows);\n"
"selected_row = ADDR_B(startY+i, src_whole_rows, selected_row);\n"
"selected_col = ADDR_L(startX+col, 0, src_whole_cols);\n"
"selected_col = ADDR_R(startX+col, src_whole_cols, selected_col);\n"
"data[i] = convert_uint4(src[selected_row * (src_step>>2) + selected_col]);\n"
"}\n"
"#endif\n"
"uint4 sum0 = 0, sum1 = 0, sum2 = 0;\n"
"for(int i=1; i < ksY; i++)\n"
"{\n"
"sum0 += (data[i]);\n"
"}\n"
"sum1 = sum0 + (data[0]);\n"
"sum2 = sum0 + (data[ksY]);\n"
"temp[0][col] = sum1;\n"
"temp[1][col] = sum2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(col < (THREADS-(ksX-1)))\n"
"{\n"
"col += anX;\n"
"int posX = dst_startX - dst_x_off + col - anX;\n"
"int posY = (gY << 1);\n"
"uint4 tmp_sum[2]={(uint4)(0,0,0,0),(uint4)(0,0,0,0)};\n"
"for(int k=0; k<2; k++)\n"
"for(int i=-anX; i<=anX; i++)\n"
"{\n"
"tmp_sum[k] += temp[k][col+i];\n"
"}\n"
"for(int i=0; i<2; i++)\n"
"{\n"
"if(posX >= 0 && posX < dst_cols && (posY+i) >= 0 && (posY+i) < dst_rows)\n"
"dst[(dst_startY+i) * (dst_step>>2)+ dst_startX + col - anX] = convert_uchar4(convert_float4(tmp_sum[i])/alpha);\n"
"}\n"
"}\n"
"}\n"
"__kernel void boxFilter_C1_D5(__global const float *restrict src, __global float *dst, float alpha,\n"
"int src_offset, int src_whole_rows, int src_whole_cols, int src_step,\n"
"int dst_offset, int dst_rows, int dst_cols, int dst_step\n"
")\n"
"{\n"
"int col = get_local_id(0);\n"
"const int gX = get_group_id(0);\n"
"const int gY = get_group_id(1);\n"
"int src_x_off = (src_offset % src_step) >> 2;\n"
"int src_y_off = src_offset / src_step;\n"
"int dst_x_off = (dst_offset % dst_step) >> 2;\n"
"int dst_y_off = dst_offset / dst_step;\n"
"int startX = gX * (THREADS-ksX+1) - anX + src_x_off;\n"
"int startY = (gY << 1) - anY + src_y_off;\n"
"int dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\n"
"int dst_startY = (gY << 1) + dst_y_off;\n"
"int end_addr = (src_whole_rows-1)*(src_step>>2) + src_whole_cols-4;\n"
"float data[ksY+1];\n"
"__local float temp[2][THREADS];\n"
"#ifdef BORDER_CONSTANT\n"
"bool con;\n"
"float ss;\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"con = startX+col >= 0 && startX+col < src_whole_cols && startY+i >= 0 && startY+i < src_whole_rows;\n"
"int cur_col = clamp(startX + col, 0, src_whole_cols);\n"
"ss = (startY+i)<src_whole_rows&&(startY+i)>=0&&cur_col>=0&&cur_col<src_whole_cols?src[(startY+i)*(src_step>>2) + cur_col]:0;\n"
"data[i] = con ? ss : 0.f;\n"
"}\n"
"#else\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"int selected_row;\n"
"int selected_col;\n"
"selected_row = ADDR_H(startY+i, 0, src_whole_rows);\n"
"selected_row = ADDR_B(startY+i, src_whole_rows, selected_row);\n"
"selected_col = ADDR_L(startX+col, 0, src_whole_cols);\n"
"selected_col = ADDR_R(startX+col, src_whole_cols, selected_col);\n"
"data[i] = src[selected_row * (src_step>>2) + selected_col];\n"
"}\n"
"#endif\n"
"float sum0 = 0.0, sum1 = 0.0, sum2 = 0.0;\n"
"for(int i=1; i < ksY; i++)\n"
"{\n"
"sum0 += (data[i]);\n"
"}\n"
"sum1 = sum0 + (data[0]);\n"
"sum2 = sum0 + (data[ksY]);\n"
"temp[0][col] = sum1;\n"
"temp[1][col] = sum2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(col < (THREADS-(ksX-1)))\n"
"{\n"
"col += anX;\n"
"int posX = dst_startX - dst_x_off + col - anX;\n"
"int posY = (gY << 1);\n"
"float tmp_sum[2]={0.0, 0.0};\n"
"for(int k=0; k<2; k++)\n"
"for(int i=-anX; i<=anX; i++)\n"
"{\n"
"tmp_sum[k] += temp[k][col+i];\n"
"}\n"
"for(int i=0; i<2; i++)\n"
"{\n"
"if(posX >= 0 && posX < dst_cols && (posY+i) >= 0 && (posY+i) < dst_rows)\n"
"dst[(dst_startY+i) * (dst_step>>2)+ dst_startX + col - anX] = tmp_sum[i]/alpha;\n"
"}\n"
"}\n"
"}\n"
"__kernel void boxFilter_C4_D5(__global const float4 *restrict src, __global float4 *dst, float alpha,\n"
"int src_offset, int src_whole_rows, int src_whole_cols, int src_step,\n"
"int dst_offset, int dst_rows, int dst_cols, int dst_step\n"
")\n"
"{\n"
"int col = get_local_id(0);\n"
"const int gX = get_group_id(0);\n"
"const int gY = get_group_id(1);\n"
"int src_x_off = (src_offset % src_step) >> 4;\n"
"int src_y_off = src_offset / src_step;\n"
"int dst_x_off = (dst_offset % dst_step) >> 4;\n"
"int dst_y_off = dst_offset / dst_step;\n"
"int startX = gX * (THREADS-ksX+1) - anX + src_x_off;\n"
"int startY = (gY << 1) - anY + src_y_off;\n"
"int dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\n"
"int dst_startY = (gY << 1) + dst_y_off;\n"
"int end_addr = (src_whole_rows-1)*(src_step>>4) + src_whole_cols-16;\n"
"float4 data[ksY+1];\n"
"__local float4 temp[2][THREADS];\n"
"#ifdef BORDER_CONSTANT\n"
"bool con;\n"
"float4 ss;\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"con = startX+col >= 0 && startX+col < src_whole_cols && startY+i >= 0 && startY+i < src_whole_rows;\n"
"int cur_col = clamp(startX + col, 0, src_whole_cols);\n"
"ss = (startY+i)<src_whole_rows&&(startY+i)>=0&&cur_col>=0&&cur_col<src_whole_cols?src[(startY+i)*(src_step>>4) + cur_col]:0;\n"
"data[i] = con ? ss : (float4)(0.0,0.0,0.0,0.0);\n"
"}\n"
"#else\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"int selected_row;\n"
"int selected_col;\n"
"selected_row = ADDR_H(startY+i, 0, src_whole_rows);\n"
"selected_row = ADDR_B(startY+i, src_whole_rows, selected_row);\n"
"selected_col = ADDR_L(startX+col, 0, src_whole_cols);\n"
"selected_col = ADDR_R(startX+col, src_whole_cols, selected_col);\n"
"data[i] = src[selected_row * (src_step>>4) + selected_col];\n"
"}\n"
"#endif\n"
"float4 sum0 = 0.0, sum1 = 0.0, sum2 = 0.0;\n"
"for(int i=1; i < ksY; i++)\n"
"{\n"
"sum0 += (data[i]);\n"
"}\n"
"sum1 = sum0 + (data[0]);\n"
"sum2 = sum0 + (data[ksY]);\n"
"temp[0][col] = sum1;\n"
"temp[1][col] = sum2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(col < (THREADS-(ksX-1)))\n"
"{\n"
"col += anX;\n"
"int posX = dst_startX - dst_x_off + col - anX;\n"
"int posY = (gY << 1);\n"
"float4 tmp_sum[2]={(float4)(0.0,0.0,0.0,0.0), (float4)(0.0,0.0,0.0,0.0)};\n"
"for(int k=0; k<2; k++)\n"
"for(int i=-anX; i<=anX; i++)\n"
"{\n"
"tmp_sum[k] += temp[k][col+i];\n"
"}\n"
"for(int i=0; i<2; i++)\n"
"{\n"
"if(posX >= 0 && posX < dst_cols && (posY+i) >= 0 && (posY+i) < dst_rows)\n"
"dst[(dst_startY+i) * (dst_step>>4)+ dst_startX + col - anX] = tmp_sum[i]/alpha;\n"
"}\n"
"}\n"
"}\n"
;
const char* filtering_laplacian="#define BORDER_REFLECT_101\n"
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (t_edge)   :(i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (b_edge)-1 :(addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)-1 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-1+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT_101\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)                 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-2+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (i)+(b_edge) : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (i)-(b_edge) : (addr))\n"
"#endif\n"
"#define ANCHOR                  3\n"
"#define ANX                     1\n"
"#define ANY                     1\n"
"#define ROWS_PER_GROUP          4\n"
"#define ROWS_PER_GROUP_BITS     2\n"
"#define ROWS_FETCH              (ROWS_PER_GROUP + ANY + ANY)\n"
"#define THREADS_PER_ROW         64\n"
"#define THREADS_PER_ROW_BIT     6\n"
"#define ELEMENTS_PER_THREAD     4\n"
"#define ELEMENTS_PER_THREAD_BIT 2\n"
"#define LOCAL_MEM_STEP          260\n"
"__kernel void filter2D_C1_D0(__global uchar *src, int src_step, int src_offset_x, int src_offset_y,\n"
"__global uchar *dst, int dst_step, int dst_offset_x, int dst_offset_y,\n"
"__constant int *mat_kernel __attribute__((max_constant_size (16384))),\n"
"int cols,int rows, int operate_cols, int wholecols, int wholerows)\n"
"{\n"
"int gX = get_global_id(0);\n"
"int gY = get_global_id(1);\n"
"int lX = get_local_id(0);\n"
"int groupX_size = get_local_size(0);\n"
"int groupX_id   = get_group_id(0);\n"
"#define dst_align (dst_offset_x & 3)\n"
"int cols_start_index_group = src_offset_x - dst_align + groupX_size * groupX_id - ANX;\n"
"int rows_start_index       = src_offset_y + (gY << ROWS_PER_GROUP_BITS) - ANY;\n"
"__local uchar local_data[LOCAL_MEM_STEP * ROWS_FETCH];\n"
"if((gY << 2) < rows)\n"
"{\n"
"for(int i = 0; i < ROWS_FETCH; ++i)\n"
"{\n"
"if((rows_start_index - src_offset_y) + i < rows + ANY)\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"int selected_row  = rows_start_index + i;\n"
"int selected_cols = cols_start_index_group + lX;\n"
"uchar data = *(src + selected_row * src_step + selected_cols);\n"
"int con = selected_row >=0 && selected_row < wholerows && selected_cols >=0 && selected_cols < wholecols;\n"
"data = con ? data : 0;\n"
"local_data[i * LOCAL_MEM_STEP + lX ] =data;\n"
"if(lX < (ANX << 1))\n"
"{\n"
"selected_cols = cols_start_index_group + lX + groupX_size;\n"
"data = *(src + selected_row * src_step + selected_cols);\n"
"con = selected_row >=0 && selected_row < wholerows && selected_cols >=0 && selected_cols < wholecols;\n"
"data = con ? data : 0;\n"
"local_data[i * LOCAL_MEM_STEP + lX + groupX_size] =data;\n"
"}\n"
"#else\n"
"int selected_row = ADDR_H(rows_start_index + i,  0, wholerows);\n"
"selected_row     = ADDR_B(rows_start_index + i, wholerows, selected_row);\n"
"int selected_cols = ADDR_L(cols_start_index_group + lX, 0, wholecols);\n"
"selected_cols     = ADDR_R(cols_start_index_group + lX, wholecols, selected_cols);\n"
"uchar data = *(src + selected_row * src_step + selected_cols);\n"
"local_data[i * LOCAL_MEM_STEP + lX ] =data;\n"
"if(lX < (ANX << 1))\n"
"{\n"
"selected_cols = cols_start_index_group + lX + groupX_size;\n"
"selected_cols = ADDR_R(selected_cols, wholecols, selected_cols);\n"
"data = *(src + selected_row * src_step + selected_cols);\n"
"local_data[i * LOCAL_MEM_STEP + lX + groupX_size] =data;\n"
"}\n"
"#endif\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int process_col = groupX_size * groupX_id + ((lX % THREADS_PER_ROW) << 2);\n"
"if(((gY << 2) < rows) && (process_col < operate_cols))\n"
"{\n"
"int dst_cols_start = dst_offset_x;\n"
"int dst_cols_end   = dst_offset_x + cols;\n"
"int dst_cols_index = (dst_offset_x + process_col) & 0xfffffffc;\n"
"int dst_rows_end   = dst_offset_y + rows;\n"
"int dst_rows_index = dst_offset_y + (gY << ROWS_PER_GROUP_BITS) + (lX >> THREADS_PER_ROW_BIT);\n"
"uchar4 dst_data = *((__global uchar4 *)(dst + dst_rows_index * dst_step + dst_cols_index));\n"
"int4 sum = (int4)(0);\n"
"uchar4 data;\n"
"for(int i = 0; i < ANCHOR; i++)\n"
"{\n"
"#pragma unroll 3\n"
"for(int j = 0; j < ANCHOR; j++)\n"
"{\n"
"if(dst_rows_index < dst_rows_end)\n"
"{\n"
"int local_row = (lX >> THREADS_PER_ROW_BIT) + i;\n"
"int local_cols = ((lX % THREADS_PER_ROW) << ELEMENTS_PER_THREAD_BIT) + j;\n"
"data = vload4(0, local_data+local_row * LOCAL_MEM_STEP + local_cols);\n"
"sum = sum + (mat_kernel[i * ANCHOR + j] * convert_int4_sat(data));\n"
"}\n"
"}\n"
"}\n"
"if(dst_rows_index < dst_rows_end)\n"
"{\n"
"sum.x = ((dst_cols_index + 0 >= dst_cols_start) && (dst_cols_index + 0 < dst_cols_end)) ? sum.x : dst_data.x;\n"
"sum.y = ((dst_cols_index + 1 >= dst_cols_start) && (dst_cols_index + 1 < dst_cols_end)) ? sum.y : dst_data.y;\n"
"sum.z = ((dst_cols_index + 2 >= dst_cols_start) && (dst_cols_index + 2 < dst_cols_end)) ? sum.z : dst_data.z;\n"
"sum.w = ((dst_cols_index + 3 >= dst_cols_start) && (dst_cols_index + 3 < dst_cols_end)) ? sum.w : dst_data.w;\n"
"*((__global uchar4 *)(dst + dst_rows_index * dst_step + dst_cols_index)) = convert_uchar4_sat(sum);\n"
"}\n"
"}\n"
"}\n"
"__kernel void filter2D_C1_D5(__global float *src, int src_step, int src_offset_x, int src_offset_y,\n"
"__global float *dst, int dst_step, int dst_offset_x, int dst_offset_y,\n"
"__constant int *mat_kernel __attribute__((max_constant_size (16384))),\n"
"int cols,int rows, int operate_cols, int wholecols, int wholerows)\n"
"{\n"
"int gX = get_global_id(0);\n"
"int gY = get_global_id(1);\n"
"int lX = get_local_id(0);\n"
"int groupX_size = get_local_size(0);\n"
"int groupX_id   = get_group_id(0);\n"
"#define dst_align (dst_offset_x & 3)\n"
"int cols_start_index_group = src_offset_x - dst_align + groupX_size * groupX_id - ANX;\n"
"int rows_start_index       = src_offset_y + (gY << ROWS_PER_GROUP_BITS) - ANY;\n"
"__local float local_data[LOCAL_MEM_STEP * ROWS_FETCH];\n"
"if(((gY << 2) < rows))\n"
"{\n"
"for(int i = 0; i < ROWS_FETCH; ++i)\n"
"{\n"
"if((rows_start_index - src_offset_y) + i < rows + ANY)\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"int selected_row  = rows_start_index + i;\n"
"int selected_cols = cols_start_index_group + lX;\n"
"float data = *((__global float *)((__global char *)src + selected_row * src_step + (selected_cols << 2)));\n"
"int con = selected_row >=0 && selected_row < wholerows && selected_cols >=0 && selected_cols < wholecols;\n"
"data = con ? data : 0;\n"
"local_data[i * LOCAL_MEM_STEP + lX ] =data;\n"
"if(lX < (ANX << 1))\n"
"{\n"
"selected_cols = cols_start_index_group + lX + groupX_size;\n"
"data = *((__global float *)((__global char *)src + selected_row * src_step + (selected_cols << 2)));\n"
"con = selected_row >=0 && selected_row < wholerows && selected_cols >=0 && selected_cols < wholecols;\n"
"data = con ? data : 0;\n"
"local_data[i * LOCAL_MEM_STEP + lX + groupX_size] =data;\n"
"}\n"
"#else\n"
"int selected_row = ADDR_H(rows_start_index + i,  0, wholerows);\n"
"selected_row     = ADDR_B(rows_start_index + i, wholerows, selected_row);\n"
"int selected_cols = ADDR_L(cols_start_index_group + lX, 0, wholecols);\n"
"selected_cols     = ADDR_R(cols_start_index_group + lX, wholecols, selected_cols);\n"
"float data = *((__global float *)((__global char *)src + selected_row * src_step + (selected_cols << 2)));\n"
"local_data[i * LOCAL_MEM_STEP + lX] =data;\n"
"if(lX < (ANX << 1))\n"
"{\n"
"selected_cols = cols_start_index_group + lX + groupX_size;\n"
"selected_cols = ADDR_R(selected_cols, wholecols, selected_cols);\n"
"data = *((__global float *)((__global char *)src + selected_row * src_step + (selected_cols << 2)));\n"
"local_data[i * LOCAL_MEM_STEP + lX + groupX_size] =data;\n"
"}\n"
"#endif\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int process_col = groupX_size * groupX_id + ((lX % THREADS_PER_ROW) << 2);\n"
"if(((gY << 2) < rows) && (process_col < operate_cols))\n"
"{\n"
"int dst_cols_start = dst_offset_x;\n"
"int dst_cols_end   = dst_offset_x + cols;\n"
"int dst_cols_index = (dst_offset_x + process_col) & 0xfffffffc;\n"
"int dst_rows_end   = dst_offset_y + rows;\n"
"int dst_rows_index = dst_offset_y + (gY << ROWS_PER_GROUP_BITS) + (lX >> THREADS_PER_ROW_BIT);\n"
"float4 dst_data = *((__global float4*)((__global char *)dst + dst_rows_index * dst_step + (dst_cols_index << 2)));\n"
"float4 sum = (float4)(0);\n"
"float4 data;\n"
"for(int i = 0; i < ANCHOR; i++)\n"
"{\n"
"#pragma unroll 3\n"
"for(int j = 0; j < ANCHOR; j++)\n"
"{\n"
"if(dst_rows_index < dst_rows_end)\n"
"{\n"
"int local_row = (lX >> THREADS_PER_ROW_BIT) + i;\n"
"int local_cols = ((lX % THREADS_PER_ROW) << ELEMENTS_PER_THREAD_BIT) + j;\n"
"data = vload4(0, local_data+local_row * LOCAL_MEM_STEP + local_cols);\n"
"sum = sum + (mat_kernel[i * ANCHOR + j] * data);\n"
"}\n"
"}\n"
"}\n"
"if(dst_rows_index < dst_rows_end)\n"
"{\n"
"sum.x = ((dst_cols_index + 0 >= dst_cols_start) && (dst_cols_index + 0 < dst_cols_end)) ? sum.x : dst_data.x;\n"
"sum.y = ((dst_cols_index + 1 >= dst_cols_start) && (dst_cols_index + 1 < dst_cols_end)) ? sum.y : dst_data.y;\n"
"sum.z = ((dst_cols_index + 2 >= dst_cols_start) && (dst_cols_index + 2 < dst_cols_end)) ? sum.z : dst_data.z;\n"
"sum.w = ((dst_cols_index + 3 >= dst_cols_start) && (dst_cols_index + 3 < dst_cols_end)) ? sum.w : dst_data.w;\n"
"*((__global float4 *)((__global char *)dst + dst_rows_index * dst_step + (dst_cols_index << 2))) = sum;\n"
"}\n"
"}\n"
"}\n"
"__kernel void filter2D_C4_D0(__global uchar4 *src, int src_step, int src_offset_x, int src_offset_y,\n"
"__global uchar4 *dst, int dst_step, int dst_offset_x, int dst_offset_y,\n"
"__constant int *mat_kernel __attribute__((max_constant_size (16384))),\n"
"int cols,int rows, int operate_cols, int wholecols, int wholerows)\n"
"{\n"
"int gX = get_global_id(0);\n"
"int gY = get_global_id(1);\n"
"int lX = get_local_id(0);\n"
"int groupX_size = get_local_size(0);\n"
"int groupX_id   = get_group_id(0);\n"
"#define dst_align (dst_offset_x & 3)\n"
"int cols_start_index_group = src_offset_x - dst_align + groupX_size * groupX_id - ANX;\n"
"int rows_start_index       = src_offset_y + (gY << ROWS_PER_GROUP_BITS) - ANY;\n"
"__local uchar4 local_data[LOCAL_MEM_STEP * ROWS_FETCH];\n"
"if(((gY << 2) < rows))\n"
"{\n"
"for(int i = 0; i < ROWS_FETCH; ++i)\n"
"{\n"
"if((rows_start_index - src_offset_y) + i < rows + ANY)\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"int selected_row  = rows_start_index + i;\n"
"int selected_cols = cols_start_index_group + lX;\n"
"uchar4 data = *((__global uchar4*)((__global char*)src + selected_row * src_step + (selected_cols << 2)));\n"
"int con = selected_row >=0 && selected_row < wholerows && selected_cols >=0 && selected_cols < wholecols;\n"
"data = con ? data : 0;\n"
"local_data[i * LOCAL_MEM_STEP + lX ] =data;\n"
"if(lX < (ANX << 1))\n"
"{\n"
"selected_cols = cols_start_index_group + lX + groupX_size;\n"
"data = *((__global uchar4*)((__global char*)src + selected_row * src_step + (selected_cols << 2)));\n"
"con = selected_row >=0 && selected_row < wholerows && selected_cols >=0 && selected_cols < wholecols;\n"
"data = con ? data : 0;\n"
"local_data[i * LOCAL_MEM_STEP + lX + groupX_size] =data;\n"
"}\n"
"#else\n"
"int selected_row = ADDR_H(rows_start_index + i,  0, wholerows);\n"
"selected_row     = ADDR_B(rows_start_index + i, wholerows, selected_row);\n"
"int selected_cols = ADDR_L(cols_start_index_group + lX, 0, wholecols);\n"
"selected_cols     = ADDR_R(cols_start_index_group + lX, wholecols, selected_cols);\n"
"uchar4 data = *((__global uchar4*)((__global char*)src + selected_row * src_step + (selected_cols << 2)));\n"
"local_data[i * LOCAL_MEM_STEP + lX] =data;\n"
"if(lX < (ANX << 1))\n"
"{\n"
"selected_cols = cols_start_index_group + lX + groupX_size;\n"
"selected_cols = ADDR_R(selected_cols, wholecols, selected_cols);\n"
"data = *((__global uchar4*)((__global char*)src + selected_row * src_step + (selected_cols << 2)));\n"
"local_data[i * LOCAL_MEM_STEP + lX + groupX_size] =data;\n"
"}\n"
"#endif\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int process_col = groupX_size * groupX_id + ((lX % THREADS_PER_ROW) << 2);\n"
"if(((gY << 2) < rows) && (process_col < operate_cols))\n"
"{\n"
"int dst_cols_start = dst_offset_x;\n"
"int dst_cols_end   = dst_offset_x + cols;\n"
"int dst_cols_index = (dst_offset_x + process_col) & 0xfffffffc;\n"
"int dst_rows_end   = dst_offset_y + rows;\n"
"int dst_rows_index = dst_offset_y + (gY << ROWS_PER_GROUP_BITS) + (lX >> THREADS_PER_ROW_BIT);\n"
"uchar16 dst_data;\n"
"dst_data = *((__global uchar16*)((__global char *)dst + dst_rows_index * dst_step + (dst_cols_index << 2)));\n"
"int16 sum = (int16)(0);\n"
"uchar16 data;\n"
"for(int i = 0; i < ANCHOR; i++)\n"
"{\n"
"#pragma unroll 3\n"
"for(int j = 0; j < ANCHOR; j++)\n"
"{\n"
"if(dst_rows_index < dst_rows_end)\n"
"{\n"
"int local_row = (lX >> THREADS_PER_ROW_BIT) + i;\n"
"int local_cols = ((lX % THREADS_PER_ROW) << ELEMENTS_PER_THREAD_BIT) + j;\n"
"data = vload16(0, (__local uchar *)(local_data+local_row * LOCAL_MEM_STEP + local_cols));\n"
"sum = sum + (mat_kernel[i * ANCHOR + j] * convert_int16_sat(data));\n"
"}\n"
"}\n"
"}\n"
"if(dst_rows_index < dst_rows_end)\n"
"{\n"
"uchar16 sum1 = convert_uchar16_sat(sum);\n"
"sum1.s0123 = ((dst_cols_index + 0 >= dst_cols_start) && (dst_cols_index + 0 < dst_cols_end))?\n"
"sum1.s0123 : dst_data.s0123;\n"
"sum1.s4567 = ((dst_cols_index + 1 >= dst_cols_start) && (dst_cols_index + 1 < dst_cols_end))?\n"
"sum1.s4567 : dst_data.s4567;\n"
"sum1.s89ab = ((dst_cols_index + 2 >= dst_cols_start) && (dst_cols_index + 2 < dst_cols_end))?\n"
"sum1.s89ab : dst_data.s89ab;\n"
"sum1.scdef = ((dst_cols_index + 3 >= dst_cols_start) && (dst_cols_index + 3 < dst_cols_end))?\n"
"sum1.scdef : dst_data.scdef;\n"
"*((__global uchar16*)((__global char *)dst + dst_rows_index * dst_step + (dst_cols_index << 2))) = sum1;\n"
"}\n"
"}\n"
"}\n"
"#define ROWS_FETCH_C4              (1 + ANY + ANY)\n"
"#define LOCAL_MEM_STEP_C4           260\n"
"__kernel void filter2D_C4_D5(__global float4 *src, int src_step, int src_offset_x, int src_offset_y,\n"
"__global float4 *dst, int dst_step, int dst_offset_x, int dst_offset_y,\n"
"__constant int *mat_kernel __attribute__((max_constant_size (16384))),\n"
"int cols,int rows, int operate_cols, int wholecols, int wholerows)\n"
"{\n"
"int gX = get_global_id(0);\n"
"int gY = get_global_id(1);\n"
"int lX = get_local_id(0);\n"
"int groupX_size = get_local_size(0);\n"
"int groupX_id   = get_group_id(0);\n"
"int cols_start_index_group = src_offset_x + groupX_size * groupX_id - ANX;\n"
"int rows_start_index       = src_offset_y + gY - ANY;\n"
"__local float4 local_data[LOCAL_MEM_STEP_C4 * ROWS_FETCH_C4];\n"
"if((gY < rows) && (gX < (operate_cols + ANX + ANX)))\n"
"{\n"
"for(int i = 0; i < ROWS_FETCH_C4; ++i)\n"
"{\n"
"if((rows_start_index - src_offset_y) + i < rows + ANY)\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"int selected_row  = rows_start_index + i;\n"
"int selected_cols = cols_start_index_group + lX;\n"
"float4 data = *((__global float4*)((__global char*)src + selected_row * src_step + (selected_cols << 4)));\n"
"int con = selected_row >=0 && selected_row < wholerows && selected_cols >=0 && selected_cols < wholecols;\n"
"data = con ? data : 0;\n"
"local_data[i * LOCAL_MEM_STEP + lX ] =data;\n"
"if(lX < (ANX << 1))\n"
"{\n"
"selected_cols = cols_start_index_group + lX + groupX_size;\n"
"data = *((__global float4*)((__global char*)src + selected_row * src_step + (selected_cols << 4)));\n"
"con = selected_row >=0 && selected_row < wholerows && selected_cols >=0 && selected_cols < wholecols;\n"
"data = con ? data : 0;\n"
"local_data[i * LOCAL_MEM_STEP + lX + groupX_size] =data;\n"
"}\n"
"#else\n"
"int selected_row = ADDR_H(rows_start_index + i,  0, wholerows);\n"
"selected_row     = ADDR_B(rows_start_index + i, wholerows, selected_row);\n"
"int selected_cols = ADDR_L(cols_start_index_group + lX, 0, wholecols);\n"
"selected_cols     = ADDR_R(cols_start_index_group + lX, wholecols, selected_cols);\n"
"float4 data = *((__global float4*)((__global char*)src + selected_row * src_step + (selected_cols << 4)));\n"
"local_data[i * LOCAL_MEM_STEP_C4 + lX] =data;\n"
"if(lX < (ANX << 1))\n"
"{\n"
"selected_cols = cols_start_index_group + lX + groupX_size;\n"
"selected_cols = ADDR_R(selected_cols, wholecols, selected_cols);\n"
"data = *((__global float4*)((__global char*)src + selected_row * src_step + (selected_cols << 4)));\n"
"local_data[i * LOCAL_MEM_STEP_C4 + lX + groupX_size] =data;\n"
"}\n"
"#endif\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if((gY < rows) && (gX < operate_cols))\n"
"{\n"
"int dst_cols_index = dst_offset_x + gX;\n"
"int dst_rows_index = dst_offset_y + gY;\n"
"float4 sum = (float4)(0);\n"
"for(int i = 0; i < ANCHOR; i++)\n"
"{\n"
"for(int j = 0; j < ANCHOR; j++)\n"
"{\n"
"int local_cols = lX + j;\n"
"sum = sum + mat_kernel[i * ANCHOR + j] * local_data[i * LOCAL_MEM_STEP_C4 + local_cols];\n"
"}\n"
"}\n"
"*((__global float4*)((__global char *)dst + dst_rows_index * dst_step + (dst_cols_index << 4))) = sum;\n"
"}\n"
"}\n"
;
const char* filtering_morph="#ifdef ERODE\n"
"#define MORPH_OP(A,B) min((A),(B))\n"
"#endif\n"
"#ifdef DILATE\n"
"#define MORPH_OP(A,B) max((A),(B))\n"
"#endif\n"
"#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"#ifndef GENTYPE\n"
"__kernel void morph_C1_D0(__global const uchar * restrict src,\n"
"__global uchar *dst,\n"
"int src_offset_x, int src_offset_y,\n"
"int cols, int rows,\n"
"int src_step_in_pixel, int dst_step_in_pixel,\n"
"__constant uchar * mat_kernel,\n"
"int src_whole_cols, int src_whole_rows,\n"
"int dst_offset_in_pixel)\n"
"{\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int x = get_group_id(0)*4*LSIZE0;\n"
"int y = get_group_id(1)*LSIZE1;\n"
"int start_x = x+src_offset_x-RADIUSX & 0xfffffffc;\n"
"int end_x = x + src_offset_x+LSIZE0*4+RADIUSX & 0xfffffffc;\n"
"int width = (end_x -start_x+4)>>2;\n"
"int offset = src_offset_x-RADIUSX & 3;\n"
"int start_y = y+src_offset_y-RADIUSY;\n"
"int point1 = mad24(l_y,LSIZE0,l_x);\n"
"int point2 = point1 + LSIZE0*LSIZE1;\n"
"int tl_x = (point1 % width)<<2;\n"
"int tl_y = point1 / width;\n"
"int tl_x2 = (point2 % width)<<2;\n"
"int tl_y2 = point2 / width;\n"
"int cur_x = start_x + tl_x;\n"
"int cur_y = start_y + tl_y;\n"
"int cur_x2 = start_x + tl_x2;\n"
"int cur_y2 = start_y + tl_y2;\n"
"int start_addr = mad24(cur_y,src_step_in_pixel,cur_x);\n"
"int start_addr2 = mad24(cur_y2,src_step_in_pixel,cur_x2);\n"
"uchar4 temp0,temp1;\n"
"__local uchar4 LDS_DAT[2*LSIZE1*LSIZE0];\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"start_addr = ((start_addr < end_addr) && (start_addr > 0)) ? start_addr : 0;\n"
"start_addr2 = ((start_addr2 < end_addr) && (start_addr2 > 0)) ? start_addr2 : 0;\n"
"temp0 = *(__global uchar4*)&src[start_addr];\n"
"temp1 = *(__global uchar4*)&src[start_addr2];\n"
"temp0.x= ELEM(cur_x,0,src_whole_cols,VAL,temp0.x);\n"
"temp0.y= ELEM(cur_x+1,0,src_whole_cols,VAL,temp0.y);\n"
"temp0.z= ELEM(cur_x+2,0,src_whole_cols,VAL,temp0.z);\n"
"temp0.w= ELEM(cur_x+3,0,src_whole_cols,VAL,temp0.w);\n"
"temp0= ELEM(cur_y,0,src_whole_rows,(uchar4)VAL,temp0);\n"
"temp1.x= ELEM(cur_x2,0,src_whole_cols,VAL,temp1.x);\n"
"temp1.y= ELEM(cur_x2+1,0,src_whole_cols,VAL,temp1.y);\n"
"temp1.z= ELEM(cur_x2+2,0,src_whole_cols,VAL,temp1.z);\n"
"temp1.w= ELEM(cur_x2+3,0,src_whole_cols,VAL,temp1.w);\n"
"temp1= ELEM(cur_y2,0,src_whole_rows,(uchar4)VAL,temp1);\n"
"LDS_DAT[point1] = temp0;\n"
"LDS_DAT[point2] = temp1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"uchar4 res = (uchar4)VAL;\n"
"for(int i=0; i<2*RADIUSY+1; i++)\n"
"for(int j=0; j<2*RADIUSX+1; j++)\n"
"{\n"
"res =\n"
"#ifndef RECTKERNEL\n"
"mat_kernel[i*(2*RADIUSX+1)+j] ?\n"
"#endif\n"
"MORPH_OP(res,vload4(0,(__local uchar*)&LDS_DAT[mad24((l_y+i),width,l_x)]+offset+j))\n"
"#ifndef RECTKERNEL\n"
":res\n"
"#endif\n"
";\n"
"}\n"
"int gidx = get_global_id(0)<<2;\n"
"int gidy = get_global_id(1);\n"
"int out_addr = mad24(gidy,dst_step_in_pixel,gidx+dst_offset_in_pixel);\n"
"if(gidx+3<cols && gidy<rows && (dst_offset_in_pixel&3)==0)\n"
"{\n"
"*(__global uchar4*)&dst[out_addr] = res;\n"
"}\n"
"else\n"
"{\n"
"if(gidx+3<cols && gidy<rows)\n"
"{\n"
"dst[out_addr] = res.x;\n"
"dst[out_addr+1] = res.y;\n"
"dst[out_addr+2] = res.z;\n"
"dst[out_addr+3] = res.w;\n"
"}\n"
"else if(gidx+2<cols && gidy<rows)\n"
"{\n"
"dst[out_addr] = res.x;\n"
"dst[out_addr+1] = res.y;\n"
"dst[out_addr+2] = res.z;\n"
"}\n"
"else if(gidx+1<cols && gidy<rows)\n"
"{\n"
"dst[out_addr] = res.x;\n"
"dst[out_addr+1] = res.y;\n"
"}\n"
"else if(gidx<cols && gidy<rows)\n"
"{\n"
"dst[out_addr] = res.x;\n"
"}\n"
"}\n"
"}\n"
"#else\n"
"__kernel void morph(__global const GENTYPE * restrict src,\n"
"__global GENTYPE *dst,\n"
"int src_offset_x, int src_offset_y,\n"
"int cols, int rows,\n"
"int src_step_in_pixel, int dst_step_in_pixel,\n"
"__constant uchar * mat_kernel,\n"
"int src_whole_cols, int src_whole_rows,\n"
"int dst_offset_in_pixel)\n"
"{\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int x = get_group_id(0)*LSIZE0;\n"
"int y = get_group_id(1)*LSIZE1;\n"
"int start_x = x+src_offset_x-RADIUSX;\n"
"int end_x = x + src_offset_x+LSIZE0+RADIUSX;\n"
"int width = end_x -(x+src_offset_x-RADIUSX)+1;\n"
"int start_y = y+src_offset_y-RADIUSY;\n"
"int point1 = mad24(l_y,LSIZE0,l_x);\n"
"int point2 = point1 + LSIZE0*LSIZE1;\n"
"int tl_x = point1 % width;\n"
"int tl_y = point1 / width;\n"
"int tl_x2 = point2 % width;\n"
"int tl_y2 = point2 / width;\n"
"int cur_x = start_x + tl_x;\n"
"int cur_y = start_y + tl_y;\n"
"int cur_x2 = start_x + tl_x2;\n"
"int cur_y2 = start_y + tl_y2;\n"
"int start_addr = mad24(cur_y,src_step_in_pixel,cur_x);\n"
"int start_addr2 = mad24(cur_y2,src_step_in_pixel,cur_x2);\n"
"GENTYPE temp0,temp1;\n"
"__local GENTYPE LDS_DAT[2*LSIZE1*LSIZE0];\n"
"int end_addr = mad24(src_whole_rows - 1,src_step_in_pixel,src_whole_cols);\n"
"start_addr = ((start_addr < end_addr) && (start_addr > 0)) ? start_addr : 0;\n"
"start_addr2 = ((start_addr2 < end_addr) && (start_addr2 > 0)) ? start_addr2 : 0;\n"
"temp0 = src[start_addr];\n"
"temp1 = src[start_addr2];\n"
"temp0= ELEM(cur_x,0,src_whole_cols,(GENTYPE)VAL,temp0);\n"
"temp0= ELEM(cur_y,0,src_whole_rows,(GENTYPE)VAL,temp0);\n"
"temp1= ELEM(cur_x2,0,src_whole_cols,(GENTYPE)VAL,temp1);\n"
"temp1= ELEM(cur_y2,0,src_whole_rows,(GENTYPE)VAL,temp1);\n"
"LDS_DAT[point1] = temp0;\n"
"LDS_DAT[point2] = temp1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"GENTYPE res = (GENTYPE)VAL;\n"
"for(int i=0; i<2*RADIUSY+1; i++)\n"
"for(int j=0; j<2*RADIUSX+1; j++)\n"
"{\n"
"res =\n"
"#ifndef RECTKERNEL\n"
"mat_kernel[i*(2*RADIUSX+1)+j] ?\n"
"#endif\n"
"MORPH_OP(res,LDS_DAT[mad24(l_y+i,width,l_x+j)])\n"
"#ifndef RECTKERNEL\n"
":res\n"
"#endif\n"
";\n"
"}\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int out_addr = mad24(gidy,dst_step_in_pixel,gidx+dst_offset_in_pixel);\n"
"if(gidx<cols && gidy<rows)\n"
"{\n"
"dst[out_addr] = res;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* haarobjectdetect="#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#define CV_HAAR_FEATURE_MAX           3\n"
"#define calc_sum(rect,offset)        (sum[(rect).p0+offset] - sum[(rect).p1+offset] - sum[(rect).p2+offset] + sum[(rect).p3+offset])\n"
"#define calc_sum1(rect,offset,i)     (sum[(rect).p0[i]+offset] - sum[(rect).p1[i]+offset] - sum[(rect).p2[i]+offset] + sum[(rect).p3[i]+offset])\n"
"typedef int   sumtype;\n"
"typedef float sqsumtype;\n"
"typedef struct  __attribute__((aligned (128)))  GpuHidHaarFeature\n"
"{\n"
"struct __attribute__((aligned (32)))\n"
"{\n"
"int p0 __attribute__((aligned (4)));\n"
"int p1 __attribute__((aligned (4)));\n"
"int p2 __attribute__((aligned (4)));\n"
"int p3 __attribute__((aligned (4)));\n"
"float weight __attribute__((aligned (4)));\n"
"}\n"
"rect[CV_HAAR_FEATURE_MAX] __attribute__((aligned (32)));\n"
"}\n"
"GpuHidHaarFeature;\n"
"typedef struct __attribute__((aligned (128) )) GpuHidHaarTreeNode\n"
"{\n"
"int p[CV_HAAR_FEATURE_MAX][4] __attribute__((aligned (64)));\n"
"float weight[CV_HAAR_FEATURE_MAX] ;\n"
"float threshold ;\n"
"float alpha[2] __attribute__((aligned (8)));\n"
"int left __attribute__((aligned (4)));\n"
"int right __attribute__((aligned (4)));\n"
"}\n"
"GpuHidHaarTreeNode;\n"
"typedef struct __attribute__((aligned (32))) GpuHidHaarClassifier\n"
"{\n"
"int count __attribute__((aligned (4)));\n"
"GpuHidHaarTreeNode* node __attribute__((aligned (8)));\n"
"float* alpha __attribute__((aligned (8)));\n"
"}\n"
"GpuHidHaarClassifier;\n"
"typedef struct __attribute__((aligned (64))) GpuHidHaarStageClassifier\n"
"{\n"
"int  count __attribute__((aligned (4)));\n"
"float threshold __attribute__((aligned (4)));\n"
"int two_rects __attribute__((aligned (4)));\n"
"int reserved0 __attribute__((aligned (8)));\n"
"int reserved1 __attribute__((aligned (8)));\n"
"int reserved2 __attribute__((aligned (8)));\n"
"int reserved3 __attribute__((aligned (8)));\n"
"}\n"
"GpuHidHaarStageClassifier;\n"
"typedef struct __attribute__((aligned (64))) GpuHidHaarClassifierCascade\n"
"{\n"
"int  count __attribute__((aligned (4)));\n"
"int  is_stump_based __attribute__((aligned (4)));\n"
"int  has_tilted_features __attribute__((aligned (4)));\n"
"int  is_tree __attribute__((aligned (4)));\n"
"int pq0 __attribute__((aligned (4)));\n"
"int pq1 __attribute__((aligned (4)));\n"
"int pq2 __attribute__((aligned (4)));\n"
"int pq3 __attribute__((aligned (4)));\n"
"int p0 __attribute__((aligned (4)));\n"
"int p1 __attribute__((aligned (4)));\n"
"int p2 __attribute__((aligned (4)));\n"
"int p3 __attribute__((aligned (4)));\n"
"float inv_window_area __attribute__((aligned (4)));\n"
"} GpuHidHaarClassifierCascade;\n"
"__kernel void __attribute__((reqd_work_group_size(8,8,1)))gpuRunHaarClassifierCascade(\n"
"global GpuHidHaarStageClassifier * stagecascadeptr,\n"
"global int4 * info,\n"
"global GpuHidHaarTreeNode * nodeptr,\n"
"global const int * restrict sum1,\n"
"global const float * restrict sqsum1,\n"
"global int4 * candidate,\n"
"const int pixelstep,\n"
"const int loopcount,\n"
"const int start_stage,\n"
"const int split_stage,\n"
"const int end_stage,\n"
"const int startnode,\n"
"const int splitnode,\n"
"const int4 p,\n"
"const int4 pq,\n"
"const float correction\n"
")\n"
"{\n"
"int grpszx = get_local_size(0);\n"
"int grpszy = get_local_size(1);\n"
"int grpnumx = get_num_groups(0);\n"
"int grpidx = get_group_id(0);\n"
"int lclidx = get_local_id(0);\n"
"int lclidy = get_local_id(1);\n"
"int lcl_sz = mul24(grpszx,grpszy);\n"
"int lcl_id = mad24(lclidy,grpszx,lclidx);\n"
"__local int lclshare[1024];\n"
"#define OFF 0\n"
"__local int* lcldata = lclshare + OFF;\n"
"__local int* glboutindex = lcldata + 28*28;\n"
"__local int* lclcount = glboutindex + 1;\n"
"__local int* lcloutindex = lclcount + 1;\n"
"__local float* partialsum = (__local float*)(lcloutindex + (lcl_sz<<1));\n"
"glboutindex[0]=0;\n"
"int outputoff = mul24(grpidx,256);\n"
"#define WINDOWSIZE 20+1\n"
"int readwidth = ((grpszx-1 + WINDOWSIZE+3)>>2)<<2;\n"
"int readheight = grpszy-1+WINDOWSIZE;\n"
"int read_horiz_cnt = readwidth >> 2;\n"
"int total_read = mul24(read_horiz_cnt,readheight);\n"
"int read_loop = (total_read + lcl_sz - 1) >> 6;\n"
"candidate[outputoff+(lcl_id<<2)] = (int4)0;\n"
"candidate[outputoff+(lcl_id<<2)+1] = (int4)0;\n"
"candidate[outputoff+(lcl_id<<2)+2] = (int4)0;\n"
"candidate[outputoff+(lcl_id<<2)+3] = (int4)0;\n"
"for(int scalei = 0; scalei <loopcount; scalei++)\n"
"{\n"
"int4 scaleinfo1= info[scalei];\n"
"int width = (scaleinfo1.x & 0xffff0000) >> 16;\n"
"int height = scaleinfo1.x & 0xffff;\n"
"int grpnumperline =(scaleinfo1.y & 0xffff0000) >> 16;\n"
"int totalgrp = scaleinfo1.y & 0xffff;\n"
"int imgoff = scaleinfo1.z;\n"
"float factor = as_float(scaleinfo1.w);\n"
"__global const int * sum = sum1 + imgoff;\n"
"__global const float * sqsum = sqsum1 + imgoff;\n"
"for(int grploop=grpidx; grploop<totalgrp; grploop+=grpnumx)\n"
"{\n"
"int grpidy = grploop / grpnumperline;\n"
"int grpidx = grploop - mul24(grpidy, grpnumperline);\n"
"int x = mad24(grpidx,grpszx,lclidx);\n"
"int y = mad24(grpidy,grpszy,lclidy);\n"
"int grpoffx = x-lclidx;\n"
"int grpoffy = y-lclidy;\n"
"for(int i=0; i<read_loop; i++)\n"
"{\n"
"int pos_id = mad24(i,lcl_sz,lcl_id);\n"
"pos_id = pos_id < total_read ? pos_id : 0;\n"
"int lcl_y = pos_id / read_horiz_cnt;\n"
"int lcl_x = pos_id - mul24(lcl_y, read_horiz_cnt);\n"
"int glb_x = grpoffx + (lcl_x<<2);\n"
"int glb_y = grpoffy + lcl_y;\n"
"int glb_off = mad24(glb_y,pixelstep,glb_x);\n"
"int4 data = *(__global int4*)&sum[glb_off];\n"
"int lcl_off = mad24(lcl_y, readwidth, lcl_x<<2);\n"
"#if OFF\n"
"lcldata[lcl_off] = data.x;\n"
"lcldata[lcl_off+1] = data.y;\n"
"lcldata[lcl_off+2] = data.z;\n"
"lcldata[lcl_off+3] = data.w;\n"
"#else\n"
"vstore4(data, 0, &lcldata[lcl_off]);\n"
"#endif\n"
"}\n"
"lcloutindex[lcl_id] = 0;\n"
"lclcount[0] = 0;\n"
"int result = 1;\n"
"int nodecounter= startnode;\n"
"float mean, variance_norm_factor;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int lcl_off = mad24(lclidy,readwidth,lclidx);\n"
"int4 cascadeinfo1, cascadeinfo2;\n"
"cascadeinfo1 = p;\n"
"cascadeinfo2 = pq;\n"
"{\n"
"cascadeinfo1.x +=lcl_off;\n"
"cascadeinfo1.z +=lcl_off;\n"
"mean = (lcldata[mad24(cascadeinfo1.y,readwidth,cascadeinfo1.x)] - lcldata[mad24(cascadeinfo1.y,readwidth,cascadeinfo1.z)] -\n"
"lcldata[mad24(cascadeinfo1.w,readwidth,cascadeinfo1.x)] + lcldata[mad24(cascadeinfo1.w,readwidth,cascadeinfo1.z)])\n"
"*correction;\n"
"int p_offset = mad24(y, pixelstep, x);\n"
"cascadeinfo2.x +=p_offset;\n"
"cascadeinfo2.z +=p_offset;\n"
"variance_norm_factor =sqsum[mad24(cascadeinfo2.y, pixelstep, cascadeinfo2.x)] - sqsum[mad24(cascadeinfo2.y, pixelstep, cascadeinfo2.z)] -\n"
"sqsum[mad24(cascadeinfo2.w, pixelstep, cascadeinfo2.x)] + sqsum[mad24(cascadeinfo2.w, pixelstep, cascadeinfo2.z)];\n"
"variance_norm_factor = variance_norm_factor * correction - mean * mean;\n"
"variance_norm_factor = variance_norm_factor >=0.f ? sqrt(variance_norm_factor) : 1.f;\n"
"for(int stageloop = start_stage; (stageloop < split_stage)  && result; stageloop++ )\n"
"{\n"
"float stage_sum = 0.f;\n"
"int2 stageinfo = *(global int2*)(stagecascadeptr+stageloop);\n"
"float stagethreshold = as_float(stageinfo.y);\n"
"for(int nodeloop = 0; nodeloop < stageinfo.x; nodeloop++ )\n"
"{\n"
"__global GpuHidHaarTreeNode* currentnodeptr = (nodeptr + nodecounter);\n"
"int4 info1 = *(__global int4*)(&(currentnodeptr->p[0][0]));\n"
"int4 info2 = *(__global int4*)(&(currentnodeptr->p[1][0]));\n"
"int4 info3 = *(__global int4*)(&(currentnodeptr->p[2][0]));\n"
"float4 w = *(__global float4*)(&(currentnodeptr->weight[0]));\n"
"float2 alpha2 = *(__global float2*)(&(currentnodeptr->alpha[0]));\n"
"float nodethreshold  = w.w * variance_norm_factor;\n"
"info1.x +=lcl_off;\n"
"info1.z +=lcl_off;\n"
"info2.x +=lcl_off;\n"
"info2.z +=lcl_off;\n"
"float classsum = (lcldata[mad24(info1.y,readwidth,info1.x)] - lcldata[mad24(info1.y,readwidth,info1.z)] -\n"
"lcldata[mad24(info1.w,readwidth,info1.x)] + lcldata[mad24(info1.w,readwidth,info1.z)]) * w.x;\n"
"classsum += (lcldata[mad24(info2.y,readwidth,info2.x)] - lcldata[mad24(info2.y,readwidth,info2.z)] -\n"
"lcldata[mad24(info2.w,readwidth,info2.x)] + lcldata[mad24(info2.w,readwidth,info2.z)]) * w.y;\n"
"info3.x +=lcl_off;\n"
"info3.z +=lcl_off;\n"
"classsum += (lcldata[mad24(info3.y,readwidth,info3.x)] - lcldata[mad24(info3.y,readwidth,info3.z)] -\n"
"lcldata[mad24(info3.w,readwidth,info3.x)] + lcldata[mad24(info3.w,readwidth,info3.z)]) * w.z;\n"
"stage_sum += classsum >= nodethreshold ? alpha2.y : alpha2.x;\n"
"nodecounter++;\n"
"}\n"
"result = (stage_sum >= stagethreshold);\n"
"}\n"
"if(result && (x < width) && (y < height))\n"
"{\n"
"int queueindex = atomic_inc(lclcount);\n"
"lcloutindex[queueindex<<1] = (lclidy << 16) | lclidx;\n"
"lcloutindex[(queueindex<<1)+1] = as_int(variance_norm_factor);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int queuecount  = lclcount[0];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"nodecounter = splitnode;\n"
"for(int stageloop = split_stage; stageloop< end_stage && queuecount>0; stageloop++)\n"
"{\n"
"lclcount[0]=0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int2 stageinfo = *(global int2*)(stagecascadeptr+stageloop);\n"
"float stagethreshold = as_float(stageinfo.y);\n"
"int perfscale = queuecount > 4 ? 3 : 2;\n"
"int queuecount_loop = (queuecount + (1<<perfscale)-1) >> perfscale;\n"
"int lcl_compute_win = lcl_sz >> perfscale;\n"
"int lcl_compute_win_id = (lcl_id >>(6-perfscale));\n"
"int lcl_loops = (stageinfo.x + lcl_compute_win -1) >> (6-perfscale);\n"
"int lcl_compute_id = lcl_id - (lcl_compute_win_id << (6-perfscale));\n"
"for(int queueloop=0; queueloop<queuecount_loop; queueloop++)\n"
"{\n"
"float stage_sum = 0.f;\n"
"int temp_coord = lcloutindex[lcl_compute_win_id<<1];\n"
"float variance_norm_factor = as_float(lcloutindex[(lcl_compute_win_id<<1)+1]);\n"
"int queue_pixel = mad24(((temp_coord  & (int)0xffff0000)>>16),readwidth,temp_coord & 0xffff);\n"
"if(lcl_compute_win_id < queuecount)\n"
"{\n"
"int tempnodecounter = lcl_compute_id;\n"
"float part_sum = 0.f;\n"
"for(int lcl_loop=0; lcl_loop<lcl_loops && tempnodecounter<stageinfo.x; lcl_loop++)\n"
"{\n"
"__global GpuHidHaarTreeNode* currentnodeptr = (nodeptr + nodecounter + tempnodecounter);\n"
"int4 info1 = *(__global int4*)(&(currentnodeptr->p[0][0]));\n"
"int4 info2 = *(__global int4*)(&(currentnodeptr->p[1][0]));\n"
"int4 info3 = *(__global int4*)(&(currentnodeptr->p[2][0]));\n"
"float4 w = *(__global float4*)(&(currentnodeptr->weight[0]));\n"
"float2 alpha2 = *(__global float2*)(&(currentnodeptr->alpha[0]));\n"
"float nodethreshold  = w.w * variance_norm_factor;\n"
"info1.x +=queue_pixel;\n"
"info1.z +=queue_pixel;\n"
"info2.x +=queue_pixel;\n"
"info2.z +=queue_pixel;\n"
"float classsum = (lcldata[mad24(info1.y,readwidth,info1.x)] - lcldata[mad24(info1.y,readwidth,info1.z)] -\n"
"lcldata[mad24(info1.w,readwidth,info1.x)] + lcldata[mad24(info1.w,readwidth,info1.z)]) * w.x;\n"
"classsum += (lcldata[mad24(info2.y,readwidth,info2.x)] - lcldata[mad24(info2.y,readwidth,info2.z)] -\n"
"lcldata[mad24(info2.w,readwidth,info2.x)] + lcldata[mad24(info2.w,readwidth,info2.z)]) * w.y;\n"
"info3.x +=queue_pixel;\n"
"info3.z +=queue_pixel;\n"
"classsum += (lcldata[mad24(info3.y,readwidth,info3.x)] - lcldata[mad24(info3.y,readwidth,info3.z)] -\n"
"lcldata[mad24(info3.w,readwidth,info3.x)] + lcldata[mad24(info3.w,readwidth,info3.z)]) * w.z;\n"
"part_sum += classsum >= nodethreshold ? alpha2.y : alpha2.x;\n"
"tempnodecounter +=lcl_compute_win;\n"
"}\n"
"partialsum[lcl_id]=part_sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lcl_compute_win_id < queuecount)\n"
"{\n"
"for(int i=0; i<lcl_compute_win && (lcl_compute_id==0); i++)\n"
"{\n"
"stage_sum += partialsum[lcl_id+i];\n"
"}\n"
"if(stage_sum >= stagethreshold && (lcl_compute_id==0))\n"
"{\n"
"int queueindex = atomic_inc(lclcount);\n"
"lcloutindex[queueindex<<1] = temp_coord;\n"
"lcloutindex[(queueindex<<1)+1] = as_int(variance_norm_factor);\n"
"}\n"
"lcl_compute_win_id +=(1<<perfscale);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"queuecount = lclcount[0];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"nodecounter += stageinfo.x;\n"
"}\n"
"if(lcl_id<queuecount)\n"
"{\n"
"int temp = lcloutindex[lcl_id<<1];\n"
"int x = mad24(grpidx,grpszx,temp & 0xffff);\n"
"int y = mad24(grpidy,grpszy,((temp & (int)0xffff0000) >> 16));\n"
"temp = glboutindex[0];\n"
"int4 candidate_result;\n"
"candidate_result.zw = (int2)convert_int_rtn(factor*20.f);\n"
"candidate_result.x = convert_int_rtn(x*factor);\n"
"candidate_result.y = convert_int_rtn(y*factor);\n"
"atomic_inc(glboutindex);\n"
"candidate[outputoff+temp+lcl_id] = candidate_result;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"}\n"
"}\n"
;
const char* haarobjectdetect_scaled2="#define CV_HAAR_FEATURE_MAX           3\n"
"typedef int   sumtype;\n"
"typedef float sqsumtype;\n"
"typedef struct  __attribute__((aligned(128)))  GpuHidHaarFeature\n"
"{\n"
"struct __attribute__((aligned(32)))\n"
"{\n"
"int p0 __attribute__((aligned(4)));\n"
"int p1 __attribute__((aligned(4)));\n"
"int p2 __attribute__((aligned(4)));\n"
"int p3 __attribute__((aligned(4)));\n"
"float weight __attribute__((aligned(4)));\n"
"}\n"
"rect[CV_HAAR_FEATURE_MAX] __attribute__((aligned(32)));\n"
"}\n"
"GpuHidHaarFeature;\n"
"typedef struct __attribute__((aligned(128))) GpuHidHaarTreeNode\n"
"{\n"
"int p[CV_HAAR_FEATURE_MAX][4] __attribute__((aligned(64)));\n"
"float weight[CV_HAAR_FEATURE_MAX] ;\n"
"float threshold ;\n"
"float alpha[2] __attribute__((aligned(8)));\n"
"int left __attribute__((aligned(4)));\n"
"int right __attribute__((aligned(4)));\n"
"}\n"
"GpuHidHaarTreeNode;\n"
"typedef struct __attribute__((aligned(32))) GpuHidHaarClassifier\n"
"{\n"
"int count __attribute__((aligned(4)));\n"
"GpuHidHaarTreeNode *node __attribute__((aligned(8)));\n"
"float *alpha __attribute__((aligned(8)));\n"
"}\n"
"GpuHidHaarClassifier;\n"
"typedef struct __attribute__((aligned(64))) GpuHidHaarStageClassifier\n"
"{\n"
"int  count __attribute__((aligned(4)));\n"
"float threshold __attribute__((aligned(4)));\n"
"int two_rects __attribute__((aligned(4)));\n"
"int reserved0 __attribute__((aligned(8)));\n"
"int reserved1 __attribute__((aligned(8)));\n"
"int reserved2 __attribute__((aligned(8)));\n"
"int reserved3 __attribute__((aligned(8)));\n"
"}\n"
"GpuHidHaarStageClassifier;\n"
"typedef struct __attribute__((aligned(64))) GpuHidHaarClassifierCascade\n"
"{\n"
"int  count __attribute__((aligned(4)));\n"
"int  is_stump_based __attribute__((aligned(4)));\n"
"int  has_tilted_features __attribute__((aligned(4)));\n"
"int  is_tree __attribute__((aligned(4)));\n"
"int pq0 __attribute__((aligned(4)));\n"
"int pq1 __attribute__((aligned(4)));\n"
"int pq2 __attribute__((aligned(4)));\n"
"int pq3 __attribute__((aligned(4)));\n"
"int p0 __attribute__((aligned(4)));\n"
"int p1 __attribute__((aligned(4)));\n"
"int p2 __attribute__((aligned(4)));\n"
"int p3 __attribute__((aligned(4)));\n"
"float inv_window_area __attribute__((aligned(4)));\n"
"} GpuHidHaarClassifierCascade;\n"
"__kernel void gpuRunHaarClassifierCascade_scaled2(\n"
"global GpuHidHaarStageClassifier *stagecascadeptr,\n"
"global int4 *info,\n"
"global GpuHidHaarTreeNode *nodeptr,\n"
"global const int *restrict sum,\n"
"global const float   *restrict sqsum,\n"
"global int4 *candidate,\n"
"const int step,\n"
"const int loopcount,\n"
"const int start_stage,\n"
"const int split_stage,\n"
"const int end_stage,\n"
"const int startnode,\n"
"const int splitnode,\n"
"global int4 *p,\n"
"global float *correction,\n"
"const int nodecount)\n"
"{\n"
"int grpszx = get_local_size(0);\n"
"int grpszy = get_local_size(1);\n"
"int grpnumx = get_num_groups(0);\n"
"int grpidx = get_group_id(0);\n"
"int lclidx = get_local_id(0);\n"
"int lclidy = get_local_id(1);\n"
"int lcl_sz = mul24(grpszx, grpszy);\n"
"int lcl_id = mad24(lclidy, grpszx, lclidx);\n"
"__local int lclshare[1024];\n"
"__local int *glboutindex = lclshare + 0;\n"
"__local int *lclcount = glboutindex + 1;\n"
"__local int *lcloutindex = lclcount + 1;\n"
"__local float *partialsum = (__local float *)(lcloutindex + (lcl_sz << 1));\n"
"glboutindex[0] = 0;\n"
"int outputoff = mul24(grpidx, 256);\n"
"candidate[outputoff + (lcl_id << 2)] = (int4)0;\n"
"candidate[outputoff + (lcl_id << 2) + 1] = (int4)0;\n"
"candidate[outputoff + (lcl_id << 2) + 2] = (int4)0;\n"
"candidate[outputoff + (lcl_id << 2) + 3] = (int4)0;\n"
"for (int scalei = 0; scalei < loopcount; scalei++)\n"
"{\n"
"int4 scaleinfo1;\n"
"scaleinfo1 = info[scalei];\n"
"int width = (scaleinfo1.x & 0xffff0000) >> 16;\n"
"int height = scaleinfo1.x & 0xffff;\n"
"int grpnumperline = (scaleinfo1.y & 0xffff0000) >> 16;\n"
"int totalgrp = scaleinfo1.y & 0xffff;\n"
"float factor = as_float(scaleinfo1.w);\n"
"float correction_t = correction[scalei];\n"
"int ystep = (int)(max(2.0f, factor) + 0.5f);\n"
"for (int grploop = get_group_id(0); grploop < totalgrp; grploop += grpnumx)\n"
"{\n"
"int4 cascadeinfo = p[scalei];\n"
"int grpidy = grploop / grpnumperline;\n"
"int grpidx = grploop - mul24(grpidy, grpnumperline);\n"
"int ix = mad24(grpidx, grpszx, lclidx);\n"
"int iy = mad24(grpidy, grpszy, lclidy);\n"
"int x = ix * ystep;\n"
"int y = iy * ystep;\n"
"lcloutindex[lcl_id] = 0;\n"
"lclcount[0] = 0;\n"
"int result = 1, nodecounter;\n"
"float mean, variance_norm_factor;\n"
"{\n"
"const int p_offset = mad24(y, step, x);\n"
"cascadeinfo.x += p_offset;\n"
"cascadeinfo.z += p_offset;\n"
"mean = (sum[mad24(cascadeinfo.y, step, cascadeinfo.x)] - sum[mad24(cascadeinfo.y, step, cascadeinfo.z)] -\n"
"sum[mad24(cascadeinfo.w, step, cascadeinfo.x)] + sum[mad24(cascadeinfo.w, step, cascadeinfo.z)])\n"
"* correction_t;\n"
"variance_norm_factor = sqsum[mad24(cascadeinfo.y, step, cascadeinfo.x)] - sqsum[mad24(cascadeinfo.y, step, cascadeinfo.z)] -\n"
"sqsum[mad24(cascadeinfo.w, step, cascadeinfo.x)] + sqsum[mad24(cascadeinfo.w, step, cascadeinfo.z)];\n"
"variance_norm_factor = variance_norm_factor * correction_t - mean * mean;\n"
"variance_norm_factor = variance_norm_factor >= 0.f ? sqrt(variance_norm_factor) : 1.f;\n"
"result = 1;\n"
"nodecounter = startnode + nodecount * scalei;\n"
"for (int stageloop = start_stage; stageloop < end_stage && result; stageloop++)\n"
"{\n"
"float stage_sum = 0.f;\n"
"int4 stageinfo = *(global int4 *)(stagecascadeptr + stageloop);\n"
"float stagethreshold = as_float(stageinfo.y);\n"
"for (int nodeloop = 0; nodeloop < stageinfo.x; nodeloop++)\n"
"{\n"
"__global GpuHidHaarTreeNode *currentnodeptr = (nodeptr + nodecounter);\n"
"int4 info1 = *(__global int4 *)(&(currentnodeptr->p[0][0]));\n"
"int4 info2 = *(__global int4 *)(&(currentnodeptr->p[1][0]));\n"
"int4 info3 = *(__global int4 *)(&(currentnodeptr->p[2][0]));\n"
"float4 w = *(__global float4 *)(&(currentnodeptr->weight[0]));\n"
"float2 alpha2 = *(__global float2 *)(&(currentnodeptr->alpha[0]));\n"
"float nodethreshold  = w.w * variance_norm_factor;\n"
"info1.x += p_offset;\n"
"info1.z += p_offset;\n"
"info2.x += p_offset;\n"
"info2.z += p_offset;\n"
"float classsum = (sum[mad24(info1.y, step, info1.x)] - sum[mad24(info1.y, step, info1.z)] -\n"
"sum[mad24(info1.w, step, info1.x)] + sum[mad24(info1.w, step, info1.z)]) * w.x;\n"
"classsum += (sum[mad24(info2.y, step, info2.x)] - sum[mad24(info2.y, step, info2.z)] -\n"
"sum[mad24(info2.w, step, info2.x)] + sum[mad24(info2.w, step, info2.z)]) * w.y;\n"
"info3.x += p_offset;\n"
"info3.z += p_offset;\n"
"classsum += (sum[mad24(info3.y, step, info3.x)] - sum[mad24(info3.y, step, info3.z)] -\n"
"sum[mad24(info3.w, step, info3.x)] + sum[mad24(info3.w, step, info3.z)]) * w.z;\n"
"stage_sum += classsum >= nodethreshold ? alpha2.y : alpha2.x;\n"
"nodecounter++;\n"
"}\n"
"result = (stage_sum >= stagethreshold);\n"
"}\n"
"if (result && (ix < width) && (iy < height))\n"
"{\n"
"int queueindex = atomic_inc(lclcount);\n"
"lcloutindex[queueindex << 1] = (y << 16) | x;\n"
"lcloutindex[(queueindex << 1) + 1] = as_int(variance_norm_factor);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int queuecount = lclcount[0];\n"
"nodecounter = splitnode + nodecount * scalei;\n"
"if (lcl_id < queuecount)\n"
"{\n"
"int temp = lcloutindex[lcl_id << 1];\n"
"int x = temp & 0xffff;\n"
"int y = (temp & (int)0xffff0000) >> 16;\n"
"temp = glboutindex[0];\n"
"int4 candidate_result;\n"
"candidate_result.zw = (int2)convert_int_rtn(factor * 20.f);\n"
"candidate_result.x = x;\n"
"candidate_result.y = y;\n"
"atomic_inc(glboutindex);\n"
"candidate[outputoff + temp + lcl_id] = candidate_result;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel void gpuscaleclassifier(global GpuHidHaarTreeNode *orinode, global GpuHidHaarTreeNode *newnode, float scale, float weight_scale, int nodenum)\n"
"{\n"
"int counter = get_global_id(0);\n"
"int tr_x[3], tr_y[3], tr_h[3], tr_w[3], i = 0;\n"
"GpuHidHaarTreeNode t1 = *(orinode + counter);\n"
"#pragma unroll\n"
"for (i = 0; i < 3; i++)\n"
"{\n"
"tr_x[i] = (int)(t1.p[i][0] * scale + 0.5f);\n"
"tr_y[i] = (int)(t1.p[i][1] * scale + 0.5f);\n"
"tr_w[i] = (int)(t1.p[i][2] * scale + 0.5f);\n"
"tr_h[i] = (int)(t1.p[i][3] * scale + 0.5f);\n"
"}\n"
"t1.weight[0] = t1.p[2][0] ? -(t1.weight[1] * tr_h[1] * tr_w[1] + t1.weight[2] * tr_h[2] * tr_w[2]) / (tr_h[0] * tr_w[0]) : -t1.weight[1] * tr_h[1] * tr_w[1] / (tr_h[0] * tr_w[0]);\n"
"counter += nodenum;\n"
"#pragma unroll\n"
"for (i = 0; i < 3; i++)\n"
"{\n"
"newnode[counter].p[i][0] = tr_x[i];\n"
"newnode[counter].p[i][1] = tr_y[i];\n"
"newnode[counter].p[i][2] = tr_x[i] + tr_w[i];\n"
"newnode[counter].p[i][3] = tr_y[i] + tr_h[i];\n"
"newnode[counter].weight[i] = t1.weight[i] * weight_scale;\n"
"}\n"
"newnode[counter].left = t1.left;\n"
"newnode[counter].right = t1.right;\n"
"newnode[counter].threshold = t1.threshold;\n"
"newnode[counter].alpha[0] = t1.alpha[0];\n"
"newnode[counter].alpha[1] = t1.alpha[1];\n"
"}\n"
;
const char* imgproc_bilateral="__kernel void bilateral_C1_D0(__global uchar *dst,\n"
"__global const uchar *src,\n"
"const int dst_rows,\n"
"const int dst_cols,\n"
"const int maxk,\n"
"const int radius,\n"
"const int dst_step,\n"
"const int dst_offset,\n"
"const int src_step,\n"
"const int src_rows,\n"
"const int src_cols,\n"
"__constant float *color_weight,\n"
"__constant float *space_weight,\n"
"__constant int *space_ofs)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"if((gidy<dst_rows) && (gidx<dst_cols))\n"
"{\n"
"int src_addr = mad24(gidy+radius,src_step,gidx+radius);\n"
"int dst_addr = mad24(gidy,dst_step,gidx+dst_offset);\n"
"float sum = 0.f, wsum = 0.f;\n"
"int val0 = (int)src[src_addr];\n"
"for(int k = 0; k < maxk; k++ )\n"
"{\n"
"int val = (int)src[src_addr + space_ofs[k]];\n"
"float w = space_weight[k]*color_weight[abs(val - val0)];\n"
"sum += (float)(val)*w;\n"
"wsum += w;\n"
"}\n"
"dst[dst_addr] = convert_uchar_rtz(sum/wsum+0.5f);\n"
"}\n"
"}\n"
"__kernel void bilateral2_C1_D0(__global uchar *dst,\n"
"__global const uchar *src,\n"
"const int dst_rows,\n"
"const int dst_cols,\n"
"const int maxk,\n"
"const int radius,\n"
"const int dst_step,\n"
"const int dst_offset,\n"
"const int src_step,\n"
"const int src_rows,\n"
"const int src_cols,\n"
"__constant float *color_weight,\n"
"__constant float *space_weight,\n"
"__constant int *space_ofs)\n"
"{\n"
"int gidx = get_global_id(0)<<2;\n"
"int gidy = get_global_id(1);\n"
"if((gidy<dst_rows) && (gidx<dst_cols))\n"
"{\n"
"int src_addr = mad24(gidy+radius,src_step,gidx+radius);\n"
"int dst_addr = mad24(gidy,dst_step,gidx+dst_offset);\n"
"float4 sum = (float4)(0.f), wsum = (float4)(0.f);\n"
"int4 val0 = convert_int4(vload4(0,src+src_addr));\n"
"for(int k = 0; k < maxk; k++ )\n"
"{\n"
"int4 val = convert_int4(vload4(0,src+src_addr + space_ofs[k]));\n"
"float4 w = (float4)(space_weight[k])*(float4)(color_weight[abs(val.x - val0.x)],color_weight[abs(val.y - val0.y)],color_weight[abs(val.z - val0.z)],color_weight[abs(val.w - val0.w)]);\n"
"sum += convert_float4(val)*w;\n"
"wsum += w;\n"
"}\n"
"*(__global uchar4*)(dst+dst_addr) = convert_uchar4_rtz(sum/wsum+0.5f);\n"
"}\n"
"}\n"
"__kernel void bilateral_C4_D0(__global uchar4 *dst,\n"
"__global const uchar4 *src,\n"
"const int dst_rows,\n"
"const int dst_cols,\n"
"const int maxk,\n"
"const int radius,\n"
"const int dst_step,\n"
"const int dst_offset,\n"
"const int src_step,\n"
"const int src_rows,\n"
"const int src_cols,\n"
"__constant float *color_weight,\n"
"__constant float *space_weight,\n"
"__constant int *space_ofs)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"if((gidy<dst_rows) && (gidx<dst_cols))\n"
"{\n"
"int src_addr = mad24(gidy+radius,src_step,gidx+radius);\n"
"int dst_addr = mad24(gidy,dst_step,gidx+dst_offset);\n"
"float4 sum = (float4)0.f;\n"
"float wsum = 0.f;\n"
"int4 val0 = convert_int4(src[src_addr]);\n"
"for(int k = 0; k < maxk; k++ )\n"
"{\n"
"int4 val = convert_int4(src[src_addr + space_ofs[k]]);\n"
"float w = space_weight[k]*color_weight[abs(val.x - val0.x)+abs(val.y - val0.y)+abs(val.z - val0.z)];\n"
"sum += convert_float4(val)*(float4)w;\n"
"wsum += w;\n"
"}\n"
"wsum=1.f/wsum;\n"
"dst[dst_addr] = convert_uchar4_rtz(sum*(float4)wsum+(float4)0.5f);\n"
"}\n"
"}\n"
;
const char* imgproc_calcHarris="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (t_edge)   :(i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (b_edge)-1 :(addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)-1 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-1+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT101\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)                 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-2+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (i)+(b_edge) : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (i)-(b_edge) : (addr))\n"
"#endif\n"
"#define THREADS 256\n"
"#define ELEM(i, l_edge, r_edge, elem1, elem2) (i) >= (l_edge) && (i) < (r_edge) ? (elem1) : (elem2)\n"
"__kernel void calcHarris(__global const float *Dx,__global const float *Dy, __global float *dst,\n"
"int dx_offset, int dx_whole_rows, int dx_whole_cols, int dx_step,\n"
"int dy_offset, int dy_whole_rows, int dy_whole_cols, int dy_step,\n"
"int dst_offset, int dst_rows, int dst_cols, int dst_step,\n"
"float k)\n"
"{\n"
"int col = get_local_id(0);\n"
"const int gX = get_group_id(0);\n"
"const int gY = get_group_id(1);\n"
"const int glx = get_global_id(0);\n"
"const int gly = get_global_id(1);\n"
"int dx_x_off = (dx_offset % dx_step) >> 2;\n"
"int dx_y_off = dx_offset / dx_step;\n"
"int dy_x_off = (dy_offset % dy_step) >> 2;\n"
"int dy_y_off = dy_offset / dy_step;\n"
"int dst_x_off = (dst_offset % dst_step) >> 2;\n"
"int dst_y_off = dst_offset / dst_step;\n"
"int dx_startX = gX * (THREADS-ksX+1) - anX + dx_x_off;\n"
"int dx_startY = (gY << 1) - anY + dx_y_off;\n"
"int dy_startX = gX * (THREADS-ksX+1) - anX + dy_x_off;\n"
"int dy_startY = (gY << 1) - anY + dy_y_off;\n"
"int dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\n"
"int dst_startY = (gY << 1) + dst_y_off;\n"
"float dx_data[ksY+1],dy_data[ksY+1],data[3][ksY+1];\n"
"__local float temp[6][THREADS];\n"
"#ifdef BORDER_CONSTANT\n"
"bool dx_con,dy_con;\n"
"float dx_s,dy_s;\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"dx_con = dx_startX+col >= 0 && dx_startX+col < dx_whole_cols && dx_startY+i >= 0 && dx_startY+i < dx_whole_rows;\n"
"dx_s = Dx[(dx_startY+i)*(dx_step>>2)+(dx_startX+col)];\n"
"dx_data[i] = dx_con ? dx_s : 0.0;\n"
"dy_con = dy_startX+col >= 0 && dy_startX+col < dy_whole_cols && dy_startY+i >= 0 && dy_startY+i < dy_whole_rows;\n"
"dy_s = Dy[(dy_startY+i)*(dy_step>>2)+(dy_startX+col)];\n"
"dy_data[i] = dy_con ? dy_s : 0.0;\n"
"data[0][i] = dx_data[i] * dx_data[i];\n"
"data[1][i] = dx_data[i] * dy_data[i];\n"
"data[2][i] = dy_data[i] * dy_data[i];\n"
"}\n"
"#else\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"int dx_selected_row;\n"
"int dx_selected_col;\n"
"dx_selected_row = ADDR_H(dx_startY+i, 0, dx_whole_rows);\n"
"dx_selected_row = ADDR_B(dx_startY+i, dx_whole_rows, dx_selected_row);\n"
"dx_selected_col = ADDR_L(dx_startX+col, 0, dx_whole_cols);\n"
"dx_selected_col = ADDR_R(dx_startX+col, dx_whole_cols, dx_selected_col);\n"
"dx_data[i] = Dx[dx_selected_row * (dx_step>>2) + dx_selected_col];\n"
"int dy_selected_row;\n"
"int dy_selected_col;\n"
"dy_selected_row = ADDR_H(dy_startY+i, 0, dy_whole_rows);\n"
"dy_selected_row = ADDR_B(dy_startY+i, dy_whole_rows, dy_selected_row);\n"
"dy_selected_col = ADDR_L(dy_startX+col, 0, dy_whole_cols);\n"
"dy_selected_col = ADDR_R(dy_startX+col, dy_whole_cols, dy_selected_col);\n"
"dy_data[i] = Dy[dy_selected_row * (dy_step>>2) + dy_selected_col];\n"
"data[0][i] = dx_data[i] * dx_data[i];\n"
"data[1][i] = dx_data[i] * dy_data[i];\n"
"data[2][i] = dy_data[i] * dy_data[i];\n"
"}\n"
"#endif\n"
"float sum0 = 0.0, sum1 = 0.0, sum2 = 0.0;\n"
"for(int i=1; i < ksY; i++)\n"
"{\n"
"sum0 += (data[0][i]);\n"
"sum1 += (data[1][i]);\n"
"sum2 += (data[2][i]);\n"
"}\n"
"float sum01,sum02,sum11,sum12,sum21,sum22;\n"
"sum01 = sum0 + (data[0][0]);\n"
"sum02 = sum0 + (data[0][ksY]);\n"
"temp[0][col] = sum01;\n"
"temp[1][col] = sum02;\n"
"sum11 = sum1 + (data[1][0]);\n"
"sum12 = sum1 + (data[1][ksY]);\n"
"temp[2][col] = sum11;\n"
"temp[3][col] = sum12;\n"
"sum21 = sum2 + (data[2][0]);\n"
"sum22 = sum2 + (data[2][ksY]);\n"
"temp[4][col] = sum21;\n"
"temp[5][col] = sum22;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(col < (THREADS-(ksX-1)))\n"
"{\n"
"col += anX;\n"
"int posX = dst_startX - dst_x_off + col - anX;\n"
"int posY = (gly << 1);\n"
"int till = (ksX + 1)%2;\n"
"float tmp_sum[6]={ 0.0, 0.0 , 0.0, 0.0, 0.0, 0.0 };\n"
"for(int k=0; k<6; k++)\n"
"for(int i=-anX; i<=anX - till; i++)\n"
"{\n"
"tmp_sum[k] += temp[k][col+i];\n"
"}\n"
"if(posX < dst_cols && (posY) < dst_rows)\n"
"{\n"
"dst[(dst_startY+0) * (dst_step>>2)+ dst_startX + col - anX] =\n"
"tmp_sum[0] * tmp_sum[4] - tmp_sum[2] * tmp_sum[2] - k * (tmp_sum[0] + tmp_sum[4]) * (tmp_sum[0] + tmp_sum[4]);\n"
"}\n"
"if(posX < dst_cols && (posY + 1) < dst_rows)\n"
"{\n"
"dst[(dst_startY+1) * (dst_step>>2)+ dst_startX + col - anX] =\n"
"tmp_sum[1] * tmp_sum[5] - tmp_sum[3] * tmp_sum[3] - k * (tmp_sum[1] + tmp_sum[5]) * (tmp_sum[1] + tmp_sum[5]);\n"
"}\n"
"}\n"
"}\n"
;
const char* imgproc_calcMinEigenVal="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (t_edge)   :(i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (b_edge)-1 :(addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)-1 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-1+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT101\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)                 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-2+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (i)+(b_edge) : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (i)-(b_edge) : (addr))\n"
"#endif\n"
"#define THREADS 256\n"
"#define ELEM(i, l_edge, r_edge, elem1, elem2) (i) >= (l_edge) && (i) < (r_edge) ? (elem1) : (elem2)\n"
"__kernel void calcMinEigenVal(__global const float *Dx,__global const float *Dy, __global float *dst,\n"
"int dx_offset, int dx_whole_rows, int dx_whole_cols, int dx_step,\n"
"int dy_offset, int dy_whole_rows, int dy_whole_cols, int dy_step,\n"
"int dst_offset, int dst_rows, int dst_cols, int dst_step,\n"
"float k)\n"
"{\n"
"int col = get_local_id(0);\n"
"const int gX = get_group_id(0);\n"
"const int gY = get_group_id(1);\n"
"const int glx = get_global_id(0);\n"
"const int gly = get_global_id(1);\n"
"int dx_x_off = (dx_offset % dx_step) >> 2;\n"
"int dx_y_off = dx_offset / dx_step;\n"
"int dy_x_off = (dy_offset % dy_step) >> 2;\n"
"int dy_y_off = dy_offset / dy_step;\n"
"int dst_x_off = (dst_offset % dst_step) >> 2;\n"
"int dst_y_off = dst_offset / dst_step;\n"
"int dx_startX = gX * (THREADS-ksX+1) - anX + dx_x_off;\n"
"int dx_startY = (gY << 1) - anY + dx_y_off;\n"
"int dy_startX = gX * (THREADS-ksX+1) - anX + dy_x_off;\n"
"int dy_startY = (gY << 1) - anY + dy_y_off;\n"
"int dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\n"
"int dst_startY = (gY << 1) + dst_y_off;\n"
"float dx_data[ksY+1],dy_data[ksY+1],data[3][ksY+1];\n"
"__local float temp[6][THREADS];\n"
"#ifdef BORDER_CONSTANT\n"
"bool dx_con,dy_con;\n"
"float dx_s,dy_s;\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"dx_con = dx_startX+col >= 0 && dx_startX+col < dx_whole_cols && dx_startY+i >= 0 && dx_startY+i < dx_whole_rows;\n"
"dx_s = Dx[(dx_startY+i)*(dx_step>>2)+(dx_startX+col)];\n"
"dx_data[i] = dx_con ? dx_s : 0.0;\n"
"dy_con = dy_startX+col >= 0 && dy_startX+col < dy_whole_cols && dy_startY+i >= 0 && dy_startY+i < dy_whole_rows;\n"
"dy_s = Dy[(dy_startY+i)*(dy_step>>2)+(dy_startX+col)];\n"
"dy_data[i] = dy_con ? dy_s : 0.0;\n"
"data[0][i] = dx_data[i] * dx_data[i];\n"
"data[1][i] = dx_data[i] * dy_data[i];\n"
"data[2][i] = dy_data[i] * dy_data[i];\n"
"}\n"
"#else\n"
"for(int i=0; i < ksY+1; i++)\n"
"{\n"
"int dx_selected_row;\n"
"int dx_selected_col;\n"
"dx_selected_row = ADDR_H(dx_startY+i, 0, dx_whole_rows);\n"
"dx_selected_row = ADDR_B(dx_startY+i, dx_whole_rows, dx_selected_row);\n"
"dx_selected_col = ADDR_L(dx_startX+col, 0, dx_whole_cols);\n"
"dx_selected_col = ADDR_R(dx_startX+col, dx_whole_cols, dx_selected_col);\n"
"dx_data[i] = Dx[dx_selected_row * (dx_step>>2) + dx_selected_col];\n"
"int dy_selected_row;\n"
"int dy_selected_col;\n"
"dy_selected_row = ADDR_H(dy_startY+i, 0, dy_whole_rows);\n"
"dy_selected_row = ADDR_B(dy_startY+i, dy_whole_rows, dy_selected_row);\n"
"dy_selected_col = ADDR_L(dy_startX+col, 0, dy_whole_cols);\n"
"dy_selected_col = ADDR_R(dy_startX+col, dy_whole_cols, dy_selected_col);\n"
"dy_data[i] = Dy[dy_selected_row * (dy_step>>2) + dy_selected_col];\n"
"data[0][i] = dx_data[i] * dx_data[i];\n"
"data[1][i] = dx_data[i] * dy_data[i];\n"
"data[2][i] = dy_data[i] * dy_data[i];\n"
"}\n"
"#endif\n"
"float sum0 = 0.0, sum1 = 0.0, sum2 = 0.0;\n"
"for(int i=1; i < ksY; i++)\n"
"{\n"
"sum0 += (data[0][i]);\n"
"sum1 += (data[1][i]);\n"
"sum2 += (data[2][i]);\n"
"}\n"
"float sum01,sum02,sum11,sum12,sum21,sum22;\n"
"sum01 = sum0 + (data[0][0]);\n"
"sum02 = sum0 + (data[0][ksY]);\n"
"temp[0][col] = sum01;\n"
"temp[1][col] = sum02;\n"
"sum11 = sum1 + (data[1][0]);\n"
"sum12 = sum1 + (data[1][ksY]);\n"
"temp[2][col] = sum11;\n"
"temp[3][col] = sum12;\n"
"sum21 = sum2 + (data[2][0]);\n"
"sum22 = sum2 + (data[2][ksY]);\n"
"temp[4][col] = sum21;\n"
"temp[5][col] = sum22;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(col < (THREADS-(ksX-1)))\n"
"{\n"
"col += anX;\n"
"int posX = dst_startX - dst_x_off + col - anX;\n"
"int posY = (gly << 1);\n"
"int till = (ksX + 1)%2;\n"
"float tmp_sum[6]={ 0.0, 0.0 , 0.0, 0.0, 0.0, 0.0 };\n"
"for(int k=0; k<6; k++)\n"
"for(int i=-anX; i<=anX - till; i++)\n"
"{\n"
"tmp_sum[k] += temp[k][col+i];\n"
"}\n"
"if(posX < dst_cols && (posY) < dst_rows)\n"
"{\n"
"float a = tmp_sum[0] * 0.5f;\n"
"float b = tmp_sum[2];\n"
"float c = tmp_sum[4] * 0.5f;\n"
"dst[(dst_startY+0) * (dst_step>>2)+ dst_startX + col - anX] = (float)((a+c) - sqrt((a-c)*(a-c) + b*b));\n"
"}\n"
"if(posX < dst_cols && (posY + 1) < dst_rows)\n"
"{\n"
"float a = tmp_sum[1] * 0.5f;\n"
"float b = tmp_sum[3];\n"
"float c = tmp_sum[5] * 0.5f;\n"
"dst[(dst_startY+1) * (dst_step>>2)+ dst_startX + col - anX] = (float)((a+c) - sqrt((a-c)*(a-c) + b*b));\n"
"}\n"
"}\n"
"}\n"
;
const char* imgproc_canny="#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n"
"#ifdef L2GRAD\n"
"inline float calc(int x, int y)\n"
"{\n"
"return sqrt((float)(x * x + y * y));\n"
"}\n"
"#else\n"
"inline float calc(int x, int y)\n"
"{\n"
"return (float)abs(x) + abs(y);\n"
"}\n"
"#endif\n"
"__kernel\n"
"void calcSobelRowPass\n"
"(\n"
"__global const uchar * src,\n"
"__global int * dx_buf,\n"
"__global int * dy_buf,\n"
"int rows,\n"
"int cols,\n"
"int src_step,\n"
"int src_offset,\n"
"int dx_buf_step,\n"
"int dx_buf_offset,\n"
"int dy_buf_step,\n"
"int dy_buf_offset\n"
")\n"
"{\n"
"dx_buf_step   /= sizeof(*dx_buf);\n"
"dx_buf_offset /= sizeof(*dx_buf);\n"
"dy_buf_step   /= sizeof(*dy_buf);\n"
"dy_buf_offset /= sizeof(*dy_buf);\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"__local int smem[16][18];\n"
"smem[lidy][lidx + 1] = src[gidx + gidy * src_step + src_offset];\n"
"if(lidx == 0)\n"
"{\n"
"smem[lidy][0]  = src[max(gidx - 1,  0)        + gidy * src_step + src_offset];\n"
"smem[lidy][17] = src[min(gidx + 16, cols - 1) + gidy * src_step + src_offset];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gidy < rows)\n"
"{\n"
"if(gidx < cols)\n"
"{\n"
"dx_buf[gidx + gidy * dx_buf_step + dx_buf_offset] =\n"
"-smem[lidy][lidx] + smem[lidy][lidx + 2];\n"
"dy_buf[gidx + gidy * dy_buf_step + dy_buf_offset] =\n"
"smem[lidy][lidx] + 2 * smem[lidy][lidx + 1] + smem[lidy][lidx + 2];\n"
"}\n"
"}\n"
"}\n"
"__kernel\n"
"void calcMagnitude_buf\n"
"(\n"
"__global const int * dx_buf,\n"
"__global const int * dy_buf,\n"
"__global int * dx,\n"
"__global int * dy,\n"
"__global float * mag,\n"
"int rows,\n"
"int cols,\n"
"int dx_buf_step,\n"
"int dx_buf_offset,\n"
"int dy_buf_step,\n"
"int dy_buf_offset,\n"
"int dx_step,\n"
"int dx_offset,\n"
"int dy_step,\n"
"int dy_offset,\n"
"int mag_step,\n"
"int mag_offset\n"
")\n"
"{\n"
"dx_buf_step    /= sizeof(*dx_buf);\n"
"dx_buf_offset  /= sizeof(*dx_buf);\n"
"dy_buf_step    /= sizeof(*dy_buf);\n"
"dy_buf_offset  /= sizeof(*dy_buf);\n"
"dx_step    /= sizeof(*dx);\n"
"dx_offset  /= sizeof(*dx);\n"
"dy_step    /= sizeof(*dy);\n"
"dy_offset  /= sizeof(*dy);\n"
"mag_step   /= sizeof(*mag);\n"
"mag_offset /= sizeof(*mag);\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"__local int sdx[18][16];\n"
"__local int sdy[18][16];\n"
"sdx[lidy + 1][lidx] = dx_buf[gidx + gidy * dx_buf_step + dx_buf_offset];\n"
"sdy[lidy + 1][lidx] = dy_buf[gidx + gidy * dy_buf_step + dy_buf_offset];\n"
"if(lidy == 0)\n"
"{\n"
"sdx[0][lidx]  = dx_buf[gidx + max(gidy - 1,  0)        * dx_buf_step + dx_buf_offset];\n"
"sdx[17][lidx] = dx_buf[gidx + min(gidy + 16, rows - 1) * dx_buf_step + dx_buf_offset];\n"
"sdy[0][lidx]  = dy_buf[gidx + max(gidy - 1,  0)        * dy_buf_step + dy_buf_offset];\n"
"sdy[17][lidx] = dy_buf[gidx + min(gidy + 16, rows - 1) * dy_buf_step + dy_buf_offset];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gidx < cols)\n"
"{\n"
"if(gidy < rows)\n"
"{\n"
"int x =  sdx[lidy][lidx] + 2 * sdx[lidy + 1][lidx] + sdx[lidy + 2][lidx];\n"
"int y = -sdy[lidy][lidx] + sdy[lidy + 2][lidx];\n"
"dx[gidx + gidy * dx_step + dx_offset] = x;\n"
"dy[gidx + gidy * dy_step + dy_offset] = y;\n"
"mag[(gidx + 1) + (gidy + 1) * mag_step + mag_offset] = calc(x, y);\n"
"}\n"
"}\n"
"}\n"
"__kernel\n"
"void calcMagnitude\n"
"(\n"
"__global const int * dx,\n"
"__global const int * dy,\n"
"__global float * mag,\n"
"int rows,\n"
"int cols,\n"
"int dx_step,\n"
"int dx_offset,\n"
"int dy_step,\n"
"int dy_offset,\n"
"int mag_step,\n"
"int mag_offset\n"
")\n"
"{\n"
"dx_step    /= sizeof(*dx);\n"
"dx_offset  /= sizeof(*dx);\n"
"dy_step    /= sizeof(*dy);\n"
"dy_offset  /= sizeof(*dy);\n"
"mag_step   /= sizeof(*mag);\n"
"mag_offset /= sizeof(*mag);\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"if(gidy < rows && gidx < cols)\n"
"{\n"
"mag[(gidx + 1) + (gidy + 1) * mag_step + mag_offset] =\n"
"calc(\n"
"dx[gidx + gidy * dx_step + dx_offset],\n"
"dy[gidx + gidy * dy_step + dy_offset]\n"
");\n"
"}\n"
"}\n"
"#define CANNY_SHIFT 15\n"
"#define TG22        (int)(0.4142135623730950488016887242097*(1<<CANNY_SHIFT) + 0.5)\n"
"__kernel\n"
"void calcMap\n"
"(\n"
"__global const int * dx,\n"
"__global const int * dy,\n"
"__global const float * mag,\n"
"__global int * map,\n"
"int rows,\n"
"int cols,\n"
"float low_thresh,\n"
"float high_thresh,\n"
"int dx_step,\n"
"int dx_offset,\n"
"int dy_step,\n"
"int dy_offset,\n"
"int mag_step,\n"
"int mag_offset,\n"
"int map_step,\n"
"int map_offset\n"
")\n"
"{\n"
"dx_step    /= sizeof(*dx);\n"
"dx_offset  /= sizeof(*dx);\n"
"dy_step    /= sizeof(*dy);\n"
"dy_offset  /= sizeof(*dy);\n"
"mag_step   /= sizeof(*mag);\n"
"mag_offset /= sizeof(*mag);\n"
"map_step   /= sizeof(*map);\n"
"map_offset /= sizeof(*map);\n"
"__local float smem[18][18];\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"int grp_idx = get_global_id(0) & 0xFFFFF0;\n"
"int grp_idy = get_global_id(1) & 0xFFFFF0;\n"
"int tid = lidx + lidy * 16;\n"
"int lx = tid % 18;\n"
"int ly = tid / 18;\n"
"if(ly < 14)\n"
"{\n"
"smem[ly][lx] = mag[grp_idx + lx + (grp_idy + ly) * mag_step];\n"
"}\n"
"if(ly < 4 && grp_idy + ly + 14 <= rows && grp_idx + lx <= cols)\n"
"{\n"
"smem[ly + 14][lx] = mag[grp_idx + lx + (grp_idy + ly + 14) * mag_step];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gidy < rows && gidx < cols)\n"
"{\n"
"int x = dx[gidx + gidy * dx_step];\n"
"int y = dy[gidx + gidy * dy_step];\n"
"const int s = (x ^ y) < 0 ? -1 : 1;\n"
"const float m = smem[lidy + 1][lidx + 1];\n"
"x = abs(x);\n"
"y = abs(y);\n"
"int edge_type = 0;\n"
"if(m > low_thresh)\n"
"{\n"
"const int tg22x = x * TG22;\n"
"const int tg67x = tg22x + (x << (1 + CANNY_SHIFT));\n"
"y <<= CANNY_SHIFT;\n"
"if(y < tg22x)\n"
"{\n"
"if(m > smem[lidy + 1][lidx] && m >= smem[lidy + 1][lidx + 2])\n"
"{\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"else if (y > tg67x)\n"
"{\n"
"if(m > smem[lidy][lidx + 1]&& m >= smem[lidy + 2][lidx + 1])\n"
"{\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"else\n"
"{\n"
"if(m > smem[lidy][lidx + 1 - s]&& m > smem[lidy + 2][lidx + 1 + s])\n"
"{\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"}\n"
"map[gidx + 1 + (gidy + 1) * map_step] = edge_type;\n"
"}\n"
"}\n"
"__kernel\n"
"void calcMap_2\n"
"(\n"
"__global const int * dx,\n"
"__global const int * dy,\n"
"__global const float * mag,\n"
"__global int * map,\n"
"int rows,\n"
"int cols,\n"
"float low_thresh,\n"
"float high_thresh,\n"
"int dx_step,\n"
"int dx_offset,\n"
"int dy_step,\n"
"int dy_offset,\n"
"int mag_step,\n"
"int mag_offset,\n"
"int map_step,\n"
"int map_offset\n"
")\n"
"{\n"
"dx_step    /= sizeof(*dx);\n"
"dx_offset  /= sizeof(*dx);\n"
"dy_step    /= sizeof(*dy);\n"
"dy_offset  /= sizeof(*dy);\n"
"mag_step   /= sizeof(*mag);\n"
"mag_offset /= sizeof(*mag);\n"
"map_step   /= sizeof(*map);\n"
"map_offset /= sizeof(*map);\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"if(gidy < rows && gidx < cols)\n"
"{\n"
"int x = dx[gidx + gidy * dx_step];\n"
"int y = dy[gidx + gidy * dy_step];\n"
"const int s = (x ^ y) < 0 ? -1 : 1;\n"
"const float m = mag[gidx + 1 + (gidy + 1) * mag_step];\n"
"x = abs(x);\n"
"y = abs(y);\n"
"int edge_type = 0;\n"
"if(m > low_thresh)\n"
"{\n"
"const int tg22x = x * TG22;\n"
"const int tg67x = tg22x + (x << (1 + CANNY_SHIFT));\n"
"y <<= CANNY_SHIFT;\n"
"if(y < tg22x)\n"
"{\n"
"if(m > mag[gidx + (gidy + 1) * mag_step] && m >= mag[gidx + 2 + (gidy + 1) * mag_step])\n"
"{\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"else if (y > tg67x)\n"
"{\n"
"if(m > mag[gidx + 1 + gidy* mag_step] && m >= mag[gidx + 1 + (gidy + 2) * mag_step])\n"
"{\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"else\n"
"{\n"
"if(m > mag[gidx + 1 - s + gidy * mag_step] && m > mag[gidx + 1 + s + (gidy + 2) * mag_step])\n"
"{\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"}\n"
"map[gidx + 1 + (gidy + 1) * map_step] = edge_type;\n"
"}\n"
"}\n"
"__kernel\n"
"void calcMap_3\n"
"(\n"
"__global const int * dx,\n"
"__global const int * dy,\n"
"__global const float * mag,\n"
"__global int * map,\n"
"int rows,\n"
"int cols,\n"
"float low_thresh,\n"
"float high_thresh,\n"
"int dx_step,\n"
"int dx_offset,\n"
"int dy_step,\n"
"int dy_offset,\n"
"int mag_step,\n"
"int mag_offset,\n"
"int map_step,\n"
"int map_offset\n"
")\n"
"{\n"
"dx_step    /= sizeof(*dx);\n"
"dx_offset  /= sizeof(*dx);\n"
"dy_step    /= sizeof(*dy);\n"
"dy_offset  /= sizeof(*dy);\n"
"mag_step   /= sizeof(*mag);\n"
"mag_offset /= sizeof(*mag);\n"
"map_step   /= sizeof(*map);\n"
"map_offset /= sizeof(*map);\n"
"__local float smem[18][18];\n"
"int lidx = get_local_id(0) % 16;\n"
"int lidy = get_local_id(0) / 16;\n"
"int grp_pix = get_global_id(0);\n"
"int grp_ind = get_global_id(1);\n"
"int grp_idx = (grp_ind % (cols/16)) * 16;\n"
"int grp_idy = (grp_ind / (cols/16)) * 16;\n"
"int gidx = grp_idx + lidx;\n"
"int gidy = grp_idy + lidy;\n"
"int tid = get_global_id(0) % 256;\n"
"int lx = tid % 18;\n"
"int ly = tid / 18;\n"
"if(ly < 14)\n"
"{\n"
"smem[ly][lx] = mag[grp_idx + lx + (grp_idy + ly) * mag_step];\n"
"}\n"
"if(ly < 4 && grp_idy + ly + 14 <= rows && grp_idx + lx <= cols)\n"
"{\n"
"smem[ly + 14][lx] = mag[grp_idx + lx + (grp_idy + ly + 14) * mag_step];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gidy < rows && gidx < cols)\n"
"{\n"
"int x = dx[gidx + gidy * dx_step];\n"
"int y = dy[gidx + gidy * dy_step];\n"
"const int s = (x ^ y) < 0 ? -1 : 1;\n"
"const float m = smem[lidy + 1][lidx + 1];\n"
"x = abs(x);\n"
"y = abs(y);\n"
"int edge_type = 0;\n"
"if(m > low_thresh)\n"
"{\n"
"const int tg22x = x * TG22;\n"
"const int tg67x = tg22x + (x << (1 + CANNY_SHIFT));\n"
"y <<= CANNY_SHIFT;\n"
"if(y < tg22x)\n"
"{\n"
"if(m > smem[lidy + 1][lidx] && m >= smem[lidy + 1][lidx + 2])\n"
"{\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"else if (y > tg67x)\n"
"{\n"
"if(m > smem[lidy][lidx + 1]&& m >= smem[lidy + 2][lidx + 1])\n"
"{\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"else\n"
"{\n"
"if(m > smem[lidy][lidx + 1 - s]&& m > smem[lidy + 2][lidx + 1 + s])\n"
"{\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"}\n"
"map[gidx + 1 + (gidy + 1) * map_step] = edge_type;\n"
"}\n"
"}\n"
"#undef CANNY_SHIFT\n"
"#undef TG22\n"
"__kernel\n"
"void edgesHysteresisLocal\n"
"(\n"
"__global int * map,\n"
"__global ushort2 * st,\n"
"volatile __global unsigned int * counter,\n"
"int rows,\n"
"int cols,\n"
"int map_step,\n"
"int map_offset\n"
")\n"
"{\n"
"map_step   /= sizeof(*map);\n"
"map_offset /= sizeof(*map);\n"
"__local int smem[18][18];\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"int grp_idx = get_global_id(0) & 0xFFFFF0;\n"
"int grp_idy = get_global_id(1) & 0xFFFFF0;\n"
"int tid = lidx + lidy * 16;\n"
"int lx = tid % 18;\n"
"int ly = tid / 18;\n"
"if(ly < 14)\n"
"{\n"
"smem[ly][lx] = map[grp_idx + lx + (grp_idy + ly) * map_step + map_offset];\n"
"}\n"
"if(ly < 4 && grp_idy + ly + 14 <= rows && grp_idx + lx <= cols)\n"
"{\n"
"smem[ly + 14][lx] = map[grp_idx + lx + (grp_idy + ly + 14) * map_step + map_offset];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gidy < rows && gidx < cols)\n"
"{\n"
"int n;\n"
"#pragma unroll\n"
"for (int k = 0; k < 16; ++k)\n"
"{\n"
"n = 0;\n"
"if (smem[lidy + 1][lidx + 1] == 1)\n"
"{\n"
"n += smem[lidy    ][lidx    ] == 2;\n"
"n += smem[lidy    ][lidx + 1] == 2;\n"
"n += smem[lidy    ][lidx + 2] == 2;\n"
"n += smem[lidy + 1][lidx    ] == 2;\n"
"n += smem[lidy + 1][lidx + 2] == 2;\n"
"n += smem[lidy + 2][lidx    ] == 2;\n"
"n += smem[lidy + 2][lidx + 1] == 2;\n"
"n += smem[lidy + 2][lidx + 2] == 2;\n"
"}\n"
"if (n > 0)\n"
"smem[lidy + 1][lidx + 1] = 2;\n"
"}\n"
"const int e = smem[lidy + 1][lidx + 1];\n"
"map[gidx + 1 + (gidy + 1) * map_step] = e;\n"
"n = 0;\n"
"if(e == 2)\n"
"{\n"
"n += smem[lidy    ][lidx    ] == 1;\n"
"n += smem[lidy    ][lidx + 1] == 1;\n"
"n += smem[lidy    ][lidx + 2] == 1;\n"
"n += smem[lidy + 1][lidx    ] == 1;\n"
"n += smem[lidy + 1][lidx + 2] == 1;\n"
"n += smem[lidy + 2][lidx    ] == 1;\n"
"n += smem[lidy + 2][lidx + 1] == 1;\n"
"n += smem[lidy + 2][lidx + 2] == 1;\n"
"}\n"
"if(n > 0)\n"
"{\n"
"unsigned int ind = atomic_inc(counter);\n"
"st[ind] = (ushort2)(gidx + 1, gidy + 1);\n"
"}\n"
"}\n"
"}\n"
"__constant int c_dx[8] = {-1,  0,  1, -1, 1, -1, 0, 1};\n"
"__constant int c_dy[8] = {-1, -1, -1,  0, 0,  1, 1, 1};\n"
"#define stack_size 512\n"
"__kernel\n"
"void edgesHysteresisGlobal\n"
"(\n"
"__global int * map,\n"
"__global ushort2 * st1,\n"
"__global ushort2 * st2,\n"
"volatile __global int * counter,\n"
"int rows,\n"
"int cols,\n"
"int count,\n"
"int map_step,\n"
"int map_offset\n"
")\n"
"{\n"
"map_step   /= sizeof(*map);\n"
"map_offset /= sizeof(*map);\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"int grp_idx = get_group_id(0);\n"
"int grp_idy = get_group_id(1);\n"
"volatile __local unsigned int s_counter;\n"
"__local unsigned int s_ind;\n"
"__local ushort2 s_st[stack_size];\n"
"if(lidx == 0)\n"
"{\n"
"s_counter = 0;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ind = mad24(grp_idy, (int)get_local_size(0), grp_idx);\n"
"if(ind < count)\n"
"{\n"
"ushort2 pos = st1[ind];\n"
"if (pos.x > 0 && pos.x <= cols && pos.y > 0 && pos.y <= rows)\n"
"{\n"
"if (lidx < 8)\n"
"{\n"
"pos.x += c_dx[lidx];\n"
"pos.y += c_dy[lidx];\n"
"if (map[pos.x + pos.y * map_step] == 1)\n"
"{\n"
"map[pos.x + pos.y * map_step] = 2;\n"
"ind = atomic_inc(&s_counter);\n"
"s_st[ind] = pos;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"while (s_counter > 0 && s_counter <= stack_size - get_local_size(0))\n"
"{\n"
"const int subTaskIdx = lidx >> 3;\n"
"const int portion = min(s_counter, get_local_size(0)>> 3);\n"
"pos.x = pos.y = 0;\n"
"if (subTaskIdx < portion)\n"
"pos = s_st[s_counter - 1 - subTaskIdx];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lidx == 0)\n"
"s_counter -= portion;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (pos.x > 0 && pos.x <= cols && pos.y > 0 && pos.y <= rows)\n"
"{\n"
"pos.x += c_dx[lidx & 7];\n"
"pos.y += c_dy[lidx & 7];\n"
"if (map[pos.x + map_offset + pos.y * map_step] == 1)\n"
"{\n"
"map[pos.x + map_offset + pos.y * map_step] = 2;\n"
"ind = atomic_inc(&s_counter);\n"
"s_st[ind] = pos;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (s_counter > 0)\n"
"{\n"
"if (lidx == 0)\n"
"{\n"
"ind = atomic_add(counter, s_counter);\n"
"s_ind = ind - s_counter;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ind = s_ind;\n"
"for (int i = lidx; i < s_counter; i += get_local_size(0))\n"
"{\n"
"st2[ind + i] = s_st[i];\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"#undef stack_size\n"
"__kernel\n"
"void getEdges\n"
"(\n"
"__global const int * map,\n"
"__global uchar * dst,\n"
"int rows,\n"
"int cols,\n"
"int map_step,\n"
"int map_offset,\n"
"int dst_step,\n"
"int dst_offset\n"
")\n"
"{\n"
"map_step   /= sizeof(*map);\n"
"map_offset /= sizeof(*map);\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"if(gidy < rows && gidx < cols)\n"
"{\n"
"dst[gidx + gidy * dst_step] = (uchar)(-(map[gidx + 1 + (gidy + 1) * map_step] / 2));\n"
"}\n"
"}\n"
;
const char* imgproc_columnsum="#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#if defined (__ATI__)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (__NVIDIA__)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void columnSum_C1_D5(__global float* src,__global float* dst,int srcCols,int srcRows,int srcStep,int dstStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"srcStep >>= 2;\n"
"dstStep >>= 2;\n"
"if (x < srcCols)\n"
"{\n"
"int srcIdx = x ;\n"
"int dstIdx = x ;\n"
"float sum = 0;\n"
"for (int y = 0; y < srcRows; ++y)\n"
"{\n"
"sum += src[srcIdx];\n"
"dst[dstIdx] = sum;\n"
"srcIdx += srcStep;\n"
"dstIdx += dstStep;\n"
"}\n"
"}\n"
"}\n"
;
const char* imgproc_convolve="#if defined (__ATI__)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (__NVIDIA__)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void convolve_D5 (__global float *src, __global float *temp1, __global float *dst,\n"
"int rows, int cols, int src_step, int dst_step,int k_step, int kWidth, int kHeight)\n"
"{\n"
"__local float smem[16 + 2 * 8][16 + 2 * 8];\n"
"int x = get_local_id(0);\n"
"int y = get_local_id(1);\n"
"int gx = get_global_id(0);\n"
"int gy = get_global_id(1);\n"
"smem[y][x] = src[min(max(gy - 8, 0), rows - 1)*(src_step >> 2) + min(max(gx - 8, 0), cols - 1)];\n"
"smem[y][x + 16] = src[min(max(gy - 8, 0), rows - 1)*(src_step >> 2) + min(gx + 8, cols - 1)];\n"
"smem[y + 16][x] = src[min(gy + 8, rows - 1)*(src_step >> 2) + min(max(gx - 8, 0), cols - 1)];\n"
"smem[y + 16][x + 16] = src[min(gy + 8, rows - 1)*(src_step >> 2) + min(gx + 8, cols - 1)];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (gx < cols && gy < rows)\n"
"{\n"
"float res = 0;\n"
"for (int i = 0; i < kHeight; ++i)\n"
"{\n"
"for (int j = 0; j < kWidth; ++j)\n"
"{\n"
"res += smem[y + 8 - kHeight / 2 + i][x + 8 - kWidth / 2 + j] * temp1[i * (k_step>>2) + j];\n"
"}\n"
"}\n"
"dst[gy*(dst_step >> 2)+gx] = res;\n"
"}\n"
"}\n"
;
const char* imgproc_copymakeboder="#ifdef BORDER_CONSTANT\n"
"#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"#endif\n"
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i,l_edge,r_edge,addr)  (i) < (l_edge) ? (l_edge) : (addr)\n"
"#define ADDR_R(i,r_edge,addr)   (i) >= (r_edge) ? (r_edge)-1 : (addr)\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i,l_edge,r_edge,addr)  (i) < (l_edge) ? -(i)-1 : (addr)\n"
"#define ADDR_R(i,r_edge,addr) (i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr)\n"
"#endif\n"
"#ifdef BORDER_REFLECT_101\n"
"#define ADDR_L(i,l_edge,r_edge,addr)  (i) < (l_edge) ? -(i) : (addr)\n"
"#define ADDR_R(i,r_edge,addr) (i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr)\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i,l_edge,r_edge,addr)  (i) < (l_edge) ? (i)+(r_edge) : (addr)\n"
"#define ADDR_R(i,r_edge,addr)   (i) >= (r_edge) ?   (i)-(r_edge) : (addr)\n"
"#endif\n"
"__kernel void copymakeborder\n"
"(__global const GENTYPE *src,\n"
"__global GENTYPE *dst,\n"
"const int dst_cols,\n"
"const int dst_rows,\n"
"const int src_cols,\n"
"const int src_rows,\n"
"const int src_step_in_pixel,\n"
"const int src_offset_in_pixel,\n"
"const int dst_step_in_pixel,\n"
"const int dst_offset_in_pixel,\n"
"const int top,\n"
"const int left,\n"
"const GENTYPE val\n"
")\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int src_x = x-left;\n"
"int src_y = y-top;\n"
"int src_addr = mad24(src_y,src_step_in_pixel,src_x+src_offset_in_pixel);\n"
"int dst_addr = mad24(y,dst_step_in_pixel,x+dst_offset_in_pixel);\n"
"int con = (src_x >= 0) && (src_x < src_cols) && (src_y >= 0) && (src_y < src_rows);\n"
"if(con)\n"
"{\n"
"dst[dst_addr] = src[src_addr];\n"
"}\n"
"else\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"if((x<dst_cols) && (y<dst_rows))\n"
"{\n"
"dst[dst_addr] = val;\n"
"}\n"
"#else\n"
"int s_x,s_y;\n"
"s_x= ADDR_L(src_x,0,src_cols,src_x);\n"
"s_x= ADDR_R(src_x,src_cols,s_x);\n"
"s_y= ADDR_L(src_y,0,src_rows,src_y);\n"
"s_y= ADDR_R(src_y,src_rows,s_y);\n"
"src_addr=mad24(s_y,src_step_in_pixel,s_x+src_offset_in_pixel);\n"
"if((x<dst_cols) && (y<dst_rows))\n"
"{\n"
"dst[dst_addr] = src[src_addr];\n"
"}\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void copymakeborder_C1_D0\n"
"(__global const uchar *src,\n"
"__global uchar *dst,\n"
"const int dst_cols,\n"
"const int dst_rows,\n"
"const int src_cols,\n"
"const int src_rows,\n"
"const int src_step_in_pixel,\n"
"const int src_offset_in_pixel,\n"
"const int dst_step_in_pixel,\n"
"const int dst_offset_in_pixel,\n"
"const int top,\n"
"const int left,\n"
"const uchar val\n"
")\n"
"{\n"
"int x = get_global_id(0)<<2;\n"
"int y = get_global_id(1);\n"
"int src_x = x-left;\n"
"int src_y = y-top;\n"
"int src_addr = mad24(src_y,src_step_in_pixel,src_x+src_offset_in_pixel);\n"
"int dst_addr = mad24(y,dst_step_in_pixel,x+dst_offset_in_pixel);\n"
"int con = (src_x >= 0) && (src_x+3 < src_cols) && (src_y >= 0) && (src_y < src_rows);\n"
"if(con)\n"
"{\n"
"uchar4 tmp = vload4(0,src+src_addr);\n"
"*(__global uchar4*)(dst+dst_addr) = tmp;\n"
"}\n"
"else\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"if((((src_x<0) && (src_x+3>=0))||(src_x < src_cols) && (src_x+3 >= src_cols)) && (src_y >= 0) && (src_y < src_rows))\n"
"{\n"
"int4 addr;\n"
"uchar4 tmp;\n"
"addr.x = ((src_x < 0) || (src_x>= src_cols)) ? 0 : src_addr;\n"
"addr.y = ((src_x+1 < 0) || (src_x+1>= src_cols)) ? 0 : (src_addr+1);\n"
"addr.z = ((src_x+2 < 0) || (src_x+2>= src_cols)) ? 0 : (src_addr+2);\n"
"addr.w = ((src_x+3 < 0) || (src_x+3>= src_cols)) ? 0 : (src_addr+3);\n"
"tmp.x = src[addr.x];\n"
"tmp.y = src[addr.y];\n"
"tmp.z = src[addr.z];\n"
"tmp.w = src[addr.w];\n"
"tmp.x = (src_x >=0)&&(src_x  < src_cols) ? tmp.x : val;\n"
"tmp.y = (src_x+1 >=0)&&(src_x +1 < src_cols) ? tmp.y : val;\n"
"tmp.z = (src_x+2 >=0)&&(src_x +2 < src_cols) ? tmp.z : val;\n"
"tmp.w = (src_x+3 >=0)&&(src_x +3 < src_cols) ? tmp.w : val;\n"
"*(__global uchar4*)(dst+dst_addr) = tmp;\n"
"}\n"
"else if((x<dst_cols) && (y<dst_rows))\n"
"{\n"
"*(__global uchar4*)(dst+dst_addr) = (uchar4)val;\n"
"}\n"
"#else\n"
"int4 s_x;\n"
"int s_y;\n"
"s_x.x= ADDR_L(src_x,0,src_cols,src_x);\n"
"s_x.y= ADDR_L(src_x+1,0,src_cols,src_x+1);\n"
"s_x.z= ADDR_L(src_x+2,0,src_cols,src_x+2);\n"
"s_x.w= ADDR_L(src_x+3,0,src_cols,src_x+3);\n"
"s_x.x= ADDR_R(src_x,src_cols,s_x.x);\n"
"s_x.y= ADDR_R(src_x+1,src_cols,s_x.y);\n"
"s_x.z= ADDR_R(src_x+2,src_cols,s_x.z);\n"
"s_x.w= ADDR_R(src_x+3,src_cols,s_x.w);\n"
"s_y= ADDR_L(src_y,0,src_rows,src_y);\n"
"s_y= ADDR_R(src_y,src_rows,s_y);\n"
"int4 src_addr4=mad24((int4)s_y,(int4)src_step_in_pixel,s_x+(int4)src_offset_in_pixel);\n"
"if((x<dst_cols) && (y<dst_rows))\n"
"{\n"
"uchar4 tmp;\n"
"tmp.x = src[src_addr4.x];\n"
"tmp.y = src[src_addr4.y];\n"
"tmp.z = src[src_addr4.z];\n"
"tmp.w = src[src_addr4.w];\n"
"*(__global uchar4*)(dst+dst_addr) = tmp;\n"
"}\n"
"#endif\n"
"}\n"
"}\n"
;
const char* imgproc_histogram="#define PARTIAL_HISTOGRAM256_COUNT     (256)\n"
"#define HISTOGRAM256_BIN_COUNT         (256)\n"
"#define HISTOGRAM256_WORK_GROUP_SIZE     (256)\n"
"#define HISTOGRAM256_LOCAL_MEM_SIZE      (HISTOGRAM256_BIN_COUNT)\n"
"#define NBANKS (16)\n"
"#define NBANKS_BIT (4)\n"
"__kernel __attribute__((reqd_work_group_size(HISTOGRAM256_BIN_COUNT,1,1)))void calc_sub_hist_D0(\n"
"__global const uint4* src,\n"
"int src_step, int src_offset,\n"
"__global int* globalHist,\n"
"int dataCount,  int cols,\n"
"int inc_x, int inc_y,\n"
"int hist_step)\n"
"{\n"
"__local int subhist[(HISTOGRAM256_BIN_COUNT << NBANKS_BIT)];\n"
"int gid = get_global_id(0);\n"
"int lid = get_local_id(0);\n"
"int gx  = get_group_id(0);\n"
"int gsize = get_global_size(0);\n"
"int lsize  = get_local_size(0);\n"
"const int shift = 8;\n"
"const int mask = HISTOGRAM256_BIN_COUNT-1;\n"
"int offset = (lid & (NBANKS-1));\n"
"uint4 data, temp1, temp2, temp3, temp4;\n"
"src += src_offset;\n"
"for(int i=0, idx=lid; i<(NBANKS >> 2); i++, idx += lsize)\n"
"{\n"
"subhist[idx] = 0;\n"
"subhist[idx+=lsize] = 0;\n"
"subhist[idx+=lsize] = 0;\n"
"subhist[idx+=lsize] = 0;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int y = gid/cols;\n"
"int x = gid - mul24(y, cols);\n"
"for(int idx=gid; idx<dataCount; idx+=gsize)\n"
"{\n"
"data = src[mad24(y, src_step, x)];\n"
"temp1 = ((data & mask) << NBANKS_BIT) + offset;\n"
"data >>= shift;\n"
"temp2 = ((data & mask) << NBANKS_BIT) + offset;\n"
"data >>= shift;\n"
"temp3 = ((data & mask) << NBANKS_BIT) + offset;\n"
"data >>= shift;\n"
"temp4 = ((data & mask) << NBANKS_BIT) + offset;\n"
"atomic_inc(subhist + temp1.x);\n"
"atomic_inc(subhist + temp1.y);\n"
"atomic_inc(subhist + temp1.z);\n"
"atomic_inc(subhist + temp1.w);\n"
"atomic_inc(subhist + temp2.x);\n"
"atomic_inc(subhist + temp2.y);\n"
"atomic_inc(subhist + temp2.z);\n"
"atomic_inc(subhist + temp2.w);\n"
"atomic_inc(subhist + temp3.x);\n"
"atomic_inc(subhist + temp3.y);\n"
"atomic_inc(subhist + temp3.z);\n"
"atomic_inc(subhist + temp3.w);\n"
"atomic_inc(subhist + temp4.x);\n"
"atomic_inc(subhist + temp4.y);\n"
"atomic_inc(subhist + temp4.z);\n"
"atomic_inc(subhist + temp4.w);\n"
"x += inc_x;\n"
"int off = ((x>=cols) ? -1 : 0);\n"
"x = mad24(off, cols, x);\n"
"y += inc_y - off;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bin1=0, bin2=0, bin3=0, bin4=0;\n"
"for(int i=0; i<NBANKS; i+=4)\n"
"{\n"
"bin1 += subhist[(lid << NBANKS_BIT) + i];\n"
"bin2 += subhist[(lid << NBANKS_BIT) + i+1];\n"
"bin3 += subhist[(lid << NBANKS_BIT) + i+2];\n"
"bin4 += subhist[(lid << NBANKS_BIT) + i+3];\n"
"}\n"
"globalHist[mad24(gx, hist_step, lid)] = bin1+bin2+bin3+bin4;\n"
"}\n"
"__kernel void __attribute__((reqd_work_group_size(1,HISTOGRAM256_BIN_COUNT,1)))calc_sub_hist_border_D0(\n"
"__global const uchar* src,\n"
"int src_step,  int src_offset,\n"
"__global int* globalHist,\n"
"int left_col,  int cols,\n"
"int rows,   int hist_step)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidy = get_local_id(1);\n"
"int gx = get_group_id(0);\n"
"int gy = get_group_id(1);\n"
"int gn = get_num_groups(0);\n"
"int rowIndex = mad24(gy, gn, gx);\n"
"__local int subhist[HISTOGRAM256_LOCAL_MEM_SIZE];\n"
"subhist[lidy] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"gidx = ((gidx>=left_col) ? (gidx+cols) : gidx);\n"
"if(gidy<rows)\n"
"{\n"
"int src_index = src_offset + mad24(gidy, src_step, gidx);\n"
"int p = (int)src[src_index];\n"
"atomic_inc(subhist + p);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"globalHist[mad24(rowIndex, hist_step, lidy)] += subhist[lidy];\n"
"}\n"
"__kernel __attribute__((reqd_work_group_size(256,1,1)))void merge_hist(__global int* buf,\n"
"__global int* hist,\n"
"int src_step)\n"
"{\n"
"int lx = get_local_id(0);\n"
"int gx = get_group_id(0);\n"
"int sum = 0;\n"
"for(int i = lx; i < PARTIAL_HISTOGRAM256_COUNT; i += HISTOGRAM256_WORK_GROUP_SIZE)\n"
"sum += buf[ mad24(i, src_step, gx)];\n"
"__local int data[HISTOGRAM256_WORK_GROUP_SIZE];\n"
"data[lx] = sum;\n"
"for(int stride = HISTOGRAM256_WORK_GROUP_SIZE /2; stride > 0; stride >>= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lx < stride)\n"
"data[lx] += data[lx + stride];\n"
"}\n"
"if(lx == 0)\n"
"hist[gx] = data[0];\n"
"}\n"
"__kernel __attribute__((reqd_work_group_size(256,1,1)))void calLUT(\n"
"__global uchar * dst,\n"
"__constant int * hist,\n"
"int total)\n"
"{\n"
"int lid = get_local_id(0);\n"
"__local int sumhist[HISTOGRAM256_BIN_COUNT+1];\n"
"sumhist[lid]=hist[lid];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid==0)\n"
"{\n"
"int sum = 0;\n"
"int i = 0;\n"
"while (!sumhist[i]) ++i;\n"
"sumhist[HISTOGRAM256_BIN_COUNT] = sumhist[i];\n"
"for(sumhist[i++] = 0; i<HISTOGRAM256_BIN_COUNT; i++)\n"
"{\n"
"sum+=sumhist[i];\n"
"sumhist[i]=sum;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float scale = 255.f/(total - sumhist[HISTOGRAM256_BIN_COUNT]);\n"
"dst[lid]= lid == 0 ? 0 : convert_uchar_sat(convert_float(sumhist[lid])*scale);\n"
"}\n"
;
const char* imgproc_integral="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define LSIZE 256\n"
"#define LSIZE_1 255\n"
"#define LSIZE_2 254\n"
"#define HF_LSIZE 128\n"
"#define LOG_LSIZE 8\n"
"#define LOG_NUM_BANKS 5\n"
"#define NUM_BANKS 32\n"
"#define GET_CONFLICT_OFFSET(lid) ((lid) >> LOG_NUM_BANKS)\n"
"kernel void integral_cols(__global uchar4 *src,__global int *sum ,__global float *sqsum,\n"
"int src_offset,int pre_invalid,int rows,int cols,int src_step,int dst_step)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"float4 sqsum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local float4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local int* sum_p;\n"
"__local float* sqsum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid]) : 0);\n"
"src_t[1] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid + 1]) : 0);\n"
"sum_t[0] = (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] = (i == 0 ? 0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? 0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = convert_float4(src_t[0] * src_t[0]);\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = convert_float4(src_t[1] * src_t[1]);\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\n"
"if(lid > 0 && (i+lid) <= rows){\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local float*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_s0 + k * dst_step / 4] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local float*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_s1 + k * dst_step / 4] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_rows(__global int4 *srcsum,__global float4 * srcsqsum,__global int *sum ,\n"
"__global float *sqsum,int rows,int cols,int src_step,int sum_step,\n"
"int sqsum_step,int sum_offset,int sqsum_offset)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"float4 sqsrc_t[2],sqsum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local float4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local int *sum_p;\n"
"__local float *sqsum_p;\n"
"src_step = src_step >> 4;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : 0;\n"
"sqsrc_t[0] = i + lid < rows ? srcsqsum[(lid+i) * src_step + gid * 2] : 0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : 0;\n"
"sqsrc_t[1] = i + lid < rows ? srcsqsum[(lid+i) * src_step + gid * 2 + 1] : 0;\n"
"sum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] =  (i == 0 ? 0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? 0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = sqsrc_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = sqsrc_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"sqsum[sqsum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid * 2 * sum_step;\n"
"int loc1 = gid * 2 * sqsum_step;\n"
"for(int k = 1;k <= 8;k++)\n"
"{\n"
"if(gid * 8 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"sqsum[sqsum_offset + loc1 + k * sqsum_step / 4] = 0;\n"
"}\n"
"}\n"
"int loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"int loc_sq0 = sqsum_offset + gid * 2 * sqsum_step + sqsum_step / 4 + i + lid, loc_sq1 = loc_sq0 + sqsum_step ;\n"
"if(lid > 0 && (i+lid) <= rows){\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local float*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq0 + k * sqsum_step / 4] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local float*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq1 + k * sqsum_step / 4] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
;
const char* imgproc_integral_sum="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define LSIZE 256\n"
"#define LSIZE_1 255\n"
"#define LSIZE_2 254\n"
"#define HF_LSIZE 128\n"
"#define LOG_LSIZE 8\n"
"#define LOG_NUM_BANKS 5\n"
"#define NUM_BANKS 32\n"
"#define GET_CONFLICT_OFFSET(lid) ((lid) >> LOG_NUM_BANKS)\n"
"kernel void integral_sum_cols(__global uchar4 *src,__global int *sum ,\n"
"int src_offset,int pre_invalid,int rows,int cols,int src_step,int dst_step)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local int* sum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid]) : 0);\n"
"src_t[1] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid + 1]) : 0);\n"
"sum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid > 0 && (i+lid) <= rows){\n"
"int loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_sum_rows(__global int4 *srcsum,__global int *sum ,\n"
"int rows,int cols,int src_step,int sum_step,\n"
"int sum_offset)\n"
"{\n"
"unsigned int lid = get_local_id(0);\n"
"unsigned int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local int *sum_p;\n"
"src_step = src_step >> 4;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : 0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : 0;\n"
"sum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid * 2 * sum_step;\n"
"for(int k = 1;k <= 8;k++)\n"
"{\n"
"if(gid * 8 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"}\n"
"}\n"
"if(lid > 0 && (i+lid) <= rows){\n"
"int loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
;
const char* imgproc_median="#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n"
"__kernel void medianFilter3_C4_D0(__global uchar4 * src, __global uchar4 * dst,  int srcOffset, int dstOffset, int cols,\n"
"int rows, int srcStep, int dstStep)\n"
"{\n"
"__local uchar4 data[18][18];\n"
"__global uchar4* source=src + srcOffset;\n"
"int dx = get_global_id(0) - get_local_id(0) -1;\n"
"int dy = get_global_id(1) - get_local_id(1) -1;\n"
"const int id = min((int)(get_local_id(0)*16+get_local_id(1)), 9*18-1);\n"
"int dr=id/18;\n"
"int dc=id%18;\n"
"int r=clamp(dy+dr, 0, rows-1);\n"
"int c=clamp(dx+dc, 0, cols-1);\n"
"data[dr][dc] = source[r*srcStep + c];\n"
"r=clamp(dy+dr+9, 0, rows-1);\n"
"data[dr+9][dc] = source[r*srcStep + c];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int x =get_local_id(0);\n"
"int y =get_local_id(1);\n"
"uchar4 p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2];\n"
"uchar4 p3=data[y+1][x], p4=data[y+1][x+1], p5=data[y+1][x+2];\n"
"uchar4 p6=data[y+2][x], p7=data[y+2][x+1], p8=data[y+2][x+2];\n"
"uchar4 mid;\n"
"op(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\n"
"op(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\n"
"op(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\n"
"op(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\n"
"op(p4, p2); op(p6, p4); op(p4, p2);\n"
"if(get_global_id(1)<rows && get_global_id(0)<cols)\n"
"dst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p4;\n"
"}\n"
"#undef op(a,b)\n"
"#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n"
"__kernel void medianFilter3_C1_D0(__global uchar * src, __global uchar * dst,  int srcOffset, int dstOffset, int cols,\n"
"int rows, int srcStep, int dstStep)\n"
"{\n"
"__local uchar data[18][18];\n"
"__global uchar* source=src + srcOffset;\n"
"int dx = get_global_id(0) - get_local_id(0) -1;\n"
"int dy = get_global_id(1) - get_local_id(1) -1;\n"
"const int id = min((int)(get_local_id(0)*16+get_local_id(1)), 9*18-1);\n"
"int dr=id/18;\n"
"int dc=id%18;\n"
"int r=clamp(dy+dr, 0, rows-1);\n"
"int c=clamp(dx+dc, 0, cols-1);\n"
"data[dr][dc] = source[r*srcStep + c];\n"
"r=clamp(dy+dr+9, 0, rows-1);\n"
"data[dr+9][dc] = source[r*srcStep + c];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int x =get_local_id(0);\n"
"int y =get_local_id(1);\n"
"uchar p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2];\n"
"uchar p3=data[y+1][x], p4=data[y+1][x+1], p5=data[y+1][x+2];\n"
"uchar p6=data[y+2][x], p7=data[y+2][x+1], p8=data[y+2][x+2];\n"
"uchar mid;\n"
"op(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\n"
"op(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\n"
"op(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\n"
"op(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\n"
"op(p4, p2); op(p6, p4); op(p4, p2);\n"
"if(get_global_id(1)<rows && get_global_id(0)<cols)\n"
"dst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p4;\n"
"}\n"
"#undef op(a,b)\n"
"#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n"
"__kernel void medianFilter3_C1_D5(__global float * src, __global float * dst,  int srcOffset, int dstOffset, int cols,\n"
"int rows, int srcStep, int dstStep)\n"
"{\n"
"__local float data[18][18];\n"
"__global float* source=src + srcOffset;\n"
"int dx = get_global_id(0) - get_local_id(0) -1;\n"
"int dy = get_global_id(1) - get_local_id(1) -1;\n"
"const int id = min((int)(get_local_id(0)*16+get_local_id(1)), 9*18-1);\n"
"int dr=id/18;\n"
"int dc=id%18;\n"
"int r=clamp(dy+dr, 0, rows-1);\n"
"int c=clamp(dx+dc, 0, cols-1);\n"
"data[dr][dc] = source[r*srcStep + c];\n"
"r=clamp(dy+dr+9, 0, rows-1);\n"
"data[dr+9][dc] = source[r*srcStep + c];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int x =get_local_id(0);\n"
"int y =get_local_id(1);\n"
"float p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2];\n"
"float p3=data[y+1][x], p4=data[y+1][x+1], p5=data[y+1][x+2];\n"
"float p6=data[y+2][x], p7=data[y+2][x+1], p8=data[y+2][x+2];\n"
"float mid;\n"
"op(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\n"
"op(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\n"
"op(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\n"
"op(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\n"
"op(p4, p2); op(p6, p4); op(p4, p2);\n"
"if(get_global_id(1)<rows && get_global_id(0)<cols)\n"
"dst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p4;\n"
"}\n"
"#undef op(a,b)\n"
"#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n"
"__kernel void medianFilter3_C4_D5(__global float4 * src, __global float4 * dst,  int srcOffset, int dstOffset, int cols,\n"
"int rows, int srcStep, int dstStep)\n"
"{\n"
"__local float4 data[18][18];\n"
"__global float4* source=src + srcOffset;\n"
"int dx = get_global_id(0) - get_local_id(0) -1;\n"
"int dy = get_global_id(1) - get_local_id(1) -1;\n"
"const int id = min((int)(get_local_id(0)*16+get_local_id(1)), 9*18-1);\n"
"int dr=id/18;\n"
"int dc=id%18;\n"
"int r=clamp(dy+dr, 0, rows-1);\n"
"int c=clamp(dx+dc, 0, cols-1);\n"
"data[dr][dc] = source[r*srcStep + c];\n"
"r=clamp(dy+dr+9, 0, rows-1);\n"
"data[dr+9][dc] = source[r*srcStep + c];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int x =get_local_id(0);\n"
"int y =get_local_id(1);\n"
"float4 p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2];\n"
"float4 p3=data[y+1][x], p4=data[y+1][x+1], p5=data[y+1][x+2];\n"
"float4 p6=data[y+2][x], p7=data[y+2][x+1], p8=data[y+2][x+2];\n"
"float4 mid;\n"
"op(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\n"
"op(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\n"
"op(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\n"
"op(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\n"
"op(p4, p2); op(p6, p4); op(p4, p2);\n"
"if(get_global_id(1)<rows && get_global_id(0)<cols)\n"
"dst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p4;\n"
"}\n"
"#undef op(a,b)\n"
"#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n"
"__kernel void medianFilter5_C4_D0(__global uchar4 * src, __global uchar4 * dst,  int srcOffset, int dstOffset, int cols,\n"
"int rows, int srcStep, int dstStep)\n"
"{\n"
"__local uchar4 data[20][20];\n"
"__global uchar4* source=src + srcOffset;\n"
"int dx = get_global_id(0) - get_local_id(0) -2;\n"
"int dy = get_global_id(1) - get_local_id(1) -2;\n"
"const int id = min((int)(get_local_id(0)*16+get_local_id(1)), 10*20-1);\n"
"int dr=id/20;\n"
"int dc=id%20;\n"
"int r=clamp(dy+dr, 0, rows-1);\n"
"int c=clamp(dx+dc, 0, cols-1);\n"
"data[dr][dc] = source[r*srcStep + c];\n"
"r=clamp(dy+dr+10, 0, rows-1);\n"
"data[dr+10][dc] = source[r*srcStep + c];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int x =get_local_id(0);\n"
"int y =get_local_id(1);\n"
"uchar4 p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2], p3=data[y][x+3], p4=data[y][x+4];\n"
"uchar4 p5=data[y+1][x], p6=data[y+1][x+1], p7=data[y+1][x+2], p8=data[y+1][x+3], p9=data[y+1][x+4];\n"
"uchar4 p10=data[y+2][x], p11=data[y+2][x+1], p12=data[y+2][x+2], p13=data[y+2][x+3], p14=data[y+2][x+4];\n"
"uchar4 p15=data[y+3][x], p16=data[y+3][x+1], p17=data[y+3][x+2], p18=data[y+3][x+3], p19=data[y+3][x+4];\n"
"uchar4 p20=data[y+4][x], p21=data[y+4][x+1], p22=data[y+4][x+2], p23=data[y+4][x+3], p24=data[y+4][x+4];\n"
"uchar4 mid;\n"
"op(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\n"
"op(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\n"
"op(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\n"
"op(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\n"
"op(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\n"
"op(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\n"
"op(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\n"
"op(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\n"
"op(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\n"
"op(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\n"
"op(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\n"
"op(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\n"
"op(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\n"
"op(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\n"
"op(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\n"
"op(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\n"
"op(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\n"
"op(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\n"
"op(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\n"
"op(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\n"
"op(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\n"
"op(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\n"
"op(p7, p11); op(p11, p13); op(p11, p12);\n"
"if(get_global_id(1)<rows && get_global_id(0)<cols)\n"
"dst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p12;\n"
"}\n"
"#undef op(a,b)\n"
"#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n"
"__kernel void medianFilter5_C1_D0(__global uchar * src, __global uchar * dst,  int srcOffset, int dstOffset, int cols,\n"
"int rows, int srcStep, int dstStep)\n"
"{\n"
"__local uchar data[20][20];\n"
"__global uchar* source=src + srcOffset;\n"
"int dx = get_global_id(0) - get_local_id(0) -2;\n"
"int dy = get_global_id(1) - get_local_id(1) -2;\n"
"const int id = min((int)(get_local_id(0)*16+get_local_id(1)), 10*20-1);\n"
"int dr=id/20;\n"
"int dc=id%20;\n"
"int r=clamp(dy+dr, 0, rows-1);\n"
"int c=clamp(dx+dc, 0, cols-1);\n"
"data[dr][dc] = source[r*srcStep + c];\n"
"r=clamp(dy+dr+10, 0, rows-1);\n"
"data[dr+10][dc] = source[r*srcStep + c];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int x =get_local_id(0);\n"
"int y =get_local_id(1);\n"
"uchar p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2], p3=data[y][x+3], p4=data[y][x+4];\n"
"uchar p5=data[y+1][x], p6=data[y+1][x+1], p7=data[y+1][x+2], p8=data[y+1][x+3], p9=data[y+1][x+4];\n"
"uchar p10=data[y+2][x], p11=data[y+2][x+1], p12=data[y+2][x+2], p13=data[y+2][x+3], p14=data[y+2][x+4];\n"
"uchar p15=data[y+3][x], p16=data[y+3][x+1], p17=data[y+3][x+2], p18=data[y+3][x+3], p19=data[y+3][x+4];\n"
"uchar p20=data[y+4][x], p21=data[y+4][x+1], p22=data[y+4][x+2], p23=data[y+4][x+3], p24=data[y+4][x+4];\n"
"uchar mid;\n"
"op(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\n"
"op(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\n"
"op(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\n"
"op(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\n"
"op(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\n"
"op(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\n"
"op(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\n"
"op(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\n"
"op(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\n"
"op(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\n"
"op(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\n"
"op(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\n"
"op(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\n"
"op(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\n"
"op(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\n"
"op(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\n"
"op(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\n"
"op(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\n"
"op(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\n"
"op(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\n"
"op(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\n"
"op(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\n"
"op(p7, p11); op(p11, p13); op(p11, p12);\n"
"if(get_global_id(1)<rows && get_global_id(0)<cols)\n"
"dst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p12;\n"
"}\n"
"#undef op(a,b)\n"
"#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n"
"__kernel void medianFilter5_C4_D5(__global float4 * src, __global float4 * dst,  int srcOffset, int dstOffset, int cols,\n"
"int rows, int srcStep, int dstStep)\n"
"{\n"
"__local float4 data[20][20];\n"
"__global float4* source=src + srcOffset;\n"
"int dx = get_global_id(0) - get_local_id(0) -2;\n"
"int dy = get_global_id(1) - get_local_id(1) -2;\n"
"const int id = min((int)(get_local_id(0)*16+get_local_id(1)), 10*20-1);\n"
"int dr=id/20;\n"
"int dc=id%20;\n"
"int r=clamp(dy+dr, 0, rows-1);\n"
"int c=clamp(dx+dc, 0, cols-1);\n"
"data[dr][dc] = source[r*srcStep + c];\n"
"r=clamp(dy+dr+10, 0, rows-1);\n"
"data[dr+10][dc] = source[r*srcStep + c];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int x =get_local_id(0);\n"
"int y =get_local_id(1);\n"
"float4 p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2], p3=data[y][x+3], p4=data[y][x+4];\n"
"float4 p5=data[y+1][x], p6=data[y+1][x+1], p7=data[y+1][x+2], p8=data[y+1][x+3], p9=data[y+1][x+4];\n"
"float4 p10=data[y+2][x], p11=data[y+2][x+1], p12=data[y+2][x+2], p13=data[y+2][x+3], p14=data[y+2][x+4];\n"
"float4 p15=data[y+3][x], p16=data[y+3][x+1], p17=data[y+3][x+2], p18=data[y+3][x+3], p19=data[y+3][x+4];\n"
"float4 p20=data[y+4][x], p21=data[y+4][x+1], p22=data[y+4][x+2], p23=data[y+4][x+3], p24=data[y+4][x+4];\n"
"float4 mid;\n"
"op(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\n"
"op(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\n"
"op(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\n"
"op(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\n"
"op(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\n"
"op(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\n"
"op(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\n"
"op(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\n"
"op(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\n"
"op(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\n"
"op(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\n"
"op(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\n"
"op(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\n"
"op(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\n"
"op(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\n"
"op(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\n"
"op(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\n"
"op(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\n"
"op(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\n"
"op(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\n"
"op(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\n"
"op(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\n"
"op(p7, p11); op(p11, p13); op(p11, p12);\n"
"if(get_global_id(1)<rows && get_global_id(0)<cols)\n"
"dst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p12;\n"
"}\n"
"#undef op(a,b)\n"
"#define op(a,b) {mid=a; a=min(a,b); b=max(mid,b);}\n"
"__kernel void medianFilter5_C1_D5(__global float * src, __global float * dst,  int srcOffset, int dstOffset, int cols,\n"
"int rows, int srcStep, int dstStep)\n"
"{\n"
"__local float data[20][20];\n"
"__global float* source=src + srcOffset;\n"
"int dx = get_global_id(0) - get_local_id(0) -2;\n"
"int dy = get_global_id(1) - get_local_id(1) -2;\n"
"const int id = min((int)(get_local_id(0)*16+get_local_id(1)), 10*20-1);\n"
"int dr=id/20;\n"
"int dc=id%20;\n"
"int r=clamp(dy+dr, 0, rows-1);\n"
"int c=clamp(dx+dc, 0, cols-1);\n"
"data[dr][dc] = source[r*srcStep + c];\n"
"r=clamp(dy+dr+10, 0, rows-1);\n"
"data[dr+10][dc] = source[r*srcStep + c];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int x =get_local_id(0);\n"
"int y =get_local_id(1);\n"
"float p0=data[y][x], p1=data[y][x+1], p2=data[y][x+2], p3=data[y][x+3], p4=data[y][x+4];\n"
"float p5=data[y+1][x], p6=data[y+1][x+1], p7=data[y+1][x+2], p8=data[y+1][x+3], p9=data[y+1][x+4];\n"
"float p10=data[y+2][x], p11=data[y+2][x+1], p12=data[y+2][x+2], p13=data[y+2][x+3], p14=data[y+2][x+4];\n"
"float p15=data[y+3][x], p16=data[y+3][x+1], p17=data[y+3][x+2], p18=data[y+3][x+3], p19=data[y+3][x+4];\n"
"float p20=data[y+4][x], p21=data[y+4][x+1], p22=data[y+4][x+2], p23=data[y+4][x+3], p24=data[y+4][x+4];\n"
"float mid;\n"
"op(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\n"
"op(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\n"
"op(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\n"
"op(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\n"
"op(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\n"
"op(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\n"
"op(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\n"
"op(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\n"
"op(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\n"
"op(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\n"
"op(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\n"
"op(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\n"
"op(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\n"
"op(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\n"
"op(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\n"
"op(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\n"
"op(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\n"
"op(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\n"
"op(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\n"
"op(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\n"
"op(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\n"
"op(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\n"
"op(p7, p11); op(p11, p13); op(p11, p12);\n"
"if(get_global_id(1)<rows && get_global_id(0)<cols)\n"
"dst[dstOffset + get_global_id(1)*dstStep + get_global_id(0)]=p12;\n"
"}\n"
"#undef op(a,b)\n"
;
const char* imgproc_remap="#if defined DOUBLE_SUPPORT\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"typedef double4 F4 ;\n"
"#else\n"
"typedef float4 F4;\n"
"#endif\n"
"__kernel void remapNNSConstant_C1_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global short * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows, int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"x = x << 2;\n"
"int gx = x - (dst_offset&3);\n"
"int4 Gx = (int4)(gx, gx+1, gx+2, gx+3);\n"
"uchar4 nval =convert_uchar4(nVal);\n"
"uchar4 val = (uchar4)(nval.s0);\n"
"int dstStart = (y * dst_step + x  + dst_offset) - (dst_offset&3);\n"
"int map1Start = y * map1_step + (x << 2) + map1_offset - ((dst_offset & 3) << 2);\n"
"short8 map1_data;\n"
"map1_data = *((__global short8 *)((__global char*)map1 + map1Start));\n"
"int4 srcIdx = convert_int4(map1_data.odd) * src_step + convert_int4(map1_data.even) + src_offset;\n"
"uchar4 con = convert_uchar4(convert_int4(map1_data.even) >= (int4)(src_cols) || convert_int4(map1_data.odd) >= (int4)(src_rows) || convert_int4(map1_data.even) < (int4)(0) || convert_int4(map1_data.odd) < (int4)(0));\n"
"uchar4 src_data = val;\n"
"if (con.s0 == 0)\n"
"src_data.s0 = *(src + srcIdx.s0);\n"
"if (con.s1 == 0)\n"
"src_data.s1 = *(src + srcIdx.s1);\n"
"if (con.s2 == 0)\n"
"src_data.s2 = *(src + srcIdx.s2);\n"
"if (con.s3 == 0)\n"
"src_data.s3 = *(src + srcIdx.s3);\n"
"uchar4 dst_data;\n"
"__global uchar4* d = (__global uchar4 *)(dst + dstStart);\n"
"uchar4 dVal = *d;\n"
"int4 dcon = (Gx >= 0 && Gx < dst_cols && y >= 0 && y < dst_rows);\n"
"dst_data = (convert_uchar4(dcon) != convert_uchar4((int4)(0))) ? src_data : dVal;\n"
"*d = dst_data;\n"
"}\n"
"}\n"
"__kernel void remapNNFConstant_C1_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global float * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows, int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"x = x << 2;\n"
"int gx = x - (dst_offset&3);\n"
"int4 Gx = (int4)(gx, gx+1, gx+2, gx+3);\n"
"uchar4 nval =convert_uchar4(nVal);\n"
"uchar val = nval.s0;\n"
"int dstStart = (y * dst_step + x  + dst_offset) - (dst_offset&3);\n"
"int map1Start = y * map1_step + (x << 3) + map1_offset - ((dst_offset & 3) << 3);\n"
"float8 map1_data;\n"
"map1_data = *((__global float8 *)((__global char*)map1 + map1Start));\n"
"int8 map1_dataZ = convert_int8_sat_rte(map1_data);\n"
"int4 srcIdx = map1_dataZ.odd * src_step + map1_dataZ.even + src_offset;\n"
"uchar4 src_data = val;\n"
"uchar4 con = convert_uchar4(map1_dataZ.even >= (int4)(src_cols) || map1_dataZ.odd >= (int4)(src_rows) || map1_dataZ.even < (int4)(0) || map1_dataZ.odd < (int4)(0));\n"
"if (con.s0 == 0)\n"
"src_data.s0 = *(src + srcIdx.s0);\n"
"if (con.s1 == 0)\n"
"src_data.s1 = *(src + srcIdx.s1);\n"
"if (con.s2 == 0)\n"
"src_data.s2 = *(src + srcIdx.s2);\n"
"if (con.s3 == 0)\n"
"src_data.s3 = *(src + srcIdx.s3);\n"
"uchar4 dst_data;\n"
"__global uchar4* d = (__global uchar4 *)(dst + dstStart);\n"
"uchar4 dVal = *d;\n"
"int4 dcon = (Gx >= 0 && Gx < dst_cols && y >= 0 && y < dst_rows);\n"
"dst_data = (convert_uchar4(dcon) != convert_uchar4((int4)(0))) ? src_data : dVal;\n"
"*d = dst_data;\n"
"}\n"
"}\n"
"__kernel void remapNNF1Constant_C1_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global float * map1,  __global float * map2, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows, int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"x = x << 2;\n"
"int gx = x - (dst_offset&3);\n"
"int4 Gx = (int4)(gx, gx+1, gx+2, gx+3);\n"
"uchar4 nval =convert_uchar4(nVal);\n"
"uchar4 val = (uchar4)(nval.s0);\n"
"int dstStart = (y * dst_step + x  + dst_offset) - (dst_offset&3);\n"
"int map1Start = y * map1_step + (x << 2) + map1_offset - ((dst_offset & 3) << 2);\n"
"float4 map1_data;\n"
"float4 map2_data;\n"
"map1_data = *((__global float4 *)((__global char*)map1 + map1Start));\n"
"map2_data = *((__global float4 *)((__global char*)map2 + map1Start));\n"
"float8 map_data = (float8)(map1_data.s0, map2_data.s0, map1_data.s1, map2_data.s1, map1_data.s2, map2_data.s2, map1_data.s3, map2_data.s3);\n"
"int8 map_dataZ = convert_int8_sat_rte(map_data);\n"
"int4 srcIdx = map_dataZ.odd * src_step + map_dataZ.even + src_offset;\n"
"uchar4 src_data = val;\n"
"uchar4 con = convert_uchar4(map_dataZ.even >= (int4)(src_cols) || map_dataZ.odd >= (int4)(src_rows)|| map_dataZ.even < (int4)(0) || map_dataZ.odd < (int4)(0));\n"
"if (con.s0 == 0)\n"
"src_data.s0 = *(src + srcIdx.s0);\n"
"if (con.s1 == 0)\n"
"src_data.s1 = *(src + srcIdx.s1);\n"
"if (con.s2 == 0)\n"
"src_data.s2 = *(src + srcIdx.s2);\n"
"if (con.s3 == 0)\n"
"src_data.s3 = *(src + srcIdx.s3);\n"
"uchar4 dst_data;\n"
"__global uchar4* d = (__global uchar4 *)(dst + dstStart);\n"
"uchar4 dVal = *d;\n"
"int4 dcon = (Gx >= 0 && Gx < dst_cols && y >= 0 && y < dst_rows);\n"
"dst_data = (convert_uchar4(dcon) != convert_uchar4((int4)(0))) ? src_data : dVal;\n"
"*d = dst_data;\n"
"}\n"
"}\n"
"__kernel void remapNNSConstant_C4_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global short * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows, int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 2) + dst_offset;\n"
"int mapIdx = y * map1_step + (x << 2) + map1_offset;\n"
"short2 map1_data = *((__global short2 *)((__global char*)map1 + mapIdx));\n"
"int srcIdx = map1_data.y * src_step + (map1_data.x << 2) + src_offset;\n"
"uchar4 nval = convert_uchar4(nVal);\n"
"uchar4 src_data;\n"
"if(map1_data.x >= src_cols || map1_data.y >= src_rows || map1_data.x <0 || map1_data.y < 0 )\n"
"src_data = nval;\n"
"else\n"
"src_data = *((__global uchar4 *)((__global uchar *)src + srcIdx));\n"
"*((__global uchar4 *)((__global uchar*)dst + dstIdx)) = src_data;\n"
"}\n"
"}\n"
"__kernel void remapNNFConstant_C4_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global float * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows, int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 2) + dst_offset;\n"
"int mapIdx = y * map1_step + (x << 3) + map1_offset;\n"
"float2 map1_data = *((__global float2 *)((__global char*)map1 + mapIdx));\n"
"int2 map1_dataZ = convert_int2_sat_rte(map1_data);\n"
"int srcIdx = map1_dataZ.y * src_step + (map1_dataZ.x << 2) + src_offset;\n"
"uchar4 nval = convert_uchar4(nVal);\n"
"uchar4 src_data;\n"
"if(map1_dataZ.x >= src_cols || map1_dataZ.y >= src_rows || map1_dataZ.x < 0 || map1_dataZ.y < 0)\n"
"src_data = nval;\n"
"else\n"
"src_data = *((__global uchar4 *)((__global uchar *)src + srcIdx));\n"
"*((__global uchar4 *)((__global uchar*)dst + dstIdx)) = src_data;\n"
"}\n"
"}\n"
"__kernel void remapNNF1Constant_C4_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global float * map1,  __global float * map2, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows, int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 2) + dst_offset;\n"
"int mapIdx = y * map1_step + (x << 2) + map1_offset;\n"
"float map1_data = *((__global float *)((__global char*)map1 + mapIdx));\n"
"float map2_data = *((__global float *)((__global char*)map2 + mapIdx));\n"
"int srcIdx = convert_int_sat_rte(map2_data) * src_step + (convert_int_sat_rte(map1_data) << 2) + src_offset;\n"
"uchar4 nval = convert_uchar4(nVal);\n"
"uchar4 src_data;\n"
"if(convert_int_sat_rte(map1_data) >= src_cols || convert_int_sat_rte(map2_data) >= src_rows || convert_int_sat_rte(map1_data) < 0 || convert_int_sat_rte(map2_data) < 0)\n"
"src_data = nval;\n"
"else\n"
"src_data = *((__global uchar4 *)((__global uchar *)src + srcIdx));\n"
"*((__global uchar4 *)((__global uchar*)dst + dstIdx)) = src_data;\n"
"}\n"
"}\n"
"__kernel void remapNNSConstant_C1_D5(__global float* dst, __global float const * restrict  src,\n"
"__global short * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows ,int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 2) + dst_offset;\n"
"int mapIdx = y * map1_step + (x << 2) + map1_offset;\n"
"short2 map1_data = *((__global short2 *)((__global char*)map1 + mapIdx));\n"
"int srcIdx = map1_data.y * src_step + (map1_data.x << 2) + src_offset;\n"
"float nval = convert_float(nVal.x);\n"
"float src_data;\n"
"if(map1_data.x >= src_cols || map1_data.y >= src_rows|| map1_data.x < 0 || map1_data.y < 0)\n"
"src_data = nval;\n"
"else\n"
"src_data = *((__global float *)((__global uchar *)src + srcIdx));\n"
"*((__global float *)((__global uchar*)dst + dstIdx)) = src_data;\n"
"}\n"
"}\n"
"__kernel void remapNNFConstant_C1_D5(__global float* dst, __global float const * restrict  src,\n"
"__global float * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows ,int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 2) + dst_offset;\n"
"int mapIdx = y * map1_step + (x << 3) + map1_offset;\n"
"float2 map1_data = *((__global float2 *)((__global char*)map1 + mapIdx));\n"
"int2 map1_dataZ = convert_int2_sat_rte(map1_data);\n"
"int srcIdx = map1_dataZ.y * src_step + (map1_dataZ.x << 2) + src_offset;\n"
"float nval = convert_float(nVal.x);\n"
"float src_data;\n"
"if(map1_dataZ.x >= src_cols || map1_dataZ.y >= src_rows || map1_dataZ.x < 0 || map1_dataZ.y < 0)\n"
"src_data = nval;\n"
"else\n"
"src_data = *((__global float *)((__global uchar *)src + srcIdx));\n"
"*((__global float *)((__global uchar*)dst + dstIdx)) = src_data;\n"
"}\n"
"}\n"
"__kernel void remapNNF1Constant_C1_D5(__global float* dst, __global float const * restrict  src,\n"
"__global float * map1, __global float * map2, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows ,int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 2) + dst_offset;\n"
"int mapIdx = y * map1_step + (x << 2) + map1_offset;\n"
"float map1_data = *((__global float *)((__global char*)map1 + mapIdx));\n"
"float map2_data = *((__global float *)((__global char*)map2 + mapIdx));\n"
"float2 map_data = (float2)(map1_data, map2_data);\n"
"int2 map1_dataZ = convert_int2_sat_rte(map_data);\n"
"int srcIdx = map1_dataZ.y * src_step + (map1_dataZ.x << 2) + src_offset;\n"
"float nval = convert_float(nVal.x);\n"
"float src_data;\n"
"if(map1_dataZ.x >= src_cols || map1_dataZ.y >= src_rows || map1_dataZ.x < 0 || map1_dataZ.y < 0)\n"
"src_data = nval;\n"
"else\n"
"src_data = *((__global float *)((__global uchar *)src + srcIdx));\n"
"*((__global float *)((__global uchar*)dst + dstIdx)) = src_data;\n"
"}\n"
"}\n"
"__kernel void remapNNSConstant_C4_D5(__global float * dst, __global float const * restrict  src,\n"
"__global short * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 4) + dst_offset  ;\n"
"int mapIdx = y * map1_step + (x << 2) + map1_offset ;\n"
"short2 map1_data = *((__global short2 *)((__global char*)map1 + mapIdx));\n"
"int srcIdx = map1_data.y * src_step + (map1_data.x << 4) + src_offset;\n"
"float4 nval = convert_float4(nVal);\n"
"float4 src_data;\n"
"if (map1_data.x <0 || map1_data.x >= src_cols || map1_data.y <0 || map1_data.y >= src_rows)\n"
"src_data = nval;\n"
"else\n"
"src_data = *((__global float4 *)((__global uchar *)src + srcIdx));\n"
"*((__global float4 *)((__global uchar*)dst + dstIdx)) = src_data;\n"
"}\n"
"}\n"
"__kernel void remapNNFConstant_C4_D5(__global float * dst, __global float const * restrict  src,\n"
"__global float * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 4) + dst_offset  ;\n"
"int mapIdx = y * map1_step + (x << 3) + map1_offset ;\n"
"float2 map1_data = *((__global float2 *)((__global char*)map1 + mapIdx));\n"
"int2 map1_dataZ = convert_int2_sat_rte(map1_data);\n"
"int srcIdx = map1_dataZ.y * src_step + (map1_dataZ.x << 4) + src_offset;\n"
"float4 nval = convert_float4(nVal);\n"
"float4 src_data = nval;\n"
"if(map1_dataZ.x >= 0 && map1_dataZ.x < src_cols && map1_dataZ.y >=0 && map1_dataZ.y < src_rows)\n"
"src_data = *((__global float4 *)((__global uchar *)src + srcIdx));\n"
"*((__global float4 *)((__global uchar*)dst + dstIdx)) = src_data;\n"
"}\n"
"}\n"
"__kernel void remapNNF1Constant_C4_D5(__global float * dst, __global float const * restrict  src,\n"
"__global float * map1,  __global float * map2, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 4) + dst_offset  ;\n"
"int mapIdx = y * map1_step + (x << 2) + map1_offset ;\n"
"float map1_data = *((__global float *)((__global char*)map1 + mapIdx));\n"
"float map2_data = *((__global float *)((__global char*)map2 + mapIdx));\n"
"float2 map_data = (float2)(map1_data, map2_data);\n"
"int2 map1_dataZ = convert_int2_sat_rte(map_data);\n"
"int srcIdx = map1_dataZ.y * src_step + (map1_dataZ.x << 4) + src_offset;\n"
"float4 nval = convert_float4(nVal);\n"
"float4 src_data = nval;\n"
"if(map1_dataZ.x >= 0 && map1_dataZ.x < src_cols && map1_dataZ.y >= 0 && map1_dataZ.y < src_rows)\n"
"src_data = *((__global float4 *)((__global uchar *)src + srcIdx));\n"
"*((__global float4 *)((__global uchar*)dst + dstIdx)) = src_data;\n"
"}\n"
"}\n"
"__kernel void remapLNFConstant_C1_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global float * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"x = x << 2;\n"
"int gx = x - (dst_offset&3);\n"
"int4 Gx = (int4)(gx, gx+1, gx+2, gx+3);\n"
"uchar4 nval =convert_uchar4(nVal);\n"
"uchar4 val = (uchar4)(nval.s0);\n"
"int dstStart = (y * dst_step + x  + dst_offset) - (dst_offset&3);\n"
"int map1Start = y * map1_step + (x << 3) + map1_offset - ((dst_offset & 3) << 3);\n"
"float8 map1_data;\n"
"map1_data = *((__global float8 *)((__global char*)map1 + map1Start));\n"
"int8 map1_dataD = convert_int8(map1_data);\n"
"float8 temp = map1_data - convert_float8(map1_dataD);\n"
"float4 u = temp.even;\n"
"float4 v = temp.odd;\n"
"float4 ud = (float4)(1.0) - u;\n"
"float4 vd = (float4)(1.0) - v;\n"
"int4 map1_dataDx = map1_dataD.even;\n"
"int4 map1_dataDy = map1_dataD.odd;\n"
"int4 map1_dataDx1 = map1_dataDx + (int4)(1);\n"
"int4 map1_dataDy1 = map1_dataDy + (int4)(1);\n"
"uchar4 a = val, b = val, c = val, d =val;\n"
"if (map1_dataDx.s0 < src_cols && map1_dataDx.s0 >= 0 && map1_dataDy.s0 < src_rows && map1_dataDy.s0 >= 0)\n"
"a.s0 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s0 * src_step + map1_dataDx.s0 + src_offset));\n"
"if (map1_dataDx.s1 < src_cols && map1_dataDx.s1 >= 0 && map1_dataDy.s1 < src_rows && map1_dataDy.s1 >= 0)\n"
"a.s1 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s1 * src_step + map1_dataDx.s1 + src_offset));\n"
"if (map1_dataDx.s2 < src_cols && map1_dataDx.s2 >= 0 && map1_dataDy.s2 < src_rows && map1_dataDy.s2 >= 0)\n"
"a.s2 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s2 * src_step + map1_dataDx.s2 + src_offset));\n"
"if (map1_dataDx.s3 < src_cols && map1_dataDx.s3 >= 0 && map1_dataDy.s3 < src_rows && map1_dataDy.s3 >= 0)\n"
"a.s3 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s3 * src_step + map1_dataDx.s3 + src_offset));\n"
"if (map1_dataDx1.s0 < src_cols && map1_dataDx1.s0 >= 0 && map1_dataDy.s0 < src_rows && map1_dataDy.s0 >= 0)\n"
"b.s0 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s0 * src_step + map1_dataDx1.s0 + src_offset));\n"
"if (map1_dataDx1.s1 < src_cols && map1_dataDx1.s1 >= 0 && map1_dataDy.s1 < src_rows && map1_dataDy.s1 >= 0)\n"
"b.s1 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s1 * src_step + map1_dataDx1.s1 + src_offset));\n"
"if (map1_dataDx1.s2 < src_cols && map1_dataDx1.s2 >= 0 && map1_dataDy.s2 < src_rows && map1_dataDy.s2 >= 0)\n"
"b.s2 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s2 * src_step + map1_dataDx1.s2 + src_offset));\n"
"if (map1_dataDx1.s3 < src_cols && map1_dataDx1.s3 >= 0 && map1_dataDy.s3 < src_rows && map1_dataDy.s3 >= 0)\n"
"b.s3 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s3 * src_step + map1_dataDx1.s3 + src_offset));\n"
"if (map1_dataDx.s0 < src_cols && map1_dataDx.s0 >= 0 && map1_dataDy1.s0 < src_rows && map1_dataDy1.s0 >= 0)\n"
"c.s0 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s0 * src_step + map1_dataDx.s0 + src_offset));\n"
"if (map1_dataDx.s1 < src_cols && map1_dataDx.s1 >= 0 && map1_dataDy1.s1 < src_rows && map1_dataDy1.s1 >= 0)\n"
"c.s1 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s1 * src_step + map1_dataDx.s1 + src_offset));\n"
"if (map1_dataDx.s2 < src_cols && map1_dataDx.s2 >= 0 && map1_dataDy1.s2 < src_rows && map1_dataDy1.s2 >= 0)\n"
"c.s2 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s2 * src_step + map1_dataDx.s2 + src_offset));\n"
"if (map1_dataDx.s3 < src_cols && map1_dataDx.s3 >= 0 && map1_dataDy1.s3 < src_rows && map1_dataDy1.s3 >= 0)\n"
"c.s3 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s3 * src_step + map1_dataDx.s3 + src_offset));\n"
"if (map1_dataDx1.s0 < src_cols && map1_dataDx1.s0 >= 0 && map1_dataDy1.s0 < src_rows && map1_dataDy1.s0 >= 0)\n"
"d.s0 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s0 * src_step + map1_dataDx1.s0 + src_offset));\n"
"if (map1_dataDx1.s1 < src_cols && map1_dataDx1.s1 >= 0 && map1_dataDy1.s1 < src_rows && map1_dataDy1.s1 >= 0)\n"
"d.s1 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s1 * src_step + map1_dataDx1.s1 + src_offset));\n"
"if (map1_dataDx1.s2 < src_cols && map1_dataDx1.s2 >= 0 && map1_dataDy1.s2 < src_rows && map1_dataDy1.s2 >= 0)\n"
"d.s2 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s2 * src_step + map1_dataDx1.s2 + src_offset));\n"
"if (map1_dataDx1.s3 < src_cols && map1_dataDx1.s3 >= 0 && map1_dataDy1.s3 < src_rows && map1_dataDy1.s3 >= 0)\n"
"d.s3 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s3 * src_step + map1_dataDx1.s3 + src_offset));\n"
"uchar4 dst_data = convert_uchar4_sat_rte((convert_float4(a))* ud * vd +(convert_float4(b))* u * vd + (convert_float4(c))* ud * v + (convert_float4(d)) * u * v );\n"
"__global uchar4* D = (__global uchar4 *)(dst + dstStart);\n"
"uchar4 dVal = *D;\n"
"int4 con = (Gx >= 0 && Gx < dst_cols && y >= 0 && y < dst_rows);\n"
"dst_data = (convert_uchar4(con) != (uchar4)(0)) ? dst_data : dVal;\n"
"*D = dst_data;\n"
"}\n"
"}\n"
"__kernel void remapLNF1Constant_C1_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global float * map1,  __global float * map2, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"x = x << 2;\n"
"int gx = x - (dst_offset&3);\n"
"int4 Gx = (int4)(gx, gx+1, gx+2, gx+3);\n"
"uchar4 nval =convert_uchar4(nVal);\n"
"uchar4 val = (uchar4)(nval.s0);\n"
"int dstStart = (y * dst_step + x  + dst_offset) - (dst_offset&3);\n"
"int map1Start = y * map1_step + (x << 2) + map1_offset - ((dst_offset & 3) << 2);\n"
"float4 map1_data;\n"
"float4 map2_data;\n"
"map1_data = *((__global float4 *)((__global char*)map1 + map1Start));\n"
"map2_data = *((__global float4 *)((__global char*)map2 + map1Start));\n"
"float8 map_data = (float8)(map1_data.s0, map2_data.s0, map1_data.s1, map2_data.s1, map1_data.s2, map2_data.s2, map1_data.s3, map2_data.s3);\n"
"int8 map1_dataD = convert_int8(map_data);\n"
"float8 temp = map_data - convert_float8(map1_dataD);\n"
"float4 u = temp.even;\n"
"float4 v = temp.odd;\n"
"float4 ud = (float4)(1.0) - u;\n"
"float4 vd = (float4)(1.0) - v;\n"
"int4 map1_dataDx = map1_dataD.even;\n"
"int4 map1_dataDy = map1_dataD.odd;\n"
"int4 map1_dataDx1 = map1_dataDx + (int4)(1);\n"
"int4 map1_dataDy1 = map1_dataDy + (int4)(1);\n"
"uchar4 a = val, b = val, c = val, d =val;\n"
"if (map1_dataDx.s0 < src_cols && map1_dataDx.s0 >= 0 && map1_dataDy.s0 < src_rows && map1_dataDy.s0 >= 0)\n"
"a.s0 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s0 * src_step + map1_dataDx.s0 + src_offset));\n"
"if (map1_dataDx.s1 < src_cols && map1_dataDx.s1 >= 0 && map1_dataDy.s1 < src_rows && map1_dataDy.s1 >= 0)\n"
"a.s1 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s1 * src_step + map1_dataDx.s1 + src_offset));\n"
"if (map1_dataDx.s2 < src_cols && map1_dataDx.s2 >= 0 && map1_dataDy.s2 < src_rows && map1_dataDy.s2 >= 0)\n"
"a.s2 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s2 * src_step + map1_dataDx.s2 + src_offset));\n"
"if (map1_dataDx.s3 < src_cols && map1_dataDx.s3 >= 0 && map1_dataDy.s3 < src_rows && map1_dataDy.s3 >= 0)\n"
"a.s3 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s3 * src_step + map1_dataDx.s3 + src_offset));\n"
"if (map1_dataDx1.s0 < src_cols && map1_dataDx1.s0 >= 0 && map1_dataDy.s0 < src_rows && map1_dataDy.s0 >= 0)\n"
"b.s0 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s0 * src_step + map1_dataDx1.s0 + src_offset));\n"
"if (map1_dataDx1.s1 < src_cols && map1_dataDx1.s1 >= 0 && map1_dataDy.s1 < src_rows && map1_dataDy.s1 >= 0)\n"
"b.s1 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s1 * src_step + map1_dataDx1.s1 + src_offset));\n"
"if (map1_dataDx1.s2 < src_cols && map1_dataDx1.s2 >= 0 && map1_dataDy.s2 < src_rows && map1_dataDy.s2 >= 0)\n"
"b.s2 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s2 * src_step + map1_dataDx1.s2 + src_offset));\n"
"if (map1_dataDx1.s3 < src_cols && map1_dataDx1.s3 >= 0 && map1_dataDy.s3 < src_rows && map1_dataDy.s3 >= 0)\n"
"b.s3 = *((__global uchar*)((__global uchar *)src + map1_dataDy.s3 * src_step + map1_dataDx1.s3 + src_offset));\n"
"if (map1_dataDx.s0 < src_cols && map1_dataDx.s0 >= 0 && map1_dataDy1.s0 < src_rows && map1_dataDy1.s0 >= 0)\n"
"c.s0 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s0 * src_step + map1_dataDx.s0 + src_offset));\n"
"if (map1_dataDx.s1 < src_cols && map1_dataDx.s1 >= 0 && map1_dataDy1.s1 < src_rows && map1_dataDy1.s1 >= 0)\n"
"c.s1 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s1 * src_step + map1_dataDx.s1 + src_offset));\n"
"if (map1_dataDx.s2 < src_cols && map1_dataDx.s2 >= 0 && map1_dataDy1.s2 < src_rows && map1_dataDy1.s2 >= 0)\n"
"c.s2 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s2 * src_step + map1_dataDx.s2 + src_offset));\n"
"if (map1_dataDx.s3 < src_cols && map1_dataDx.s3 >= 0 && map1_dataDy1.s3 < src_rows && map1_dataDy1.s3 >= 0)\n"
"c.s3 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s3 * src_step + map1_dataDx.s3 + src_offset));\n"
"if (map1_dataDx1.s0 < src_cols && map1_dataDx1.s0 >= 0 && map1_dataDy1.s0 < src_rows && map1_dataDy1.s0 >= 0)\n"
"d.s0 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s0 * src_step + map1_dataDx1.s0 + src_offset));\n"
"if (map1_dataDx1.s1 < src_cols && map1_dataDx1.s1 >= 0 && map1_dataDy1.s1 < src_rows && map1_dataDy1.s1 >= 0)\n"
"d.s1 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s1 * src_step + map1_dataDx1.s1 + src_offset));\n"
"if (map1_dataDx1.s2 < src_cols && map1_dataDx1.s2 >= 0 && map1_dataDy1.s2 < src_rows && map1_dataDy1.s2 >= 0)\n"
"d.s2 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s2 * src_step + map1_dataDx1.s2 + src_offset));\n"
"if (map1_dataDx1.s3 < src_cols && map1_dataDx1.s3 >= 0 && map1_dataDy1.s3 < src_rows && map1_dataDy1.s3 >= 0)\n"
"d.s3 = *((__global uchar*)((__global uchar *)src + map1_dataDy1.s3 * src_step + map1_dataDx1.s3 + src_offset));\n"
"uchar4 dst_data = convert_uchar4_sat_rte((convert_float4(a))* ud * vd +(convert_float4(b))* u * vd + (convert_float4(c))* ud * v + (convert_float4(d)) * u * v );\n"
"__global uchar4* D = (__global uchar4 *)(dst + dstStart);\n"
"uchar4 dVal = *D;\n"
"int4 con = (Gx >= 0 && Gx < dst_cols && y >= 0 && y < dst_rows);\n"
"dst_data = (convert_uchar4(con) != (uchar4)(0)) ? dst_data : dVal;\n"
"*D = dst_data;\n"
"}\n"
"}\n"
"__kernel void remapLNFConstant_C4_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global float * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 2) + dst_offset;\n"
"int mapIdx = y * map1_step + (x << 3) + map1_offset;\n"
"float2 map_data = *((__global float2 *)((__global char*)map1 + mapIdx));\n"
"int2 map_dataA = convert_int2(map_data);\n"
"float2 u = map_data - convert_float2(map_dataA);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y +1);\n"
"uchar4 nval = convert_uchar4(nVal);\n"
"uchar4 a, b, c , d;\n"
"if(map_dataA.x < 0 || map_dataA.x >= src_cols || map_dataA.y >= src_rows || map_dataA.y < 0)\n"
"a = nval;\n"
"else\n"
"a = *((__global uchar4 *)((__global uchar *)src + map_dataA.y * src_step + (map_dataA.x<<2) + src_offset ));\n"
"if(map_dataB.x < 0 || map_dataB.x >= src_cols || map_dataB.y >= src_rows || map_dataB.y < 0)\n"
"b = nval;\n"
"else\n"
"b = *((__global uchar4 *)((__global uchar *)src + map_dataB.y * src_step + (map_dataB.x<<2) + src_offset ));\n"
"if(map_dataC.x < 0 || map_dataC.x >= src_cols || map_dataC.y >= src_rows || map_dataC.y < 0)\n"
"c = nval;\n"
"else\n"
"c = *((__global uchar4 *)((__global uchar *)src + map_dataC.y * src_step + (map_dataC.x<<2) + src_offset ));\n"
"if(map_dataD.x < 0 || map_dataD.x >= src_cols || map_dataD.y >= src_rows || map_dataD.y < 0)\n"
"d = nval;\n"
"else\n"
"d = *((__global uchar4 *)((__global uchar *)src + map_dataD.y * src_step + (map_dataD.x<<2) + src_offset ));\n"
"float4 dst_data = convert_float4(a)*((float4)(1.0-u.x)*((float4)(1.0-u.y))) + convert_float4(b)*((float4)(u.x))*((float4)(1.0-u.y)) + convert_float4(c)*((float4)(1.0-u.x))*((float4)(u.y)) + convert_float4(d)*((float4)(u.x))*((float4)(u.y));\n"
"*((__global uchar4 *)((__global uchar*)dst + dstIdx)) = convert_uchar4_sat_rte(dst_data);\n"
"}\n"
"}\n"
"__kernel void remapLNF1Constant_C4_D0(__global unsigned char* dst, __global unsigned char const * restrict  src,\n"
"__global float * map1,  __global float * map2, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 2) + dst_offset;\n"
"int mapIdx = y * map1_step + (x << 2) + map1_offset;\n"
"float map1_data = *((__global float *)((__global char*)map1 + mapIdx));\n"
"float map2_data = *((__global float *)((__global char*)map2 + mapIdx));\n"
"float2 map_data = (float2)(map1_data, map2_data);\n"
"int2 map_dataA = convert_int2(map_data);\n"
"float2 u = map_data - convert_float2(map_dataA);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y +1);\n"
"uchar4 nval = convert_uchar4(nVal);\n"
"uchar4 a, b, c , d;\n"
"if(map_dataA.x < 0 || map_dataA.x >= src_cols || map_dataA.y >= src_rows || map_dataA.y < 0)\n"
"a = nval;\n"
"else\n"
"a = *((__global uchar4 *)((__global uchar *)src + map_dataA.y * src_step + (map_dataA.x<<2) + src_offset ));\n"
"if(map_dataB.x < 0 || map_dataB.x >= src_cols || map_dataB.y >= src_rows || map_dataB.y < 0)\n"
"b = nval;\n"
"else\n"
"b = *((__global uchar4 *)((__global uchar *)src + map_dataB.y * src_step + (map_dataB.x<<2) + src_offset ));\n"
"if(map_dataC.x < 0 || map_dataC.x >= src_cols || map_dataC.y >= src_rows || map_dataC.y < 0)\n"
"c = nval;\n"
"else\n"
"c = *((__global uchar4 *)((__global uchar *)src + map_dataC.y * src_step + (map_dataC.x<<2) + src_offset ));\n"
"if(map_dataD.x < 0 || map_dataD.x >= src_cols || map_dataD.y >= src_rows || map_dataD.y < 0)\n"
"d = nval;\n"
"else\n"
"d = *((__global uchar4 *)((__global uchar *)src + map_dataD.y * src_step + (map_dataD.x<<2) + src_offset ));\n"
"float4 dst_data = convert_float4(a)*((float4)(1.0-u.x)*((float4)(1.0-u.y))) + convert_float4(b)*((float4)(u.x))*((float4)(1.0-u.y)) + convert_float4(c)*((float4)(1.0-u.x))*((float4)(u.y)) + convert_float4(d)*((float4)(u.x))*((float4)(u.y));\n"
"*((__global uchar4 *)((__global uchar*)dst + dstIdx)) = convert_uchar4_sat_rte(dst_data);\n"
"}\n"
"}\n"
"__kernel void remapLNFConstant_C1_D5(__global float* dst, __global float const * restrict  src,\n"
"__global float * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"x = x << 4;\n"
"int gx = x - (dst_offset&15);\n"
"int4 Gx = (int4)(gx, gx+4, gx+8, gx+12);\n"
"float4 nval =convert_float4(nVal);\n"
"float4 val = (float4)(nval.s0);\n"
"int dstStart = (y * dst_step + x  + dst_offset) - (dst_offset&15);\n"
"int map1Start = y * map1_step + (x << 1) + map1_offset - ((dst_offset & 15) << 1);\n"
"float8 map1_data;\n"
"map1_data = *((__global float8 *)((__global char*)map1 + map1Start));\n"
"int8 map1_dataD = convert_int8(map1_data);\n"
"float8 temp = map1_data - convert_float8(map1_dataD);\n"
"float4 u = temp.even;\n"
"float4 v = temp.odd;\n"
"float4 ud = (float4)(1.0) - u;\n"
"float4 vd = (float4)(1.0) - v;\n"
"int4 map1_dataDx = map1_dataD.even;\n"
"int4 map1_dataDy = map1_dataD.odd;\n"
"int4 map1_dataDx1 = map1_dataDx + (int4)(1);\n"
"int4 map1_dataDy1 = map1_dataDy + (int4)(1);\n"
"float4 a = val, b = val, c = val, d = val;\n"
"if (map1_dataDx.s0 < src_cols && map1_dataDx.s0 >= 0 && map1_dataDy.s0 < src_rows && map1_dataDy.s0 >= 0)\n"
"a.s0 = *((__global float*)((__global uchar *)src + map1_dataDy.s0 * src_step + (map1_dataDx.s0 << 2) + src_offset));\n"
"if (map1_dataDx.s1 < src_cols && map1_dataDx.s1 >= 0 && map1_dataDy.s1 < src_rows && map1_dataDy.s1 >= 0)\n"
"a.s1 = *((__global float*)((__global uchar *)src + map1_dataDy.s1 * src_step + (map1_dataDx.s1 << 2) + src_offset));\n"
"if (map1_dataDx.s2 < src_cols && map1_dataDx.s2 >= 0 && map1_dataDy.s2 < src_rows && map1_dataDy.s2 >= 0)\n"
"a.s2 = *((__global float*)((__global uchar *)src + map1_dataDy.s2 * src_step + (map1_dataDx.s2 << 2) + src_offset));\n"
"if (map1_dataDx.s3 < src_cols && map1_dataDx.s3 >= 0 && map1_dataDy.s3 < src_rows && map1_dataDy.s3 >= 0)\n"
"a.s3 = *((__global float*)((__global uchar *)src + map1_dataDy.s3 * src_step + (map1_dataDx.s3 << 2) + src_offset));\n"
"if (map1_dataDx1.s0 < src_cols && map1_dataDx1.s0 >= 0 && map1_dataDy.s0 < src_rows && map1_dataDy.s0 >= 0)\n"
"b.s0 = *((__global float*)((__global uchar *)src + map1_dataDy.s0 * src_step + (map1_dataDx1.s0 << 2) + src_offset));\n"
"if (map1_dataDx1.s1 < src_cols && map1_dataDx1.s1 >= 0 && map1_dataDy.s1 < src_rows && map1_dataDy.s1 >= 0)\n"
"b.s1 = *((__global float*)((__global uchar *)src + map1_dataDy.s1 * src_step + (map1_dataDx1.s1 << 2) + src_offset));\n"
"if (map1_dataDx1.s2 < src_cols && map1_dataDx1.s2 >= 0 && map1_dataDy.s2 < src_rows && map1_dataDy.s2 >= 0)\n"
"b.s2 = *((__global float*)((__global uchar *)src + map1_dataDy.s2 * src_step + (map1_dataDx1.s2 << 2) + src_offset));\n"
"if (map1_dataDx1.s3 < src_cols && map1_dataDx1.s3 >= 0 && map1_dataDy.s3 < src_rows && map1_dataDy.s3 >= 0)\n"
"b.s3 = *((__global float*)((__global uchar *)src + map1_dataDy.s3 * src_step + (map1_dataDx1.s3 << 2) + src_offset));\n"
"if (map1_dataDx.s0 < src_cols && map1_dataDx.s0 >= 0 && map1_dataDy1.s0 < src_rows && map1_dataDy1.s0 >= 0)\n"
"c.s0 = *((__global float*)((__global uchar *)src + map1_dataDy1.s0 * src_step + (map1_dataDx.s0 << 2) + src_offset));\n"
"if (map1_dataDx.s1 < src_cols && map1_dataDx.s1 >= 0 && map1_dataDy1.s1 < src_rows && map1_dataDy1.s1 >= 0)\n"
"c.s1 = *((__global float*)((__global uchar *)src + map1_dataDy1.s1 * src_step + (map1_dataDx.s1 << 2) + src_offset));\n"
"if (map1_dataDx.s2 < src_cols && map1_dataDx.s2 >= 0 && map1_dataDy1.s2 < src_rows && map1_dataDy1.s2 >= 0)\n"
"c.s2 = *((__global float*)((__global uchar *)src + map1_dataDy1.s2 * src_step + (map1_dataDx.s2 << 2) + src_offset));\n"
"if (map1_dataDx.s3 < src_cols && map1_dataDx.s3 >= 0 && map1_dataDy1.s3 < src_rows && map1_dataDy1.s3 >= 0)\n"
"c.s3 = *((__global float*)((__global uchar *)src + map1_dataDy1.s3 * src_step + (map1_dataDx.s3 << 2) + src_offset));\n"
"if (map1_dataDx1.s0 < src_cols && map1_dataDx1.s0 >= 0 && map1_dataDy1.s0 < src_rows && map1_dataDy1.s0 >= 0)\n"
"d.s0 = *((__global float*)((__global uchar *)src + map1_dataDy1.s0 * src_step + (map1_dataDx1.s0 << 2) + src_offset));\n"
"if (map1_dataDx1.s1 < src_cols && map1_dataDx1.s1 >= 0 && map1_dataDy1.s1 < src_rows && map1_dataDy1.s1 >= 0)\n"
"d.s1 = *((__global float*)((__global uchar *)src + map1_dataDy1.s1 * src_step + (map1_dataDx1.s1 << 2) + src_offset));\n"
"if (map1_dataDx1.s2 < src_cols && map1_dataDx1.s2 >= 0 && map1_dataDy1.s2 < src_rows && map1_dataDy1.s2 >= 0)\n"
"d.s2 = *((__global float*)((__global uchar *)src + map1_dataDy1.s2 * src_step + (map1_dataDx1.s2 << 2) + src_offset));\n"
"if (map1_dataDx1.s3 < src_cols && map1_dataDx1.s3 >= 0 && map1_dataDy1.s3 < src_rows && map1_dataDy1.s3 >= 0)\n"
"d.s3 = *((__global float*)((__global uchar *)src + map1_dataDy1.s3 * src_step + (map1_dataDx1.s3 << 2) + src_offset));\n"
"float4 dst_data = a * ud * vd + b * u * vd + c * ud * v + d * u * v ;\n"
"__global float4* D = (__global float4 *)((__global char*)dst + dstStart);\n"
"float4 dVal = *D;\n"
"int4 con = (Gx >= 0 && Gx < (dst_cols << 2) && y >= 0 && y < dst_rows);\n"
"dst_data = (convert_float4(con) != (float4)(0)) ? dst_data : dVal;\n"
"*D = dst_data;\n"
"}\n"
"}\n"
"__kernel void remapLNF1Constant_C1_D5(__global float* dst, __global float const * restrict  src,\n"
"__global float * map1, __global float * map2, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"x = x << 4;\n"
"int gx = x - (dst_offset&15);\n"
"int4 Gx = (int4)(gx, gx+4, gx+8, gx+12);\n"
"float4 nval =convert_float4(nVal);\n"
"float4 val = (float4)(nval.s0);\n"
"int dstStart = y * dst_step + x  + dst_offset - (dst_offset & 15);\n"
"int map1Start = y * map1_step + x + map1_offset - (dst_offset & 15);\n"
"float4 map1_data;\n"
"float4 map2_data;\n"
"map1_data = *((__global float4 *)((__global char*)map1 + map1Start));\n"
"map2_data = *((__global float4 *)((__global char*)map2 + map1Start));\n"
"float8 map_data = (float8)(map1_data.s0, map2_data.s0, map1_data.s1, map2_data.s1, map1_data.s2, map2_data.s2, map1_data.s3, map2_data.s3);\n"
"int8 map1_dataD = convert_int8(map_data);\n"
"float8 temp = map_data - convert_float8(map1_dataD);\n"
"float4 u = temp.even;\n"
"float4 v = temp.odd;\n"
"float4 ud = (float4)(1.0) - u;\n"
"float4 vd = (float4)(1.0) - v;\n"
"int4 map1_dataDx = map1_dataD.even;\n"
"int4 map1_dataDy = map1_dataD.odd;\n"
"int4 map1_dataDx1 = map1_dataDx + (int4)(1);\n"
"int4 map1_dataDy1 = map1_dataDy + (int4)(1);\n"
"float4 a = val, b = val, c = val, d = val;\n"
"if (map1_dataDx.s0 < src_cols && map1_dataDx.s0 >= 0 && map1_dataDy.s0 < src_rows && map1_dataDy.s0 >= 0)\n"
"a.s0 = *((__global float*)((__global uchar *)src + map1_dataDy.s0 * src_step + (map1_dataDx.s0 << 2) + src_offset));\n"
"if (map1_dataDx.s1 < src_cols && map1_dataDx.s1 >= 0 && map1_dataDy.s1 < src_rows && map1_dataDy.s1 >= 0)\n"
"a.s1 = *((__global float*)((__global uchar *)src + map1_dataDy.s1 * src_step + (map1_dataDx.s1 << 2) + src_offset));\n"
"if (map1_dataDx.s2 < src_cols && map1_dataDx.s2 >= 0 && map1_dataDy.s2 < src_rows && map1_dataDy.s2 >= 0)\n"
"a.s2 = *((__global float*)((__global uchar *)src + map1_dataDy.s2 * src_step + (map1_dataDx.s2 << 2) + src_offset));\n"
"if (map1_dataDx.s3 < src_cols && map1_dataDx.s3 >= 0 && map1_dataDy.s3 < src_rows && map1_dataDy.s3 >= 0)\n"
"a.s3 = *((__global float*)((__global uchar *)src + map1_dataDy.s3 * src_step + (map1_dataDx.s3 << 2) + src_offset));\n"
"if (map1_dataDx1.s0 < src_cols && map1_dataDx1.s0 >= 0 && map1_dataDy.s0 < src_rows && map1_dataDy.s0 >= 0)\n"
"b.s0 = *((__global float*)((__global uchar *)src + map1_dataDy.s0 * src_step + (map1_dataDx1.s0 << 2) + src_offset));\n"
"if (map1_dataDx1.s1 < src_cols && map1_dataDx1.s1 >= 0 && map1_dataDy.s1 < src_rows && map1_dataDy.s1 >= 0)\n"
"b.s1 = *((__global float*)((__global uchar *)src + map1_dataDy.s1 * src_step + (map1_dataDx1.s1 << 2) + src_offset));\n"
"if (map1_dataDx1.s2 < src_cols && map1_dataDx1.s2 >= 0 && map1_dataDy.s2 < src_rows && map1_dataDy.s2 >= 0)\n"
"b.s2 = *((__global float*)((__global uchar *)src + map1_dataDy.s2 * src_step + (map1_dataDx1.s2 << 2) + src_offset));\n"
"if (map1_dataDx1.s3 < src_cols && map1_dataDx1.s3 >= 0 && map1_dataDy.s3 < src_rows && map1_dataDy.s3 >= 0)\n"
"b.s3 = *((__global float*)((__global uchar *)src + map1_dataDy.s3 * src_step + (map1_dataDx1.s3 << 2) + src_offset));\n"
"if (map1_dataDx.s0 < src_cols && map1_dataDx.s0 >= 0 && map1_dataDy1.s0 < src_rows && map1_dataDy1.s0 >= 0)\n"
"c.s0 = *((__global float*)((__global uchar *)src + map1_dataDy1.s0 * src_step + (map1_dataDx.s0 << 2) + src_offset));\n"
"if (map1_dataDx.s1 < src_cols && map1_dataDx.s1 >= 0 && map1_dataDy1.s1 < src_rows && map1_dataDy1.s1 >= 0)\n"
"c.s1 = *((__global float*)((__global uchar *)src + map1_dataDy1.s1 * src_step + (map1_dataDx.s1 << 2) + src_offset));\n"
"if (map1_dataDx.s2 < src_cols && map1_dataDx.s2 >= 0 && map1_dataDy1.s2 < src_rows && map1_dataDy1.s2 >= 0)\n"
"c.s2 = *((__global float*)((__global uchar *)src + map1_dataDy1.s2 * src_step + (map1_dataDx.s2 << 2) + src_offset));\n"
"if (map1_dataDx.s3 < src_cols && map1_dataDx.s3 >= 0 && map1_dataDy1.s3 < src_rows && map1_dataDy1.s3 >= 0)\n"
"c.s3 = *((__global float*)((__global uchar *)src + map1_dataDy1.s3 * src_step + (map1_dataDx.s3 << 2) + src_offset));\n"
"if (map1_dataDx1.s0 < src_cols && map1_dataDx1.s0 >= 0 && map1_dataDy1.s0 < src_rows && map1_dataDy1.s0 >= 0)\n"
"d.s0 = *((__global float*)((__global uchar *)src + map1_dataDy1.s0 * src_step + (map1_dataDx1.s0 << 2) + src_offset));\n"
"if (map1_dataDx1.s1 < src_cols && map1_dataDx1.s1 >= 0 && map1_dataDy1.s1 < src_rows && map1_dataDy1.s1 >= 0)\n"
"d.s1 = *((__global float*)((__global uchar *)src + map1_dataDy1.s1 * src_step + (map1_dataDx1.s1 << 2) + src_offset));\n"
"if (map1_dataDx1.s2 < src_cols && map1_dataDx1.s2 >= 0 && map1_dataDy1.s2 < src_rows && map1_dataDy1.s2 >= 0)\n"
"d.s2 = *((__global float*)((__global uchar *)src + map1_dataDy1.s2 * src_step + (map1_dataDx1.s2 << 2) + src_offset));\n"
"if (map1_dataDx1.s3 < src_cols && map1_dataDx1.s3 >= 0 && map1_dataDy1.s3 < src_rows && map1_dataDy1.s3 >= 0)\n"
"d.s3 = *((__global float*)((__global uchar *)src + map1_dataDy1.s3 * src_step + (map1_dataDx1.s3 << 2) + src_offset));\n"
"float4 dst_data = a * ud * vd + b * u * vd + c * ud * v + d * u * v ;\n"
"__global float4* D = (__global float4 *)((__global char*)dst + dstStart);\n"
"float4 dVal = *D;\n"
"int4 con = (Gx >= 0 && Gx < (dst_cols << 2) && y >= 0 && y < dst_rows);\n"
"dst_data = (convert_float4(con) != (float4)(0)) ? dst_data : dVal;\n"
"*D = dst_data;\n"
"}\n"
"}\n"
"__kernel void remapLNFConstant_C4_D5(__global float * dst, __global float const * restrict  src,\n"
"__global float * map1, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 4) + dst_offset  ;\n"
"int mapIdx = y * map1_step + (x << 3) + map1_offset ;\n"
"float2 map_data = *((__global float2 *)((__global char*)map1 + mapIdx));\n"
"int2 map_dataA = convert_int2(map_data);\n"
"float2 u = map_data - convert_float2(map_dataA);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y +1);\n"
"float4 nval = convert_float4(nVal);\n"
"float4 a, b, c , d;\n"
"if(map_dataA.x < 0 || map_dataA.x >= src_cols || map_dataA.y >= src_rows || map_dataA.y < 0)\n"
"a = nval;\n"
"else\n"
"a = *((__global float4 *)((__global uchar *)src + map_dataA.y * src_step + (map_dataA.x<<4) + src_offset ));\n"
"if(map_dataB.x < 0 || map_dataB.x >= src_cols || map_dataB.y >= src_rows || map_dataB.y < 0)\n"
"b = nval;\n"
"else\n"
"b = *((__global float4 *)((__global uchar *)src + map_dataB.y * src_step + (map_dataB.x<<4) + src_offset ));\n"
"if(map_dataC.x < 0 || map_dataC.x >= src_cols || map_dataC.y >= src_rows || map_dataC.y < 0)\n"
"c = nval;\n"
"else\n"
"c = *((__global float4 *)((__global uchar *)src + map_dataC.y * src_step + (map_dataC.x<<4) + src_offset ));\n"
"if(map_dataD.x < 0 || map_dataD.x >= src_cols || map_dataD.y >= src_rows || map_dataD.y < 0)\n"
"d = nval;\n"
"else\n"
"d = *((__global float4 *)((__global uchar *)src + map_dataD.y * src_step + (map_dataD.x<<4) + src_offset ));\n"
"float4 dst_data = a * ((float4)(1.0-u.x)) * ((float4)(1.0-u.y)) + b *((float4)(u.x)) * ((float4)(1.0-u.y)) + c * ((float4)(1.0-u.x)) *((float4)(u.y)) + d *((float4)(u.x)) *((float4)(u.y));\n"
"*((__global float4 *)((__global uchar*)dst + dstIdx)) =  dst_data ;\n"
"}\n"
"}\n"
"__kernel void remapLNF1Constant_C4_D5(__global float * dst, __global float const * restrict  src,\n"
"__global float * map1, __global float * map2, int dst_offset, int src_offset, int map1_offset, int dst_step, int src_step,\n"
"int map1_step, int src_cols, int src_rows, int dst_cols, int dst_rows, int map1_cols, int map1_rows , int threadCols, F4 nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < threadCols && y < dst_rows)\n"
"{\n"
"int dstIdx = y * dst_step + (x << 4) + dst_offset  ;\n"
"int mapIdx = y * map1_step + (x << 2) + map1_offset ;\n"
"float map1_data = *((__global float *)((__global char*)map1 + mapIdx));\n"
"float map2_data = *((__global float *)((__global char*)map2 + mapIdx));\n"
"float2 map_data = (float2)(map1_data, map2_data);\n"
"int2 map_dataA = convert_int2(map_data);\n"
"float2 u = map_data - convert_float2(map_dataA);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y +1);\n"
"float4 nval = convert_float4(nVal);\n"
"float4 a, b, c , d;\n"
"if(map_dataA.x < 0 || map_dataA.x >= src_cols || map_dataA.y >= src_rows || map_dataA.y < 0)\n"
"a = nval;\n"
"else\n"
"a = *((__global float4 *)((__global uchar *)src + map_dataA.y * src_step + (map_dataA.x<<4) + src_offset ));\n"
"if(map_dataB.x < 0 || map_dataB.x >= src_cols || map_dataB.y >= src_rows || map_dataB.y < 0)\n"
"b = nval;\n"
"else\n"
"b = *((__global float4 *)((__global uchar *)src + map_dataB.y * src_step + (map_dataB.x<<4) + src_offset ));\n"
"if(map_dataC.x < 0 || map_dataC.x >= src_cols || map_dataC.y >= src_rows || map_dataC.y < 0)\n"
"c = nval;\n"
"else\n"
"c = *((__global float4 *)((__global uchar *)src + map_dataC.y * src_step + (map_dataC.x<<4) + src_offset ));\n"
"if(map_dataD.x < 0 || map_dataD.x >= src_cols || map_dataD.y >= src_rows || map_dataD.y < 0)\n"
"d = nval;\n"
"else\n"
"d = *((__global float4 *)((__global uchar *)src + map_dataD.y * src_step + (map_dataD.x<<4) + src_offset ));\n"
"float4 dst_data = a * ((float4)(1.0-u.x)) * ((float4)(1.0-u.y)) + b *((float4)(u.x)) * ((float4)(1.0-u.y)) + c * ((float4)(1.0-u.x)) *((float4)(u.y)) + d *((float4)(u.x)) *((float4)(u.y));\n"
"*((__global float4 *)((__global uchar*)dst + dstIdx)) =  dst_data ;\n"
"}\n"
"}\n"
;
const char* imgproc_resize="#if defined DOUBLE_SUPPORT\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#define F double\n"
"#else\n"
"#define F float\n"
"#endif\n"
"#define INTER_RESIZE_COEF_BITS 11\n"
"#define INTER_RESIZE_COEF_SCALE (1 << INTER_RESIZE_COEF_BITS)\n"
"#define CAST_BITS (INTER_RESIZE_COEF_BITS << 1)\n"
"#define CAST_SCALE (1.0f/(1<<CAST_BITS))\n"
"#define INC(x,l) ((x+1) >= (l) ? (x):((x)+1))\n"
"__kernel void resizeLN_C1_D0(__global uchar * dst, __global uchar const * restrict src,\n"
"int dstoffset_in_pixel, int srcoffset_in_pixel,int dststep_in_pixel, int srcstep_in_pixel,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n"
"{\n"
"int gx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"float4  sx, u, xf;\n"
"int4 x, DX;\n"
"gx = (gx<<2) - (dstoffset_in_pixel&3);\n"
"DX = (int4)(gx, gx+1, gx+2, gx+3);\n"
"sx = (convert_float4(DX) + 0.5f) * ifx - 0.5f;\n"
"xf = floor(sx);\n"
"x = convert_int4(xf);\n"
"u = sx - xf;\n"
"float sy = ((dy+0.5f) * ify - 0.5f);\n"
"int y = floor(sy);\n"
"float v = sy - y;\n"
"u = x < 0 ? 0 : u;\n"
"u = (x >= src_cols) ? 0 : u;\n"
"x = x < 0 ? 0 : x;\n"
"x = (x >= src_cols) ? src_cols-1 : x;\n"
"y<0 ? y=0,v=0 : y;\n"
"y>=src_rows ? y=src_rows-1,v=0 : y;\n"
"int4 U, U1;\n"
"int V, V1;\n"
"float4 utmp1, utmp2;\n"
"float vtmp;\n"
"float4 scale_vec = INTER_RESIZE_COEF_SCALE;\n"
"utmp1 = u * scale_vec;\n"
"utmp2 = scale_vec - utmp1;\n"
"U = convert_int4(rint(utmp1));\n"
"U1 = convert_int4(rint(utmp2));\n"
"vtmp = v * INTER_RESIZE_COEF_SCALE;\n"
"V = rint(vtmp);\n"
"V1= rint(INTER_RESIZE_COEF_SCALE - vtmp);\n"
"int y_ = INC(y,src_rows);\n"
"int4 x_;\n"
"x_ =  ((x+1 >= src_cols) != 0) ? x : x+1;\n"
"int4 val1, val2, val;\n"
"int4 sdata1, sdata2, sdata3, sdata4;\n"
"int4 pos1 = mad24((int4)y, (int4)srcstep_in_pixel, x+(int4)srcoffset_in_pixel);\n"
"int4 pos2 = mad24((int4)y, (int4)srcstep_in_pixel, x_+(int4)srcoffset_in_pixel);\n"
"int4 pos3 = mad24((int4)y_, (int4)srcstep_in_pixel, x+(int4)srcoffset_in_pixel);\n"
"int4 pos4 = mad24((int4)y_, (int4)srcstep_in_pixel, x_+(int4)srcoffset_in_pixel);\n"
"sdata1.s0 = src[pos1.s0];\n"
"sdata1.s1 = src[pos1.s1];\n"
"sdata1.s2 = src[pos1.s2];\n"
"sdata1.s3 = src[pos1.s3];\n"
"sdata2.s0 = src[pos2.s0];\n"
"sdata2.s1 = src[pos2.s1];\n"
"sdata2.s2 = src[pos2.s2];\n"
"sdata2.s3 = src[pos2.s3];\n"
"sdata3.s0 = src[pos3.s0];\n"
"sdata3.s1 = src[pos3.s1];\n"
"sdata3.s2 = src[pos3.s2];\n"
"sdata3.s3 = src[pos3.s3];\n"
"sdata4.s0 = src[pos4.s0];\n"
"sdata4.s1 = src[pos4.s1];\n"
"sdata4.s2 = src[pos4.s2];\n"
"sdata4.s3 = src[pos4.s3];\n"
"val1 = mul24(U1 , sdata1) + mul24(U , sdata2);\n"
"val2 = mul24(U1 , sdata3) + mul24(U , sdata4);\n"
"val = mul24((int4)V1 , val1) + mul24((int4)V , val2);\n"
"val = ((val + (1<<(CAST_BITS-1))) >> CAST_BITS);\n"
"pos4 = mad24(dy, dststep_in_pixel, gx+dstoffset_in_pixel);\n"
"pos4.y++;\n"
"pos4.z+=2;\n"
"pos4.w+=3;\n"
"uchar4 uval = convert_uchar4_sat(val);\n"
"int con = (gx >= 0 && gx+3 < dst_cols && dy >= 0 && dy < dst_rows && (dstoffset_in_pixel&3)==0);\n"
"if(con)\n"
"{\n"
"*(__global uchar4*)(dst + pos4.x)=uval;\n"
"}\n"
"else\n"
"{\n"
"if(gx >= 0 && gx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"dst[pos4.x]=uval.x;\n"
"}\n"
"if(gx+1 >= 0 && gx+1 < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"dst[pos4.y]=uval.y;\n"
"}\n"
"if(gx+2 >= 0 && gx+2 < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"dst[pos4.z]=uval.z;\n"
"}\n"
"if(gx+3 >= 0 && gx+3 < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"dst[pos4.w]=uval.w;\n"
"}\n"
"}\n"
"}\n"
"__kernel void resizeLN_C4_D0(__global uchar4 * dst, __global uchar4 * src,\n"
"int dstoffset_in_pixel, int srcoffset_in_pixel,int dststep_in_pixel, int srcstep_in_pixel,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"float sx = ((dx+0.5f) * ifx - 0.5f), sy = ((dy+0.5f) * ify - 0.5f);\n"
"int x = floor(sx), y = floor(sy);\n"
"float u = sx - x, v = sy - y;\n"
"x<0 ? x=0,u=0 : x,u;\n"
"x>=src_cols ? x=src_cols-1,u=0 : x,u;\n"
"y<0 ? y=0,v=0 : y,v;\n"
"y>=src_rows ? y=src_rows-1,v=0 : y,v;\n"
"u = u * INTER_RESIZE_COEF_SCALE;\n"
"v = v * INTER_RESIZE_COEF_SCALE;\n"
"int U = rint(u);\n"
"int V = rint(v);\n"
"int U1= rint(INTER_RESIZE_COEF_SCALE - u);\n"
"int V1= rint(INTER_RESIZE_COEF_SCALE - v);\n"
"int y_ = INC(y,src_rows);\n"
"int x_ = INC(x,src_cols);\n"
"int4 srcpos;\n"
"srcpos.x = mad24(y, srcstep_in_pixel, x+srcoffset_in_pixel);\n"
"srcpos.y = mad24(y, srcstep_in_pixel, x_+srcoffset_in_pixel);\n"
"srcpos.z = mad24(y_, srcstep_in_pixel, x+srcoffset_in_pixel);\n"
"srcpos.w = mad24(y_, srcstep_in_pixel, x_+srcoffset_in_pixel);\n"
"int4 data0 = convert_int4(src[srcpos.x]);\n"
"int4 data1 = convert_int4(src[srcpos.y]);\n"
"int4 data2 = convert_int4(src[srcpos.z]);\n"
"int4 data3 = convert_int4(src[srcpos.w]);\n"
"int4 val = mul24((int4)mul24(U1, V1) ,  data0) + mul24((int4)mul24(U, V1) ,  data1)\n"
"+mul24((int4)mul24(U1, V) ,  data2)+mul24((int4)mul24(U, V) ,  data3);\n"
"int dstpos = mad24(dy, dststep_in_pixel, dx+dstoffset_in_pixel);\n"
"uchar4 uval =   convert_uchar4((val + (1<<(CAST_BITS-1)))>>CAST_BITS);\n"
"if(dx>=0 && dx<dst_cols && dy>=0 && dy<dst_rows)\n"
"dst[dstpos] = uval;\n"
"}\n"
"__kernel void resizeLN_C1_D5(__global float * dst, __global float * src,\n"
"int dstoffset_in_pixel, int srcoffset_in_pixel,int dststep_in_pixel, int srcstep_in_pixel,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"float sx = ((dx+0.5f) * ifx - 0.5f), sy = ((dy+0.5f) * ify - 0.5f);\n"
"int x = floor(sx), y = floor(sy);\n"
"float u = sx - x, v = sy - y;\n"
"x<0 ? x=0,u=0 : x,u;\n"
"x>=src_cols ? x=src_cols-1,u=0 : x,u;\n"
"y<0 ? y=0,v=0 : y,v;\n"
"y>=src_rows ? y=src_rows-1,v=0 : y,v;\n"
"int y_ = INC(y,src_rows);\n"
"int x_ = INC(x,src_cols);\n"
"float u1 = 1.f-u;\n"
"float v1 = 1.f-v;\n"
"int4 srcpos;\n"
"srcpos.x = mad24(y, srcstep_in_pixel, x+srcoffset_in_pixel);\n"
"srcpos.y = mad24(y, srcstep_in_pixel, x_+srcoffset_in_pixel);\n"
"srcpos.z = mad24(y_, srcstep_in_pixel, x+srcoffset_in_pixel);\n"
"srcpos.w = mad24(y_, srcstep_in_pixel, x_+srcoffset_in_pixel);\n"
"float data0 = src[srcpos.x];\n"
"float data1 = src[srcpos.y];\n"
"float data2 = src[srcpos.z];\n"
"float data3 = src[srcpos.w];\n"
"float val1 = u1 *  data0 +\n"
"u  *  data1 ;\n"
"float val2 = u1 *  data2 +\n"
"u *  data3;\n"
"float val = v1 * val1 + v * val2;\n"
"int dstpos = mad24(dy, dststep_in_pixel, dx+dstoffset_in_pixel);\n"
"if(dx>=0 && dx<dst_cols && dy>=0 && dy<dst_rows)\n"
"dst[dstpos] = val;\n"
"}\n"
"__kernel void resizeLN_C4_D5(__global float4 * dst, __global float4 * src,\n"
"int dstoffset_in_pixel, int srcoffset_in_pixel,int dststep_in_pixel, int srcstep_in_pixel,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"float sx = ((dx+0.5f) * ifx - 0.5f), sy = ((dy+0.5f) * ify - 0.5f);\n"
"int x = floor(sx), y = floor(sy);\n"
"float u = sx - x, v = sy - y;\n"
"x<0 ? x=0,u=0 : x;\n"
"x>=src_cols ? x=src_cols-1,u=0 : x;\n"
"y<0 ? y=0,v=0 : y;\n"
"y>=src_rows ? y=src_rows-1,v=0 : y;\n"
"int y_ = INC(y,src_rows);\n"
"int x_ = INC(x,src_cols);\n"
"float u1 = 1.f-u;\n"
"float v1 = 1.f-v;\n"
"int4 srcpos;\n"
"srcpos.x = mad24(y, srcstep_in_pixel, x+srcoffset_in_pixel);\n"
"srcpos.y = mad24(y, srcstep_in_pixel, x_+srcoffset_in_pixel);\n"
"srcpos.z = mad24(y_, srcstep_in_pixel, x+srcoffset_in_pixel);\n"
"srcpos.w = mad24(y_, srcstep_in_pixel, x_+srcoffset_in_pixel);\n"
"float4 s_data1, s_data2, s_data3, s_data4;\n"
"s_data1 = src[srcpos.x];\n"
"s_data2 = src[srcpos.y];\n"
"s_data3 = src[srcpos.z];\n"
"s_data4 = src[srcpos.w];\n"
"float4 val = u1 * v1 * s_data1 + u * v1 * s_data2\n"
"+u1 * v *s_data3 + u * v *s_data4;\n"
"int dstpos = mad24(dy, dststep_in_pixel, dx+dstoffset_in_pixel);\n"
"if(dx>=0 && dx<dst_cols && dy>=0 && dy<dst_rows)\n"
"dst[dstpos] = val;\n"
"}\n"
"__kernel void resizeNN_C1_D0(__global uchar * dst, __global uchar * src,\n"
"int dstoffset_in_pixel, int srcoffset_in_pixel,int dststep_in_pixel, int srcstep_in_pixel,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, F ifx, F ify )\n"
"{\n"
"int gx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"gx = (gx<<2) - (dstoffset_in_pixel&3);\n"
"int4 sx;\n"
"int sy;\n"
"F ss1 = gx*ifx;\n"
"F ss2 = (gx+1)*ifx;\n"
"F ss3 = (gx+2)*ifx;\n"
"F ss4 = (gx+3)*ifx;\n"
"F s5 = dy * ify;\n"
"sx.s0 = min((int)floor(ss1), src_cols-1);\n"
"sx.s1 = min((int)floor(ss2), src_cols-1);\n"
"sx.s2 = min((int)floor(ss3), src_cols-1);\n"
"sx.s3 = min((int)floor(ss4), src_cols-1);\n"
"sy = min((int)floor(s5), src_rows-1);\n"
"uchar4 val;\n"
"int4 pos = mad24((int4)sy, (int4)srcstep_in_pixel, sx+(int4)srcoffset_in_pixel);\n"
"val.s0 = src[pos.s0];\n"
"val.s1 = src[pos.s1];\n"
"val.s2 = src[pos.s2];\n"
"val.s3 = src[pos.s3];\n"
"pos = mad24(dy, dststep_in_pixel, gx+dstoffset_in_pixel);\n"
"pos.y++;\n"
"pos.z+=2;\n"
"pos.w+=3;\n"
"int con = (gx >= 0 && gx+3 < dst_cols && dy >= 0 && dy < dst_rows && (dstoffset_in_pixel&3)==0);\n"
"if(con)\n"
"{\n"
"*(__global uchar4*)(dst + pos.x)=val;\n"
"}\n"
"else\n"
"{\n"
"if(gx >= 0 && gx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"dst[pos.x]=val.x;\n"
"}\n"
"if(gx+1 >= 0 && gx+1 < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"dst[pos.y]=val.y;\n"
"}\n"
"if(gx+2 >= 0 && gx+2 < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"dst[pos.z]=val.z;\n"
"}\n"
"if(gx+3 >= 0 && gx+3 < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"dst[pos.w]=val.w;\n"
"}\n"
"}\n"
"}\n"
"__kernel void resizeNN_C4_D0(__global uchar4 * dst, __global uchar4 * src,\n"
"int dstoffset_in_pixel, int srcoffset_in_pixel,int dststep_in_pixel, int srcstep_in_pixel,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, F ifx, F ify )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"F s1 = dx*ifx;\n"
"F s2 = dy*ify;\n"
"int sx = fmin((float)floor(s1), (float)src_cols-1);\n"
"int sy = fmin((float)floor(s2), (float)src_rows-1);\n"
"int dpos = mad24(dy, dststep_in_pixel, dx + dstoffset_in_pixel);\n"
"int spos = mad24(sy, srcstep_in_pixel, sx + srcoffset_in_pixel);\n"
"if(dx>=0 && dx<dst_cols && dy>=0 && dy<dst_rows)\n"
"dst[dpos] = src[spos];\n"
"}\n"
"__kernel void resizeNN_C1_D5(__global float * dst, __global float * src,\n"
"int dstoffset_in_pixel, int srcoffset_in_pixel,int dststep_in_pixel, int srcstep_in_pixel,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, F ifx, F ify )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"F s1 = dx*ifx;\n"
"F s2 = dy*ify;\n"
"int sx = fmin((float)floor(s1), (float)src_cols-1);\n"
"int sy = fmin((float)floor(s2), (float)src_rows-1);\n"
"int dpos = mad24(dy, dststep_in_pixel, dx + dstoffset_in_pixel);\n"
"int spos = mad24(sy, srcstep_in_pixel, sx + srcoffset_in_pixel);\n"
"if(dx>=0 && dx<dst_cols && dy>=0 && dy<dst_rows)\n"
"dst[dpos] = src[spos];\n"
"}\n"
"__kernel void resizeNN_C4_D5(__global float4 * dst, __global float4 * src,\n"
"int dstoffset_in_pixel, int srcoffset_in_pixel,int dststep_in_pixel, int srcstep_in_pixel,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, F ifx, F ify )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"F s1 = dx*ifx;\n"
"F s2 = dy*ify;\n"
"int s_col = floor(s1);\n"
"int s_row = floor(s2);\n"
"int sx = min(s_col, src_cols-1);\n"
"int sy = min(s_row, src_rows-1);\n"
"int dpos = mad24(dy, dststep_in_pixel, dx + dstoffset_in_pixel);\n"
"int spos = mad24(sy, srcstep_in_pixel, sx + srcoffset_in_pixel);\n"
"if(dx>=0 && dx<dst_cols && dy>=0 && dy<dst_rows)\n"
"dst[dpos] = src[spos];\n"
"}\n"
;
const char* imgproc_threshold="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void threshold_C1_D0(__global const uchar * restrict src, __global uchar *dst,\n"
"int src_offset, int src_step,\n"
"int dst_offset, int dst_rows, int dst_cols, int dst_step,\n"
"uchar thresh, uchar max_val, int thresh_type\n"
")\n"
"{\n"
"int gx = get_global_id(0);\n"
"const int gy = get_global_id(1);\n"
"int offset = (dst_offset & 15);\n"
"src_offset -= offset;\n"
"int dstart = (gx << 4) - offset;\n"
"if(dstart < dst_cols && gy < dst_rows)\n"
"{\n"
"uchar16 sdata = vload16(gx, src+src_offset+gy*src_step);\n"
"uchar16 ddata;\n"
"uchar16 zero = 0;\n"
"switch (thresh_type)\n"
"{\n"
"case 0:\n"
"ddata = ((sdata > thresh) ) ? (uchar16)(max_val) : (uchar16)(0);\n"
"break;\n"
"case 1:\n"
"ddata = ((sdata > thresh)) ? zero  : (uchar16)(max_val);\n"
"break;\n"
"case 2:\n"
"ddata = ((sdata > thresh)) ? (uchar16)(thresh) : sdata;\n"
"break;\n"
"case 3:\n"
"ddata = ((sdata > thresh)) ? sdata : zero;\n"
"break;\n"
"case 4:\n"
"ddata = ((sdata > thresh)) ? zero : sdata;\n"
"break;\n"
"default:\n"
"ddata = sdata;\n"
"}\n"
"int16 dpos = (int16)(dstart, dstart+1, dstart+2, dstart+3, dstart+4, dstart+5, dstart+6, dstart+7, dstart+8,\n"
"dstart+9, dstart+10, dstart+11, dstart+12, dstart+13, dstart+14, dstart+15);\n"
"uchar16 dVal = *(__global uchar16*)(dst+dst_offset+gy*dst_step+dstart);\n"
"int16 con = dpos >= 0 && dpos < dst_cols;\n"
"ddata = convert_uchar16(con != 0) ? ddata : dVal;\n"
"if(dstart < dst_cols)\n"
"{\n"
"*(__global uchar16*)(dst+dst_offset+gy*dst_step+dstart) = ddata;\n"
"}\n"
"}\n"
"}\n"
"__kernel void threshold_C1_D5(__global const float * restrict src, __global float *dst,\n"
"int src_offset, int src_step,\n"
"int dst_offset, int dst_rows, int dst_cols, int dst_step,\n"
"float thresh, float max_val, int thresh_type\n"
")\n"
"{\n"
"const int gx = get_global_id(0);\n"
"const int gy = get_global_id(1);\n"
"int offset = (dst_offset & 3);\n"
"src_offset -= offset;\n"
"int dstart = (gx << 2) - offset;\n"
"if(dstart < dst_cols && gy < dst_rows)\n"
"{\n"
"float4 sdata = vload4(gx, src+src_offset+gy*src_step);\n"
"float4 ddata;\n"
"float4 zero = 0;\n"
"switch (thresh_type)\n"
"{\n"
"case 0:\n"
"ddata = sdata > thresh ? (float4)(max_val) : (float4)(0.f);\n"
"break;\n"
"case 1:\n"
"ddata = sdata > thresh ? zero : (float4)max_val;\n"
"break;\n"
"case 2:\n"
"ddata = sdata > thresh ? (float4)thresh : sdata;\n"
"break;\n"
"case 3:\n"
"ddata = sdata > thresh ? sdata : (float4)(0.f);\n"
"break;\n"
"case 4:\n"
"ddata = sdata > thresh ? (float4)(0.f) : sdata;\n"
"break;\n"
"default:\n"
"ddata = sdata;\n"
"}\n"
"int4 dpos = (int4)(dstart, dstart+1, dstart+2, dstart+3);\n"
"float4 dVal = *(__global float4*)(dst+dst_offset+gy*dst_step+dstart);\n"
"int4 con = dpos >= 0 && dpos < dst_cols;\n"
"ddata = convert_float4(con) != 0 ? ddata : dVal;\n"
"if(dstart < dst_cols)\n"
"{\n"
"*(__global float4*)(dst+dst_offset+gy*dst_step+dstart) = ddata;\n"
"}\n"
"}\n"
"}\n"
;
const char* imgproc_warpAffine="#if defined DOUBLE_SUPPORT\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"typedef double F;\n"
"typedef double4 F4;\n"
"#define convert_F4 convert_double4\n"
"#else\n"
"typedef float F;\n"
"typedef float4 F4;\n"
"#define convert_F4 convert_float4\n"
"#endif\n"
"#define INTER_BITS 5\n"
"#define INTER_TAB_SIZE (1 << INTER_BITS)\n"
"#define INTER_SCALE 1.f/INTER_TAB_SIZE\n"
"#define AB_BITS max(10, (int)INTER_BITS)\n"
"#define AB_SCALE (1 << AB_BITS)\n"
"#define INTER_REMAP_COEF_BITS 15\n"
"#define INTER_REMAP_COEF_SCALE (1 << INTER_REMAP_COEF_BITS)\n"
"inline void interpolateCubic( float x, float* coeffs )\n"
"{\n"
"const float A = -0.75f;\n"
"coeffs[0] = ((A*(x + 1.f) - 5.0f*A)*(x + 1.f) + 8.0f*A)*(x + 1.f) - 4.0f*A;\n"
"coeffs[1] = ((A + 2.f)*x - (A + 3.f))*x*x + 1.f;\n"
"coeffs[2] = ((A + 2.f)*(1.f - x) - (A + 3.f))*(1.f - x)*(1.f - x) + 1.f;\n"
"coeffs[3] = 1.f - coeffs[0] - coeffs[1] - coeffs[2];\n"
"}\n"
"__kernel void warpAffineNN_C1_D0(__global uchar const * restrict src, __global uchar * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"dx = (dx<<2) - (dst_offset&3);\n"
"int round_delta = (AB_SCALE>>1);\n"
"int4 X, Y;\n"
"int4 sx, sy;\n"
"int4 DX = (int4)(dx, dx+1, dx+2, dx+3);\n"
"DX = (DX << AB_BITS);\n"
"F4 M0DX, M3DX;\n"
"M0DX = M[0] * convert_F4(DX);\n"
"M3DX = M[3] * convert_F4(DX);\n"
"X = convert_int4(rint(M0DX));\n"
"Y = convert_int4(rint(M3DX));\n"
"int tmp1, tmp2;\n"
"tmp1 = rint((M[1]*dy + M[2]) * AB_SCALE);\n"
"tmp2 = rint((M[4]*dy + M[5]) * AB_SCALE);\n"
"X += tmp1 + round_delta;\n"
"Y += tmp2 + round_delta;\n"
"sx = convert_int4(convert_short4(X >> AB_BITS));\n"
"sy = convert_int4(convert_short4(Y >> AB_BITS));\n"
"__global uchar4 * d = (__global uchar4 *)(dst+dst_offset+dy*dstStep+dx);\n"
"uchar4 dval = *d;\n"
"DX = (int4)(dx, dx+1, dx+2, dx+3);\n"
"int4 dcon = DX >= 0 && DX < dst_cols && dy >= 0 && dy < dst_rows;\n"
"int4 scon = sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows;\n"
"int4 spos = src_offset + sy * srcStep + sx;\n"
"uchar4 sval;\n"
"sval.s0 = scon.s0 ? src[spos.s0] : 0;\n"
"sval.s1 = scon.s1 ? src[spos.s1] : 0;\n"
"sval.s2 = scon.s2 ? src[spos.s2] : 0;\n"
"sval.s3 = scon.s3 ? src[spos.s3] : 0;\n"
"dval = convert_uchar4(dcon != 0) ? sval : dval;\n"
"*d = dval;\n"
"}\n"
"}\n"
"__kernel void warpAffineLinear_C1_D0(__global const uchar * restrict src, __global uchar * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"dx = (dx<<2) - (dst_offset&3);\n"
"int round_delta = ((AB_SCALE >> INTER_BITS) >> 1);\n"
"int4 X, Y;\n"
"short4  ax, ay;\n"
"int4 sx, sy;\n"
"int4 DX = (int4)(dx, dx+1, dx+2, dx+3);\n"
"DX = (DX << AB_BITS);\n"
"F4 M0DX, M3DX;\n"
"M0DX = M[0] * convert_F4(DX);\n"
"M3DX = M[3] * convert_F4(DX);\n"
"X = convert_int4(rint(M0DX));\n"
"Y = convert_int4(rint(M3DX));\n"
"int tmp1, tmp2;\n"
"tmp1 = rint((M[1]*dy + M[2]) * AB_SCALE);\n"
"tmp2 = rint((M[4]*dy + M[5]) * AB_SCALE);\n"
"X += tmp1 + round_delta;\n"
"Y += tmp2 + round_delta;\n"
"X = X >> (AB_BITS - INTER_BITS);\n"
"Y = Y >> (AB_BITS - INTER_BITS);\n"
"sx = convert_int4(convert_short4(X >> INTER_BITS));\n"
"sy = convert_int4(convert_short4(Y >> INTER_BITS));\n"
"ax = convert_short4(X & (INTER_TAB_SIZE-1));\n"
"ay = convert_short4(Y & (INTER_TAB_SIZE-1));\n"
"uchar4 v0, v1, v2,v3;\n"
"int4 scon0, scon1, scon2, scon3;\n"
"int4 spos0, spos1, spos2, spos3;\n"
"scon0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows);\n"
"scon1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows);\n"
"scon2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows);\n"
"scon3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows);\n"
"spos0 = src_offset + sy * srcStep + sx;\n"
"spos1 = src_offset + sy * srcStep + sx + 1;\n"
"spos2 = src_offset + (sy+1) * srcStep + sx;\n"
"spos3 = src_offset + (sy+1) * srcStep + sx + 1;\n"
"v0.s0 = scon0.s0 ? src[spos0.s0] : 0;\n"
"v1.s0 = scon1.s0 ? src[spos1.s0] : 0;\n"
"v2.s0 = scon2.s0 ? src[spos2.s0] : 0;\n"
"v3.s0 = scon3.s0 ? src[spos3.s0] : 0;\n"
"v0.s1 = scon0.s1 ? src[spos0.s1] : 0;\n"
"v1.s1 = scon1.s1 ? src[spos1.s1] : 0;\n"
"v2.s1 = scon2.s1 ? src[spos2.s1] : 0;\n"
"v3.s1 = scon3.s1 ? src[spos3.s1] : 0;\n"
"v0.s2 = scon0.s2 ? src[spos0.s2] : 0;\n"
"v1.s2 = scon1.s2 ? src[spos1.s2] : 0;\n"
"v2.s2 = scon2.s2 ? src[spos2.s2] : 0;\n"
"v3.s2 = scon3.s2 ? src[spos3.s2] : 0;\n"
"v0.s3 = scon0.s3 ? src[spos0.s3] : 0;\n"
"v1.s3 = scon1.s3 ? src[spos1.s3] : 0;\n"
"v2.s3 = scon2.s3 ? src[spos2.s3] : 0;\n"
"v3.s3 = scon3.s3 ? src[spos3.s3] : 0;\n"
"short4 itab0, itab1, itab2, itab3;\n"
"float4 taby, tabx;\n"
"taby = INTER_SCALE * convert_float4(ay);\n"
"tabx = INTER_SCALE * convert_float4(ax);\n"
"itab0 = convert_short4_sat(( (1.0f-taby)*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\n"
"itab1 = convert_short4_sat(( (1.0f-taby)*tabx * INTER_REMAP_COEF_SCALE ));\n"
"itab2 = convert_short4_sat(( taby*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\n"
"itab3 = convert_short4_sat(( taby*tabx * INTER_REMAP_COEF_SCALE ));\n"
"int4 val;\n"
"uchar4 tval;\n"
"val = convert_int4(v0) * convert_int4(itab0) + convert_int4(v1) * convert_int4(itab1)\n"
"+ convert_int4(v2) * convert_int4(itab2) + convert_int4(v3) * convert_int4(itab3);\n"
"tval = convert_uchar4_sat ( (val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n"
"__global uchar4 * d =(__global uchar4 *)(dst+dst_offset+dy*dstStep+dx);\n"
"uchar4 dval = *d;\n"
"DX = (int4)(dx, dx+1, dx+2, dx+3);\n"
"int4 dcon = DX >= 0 && DX < dst_cols && dy >= 0 && dy < dst_rows;\n"
"dval = convert_uchar4(dcon != 0) ? tval : dval;\n"
"*d = dval;\n"
"}\n"
"}\n"
"__kernel void warpAffineCubic_C1_D0(__global uchar * src, __global uchar * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = ((AB_SCALE>>INTER_BITS)>>1);\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"int X = X0 >> (AB_BITS - INTER_BITS);\n"
"int Y = Y0 >> (AB_BITS - INTER_BITS);\n"
"short sx = (short)(X >> INTER_BITS) - 1;\n"
"short sy = (short)(Y >> INTER_BITS) - 1;\n"
"short ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"uchar v[16];\n"
"int i, j;\n"
"#pragma unroll 4\n"
"for(i=0; i<4;  i++)\n"
"for(j=0; j<4;  j++)\n"
"{\n"
"v[i*4+j] = (sx+j >= 0 && sx+j < src_cols && sy+i >= 0 && sy+i < src_rows) ? src[src_offset+(sy+i) * srcStep + (sx+j)] : 0;\n"
"}\n"
"short itab[16];\n"
"float tab1y[4], tab1x[4];\n"
"float axx, ayy;\n"
"ayy = 1.f/INTER_TAB_SIZE * ay;\n"
"axx = 1.f/INTER_TAB_SIZE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"int isum = 0;\n"
"#pragma unroll 16\n"
"for( i=0; i<16; i++ )\n"
"{\n"
"F v = tab1y[(i>>2)] * tab1x[(i&3)];\n"
"isum += itab[i] = convert_short_sat( rint( v * INTER_REMAP_COEF_SCALE ) );\n"
"}\n"
"if( isum != INTER_REMAP_COEF_SCALE )\n"
"{\n"
"int k1, k2;\n"
"int diff = isum - INTER_REMAP_COEF_SCALE;\n"
"int Mk1=2, Mk2=2, mk1=2, mk2=2;\n"
"for( k1 = 2; k1 < 4; k1++ )\n"
"for( k2 = 2; k2 < 4; k2++ )\n"
"{\n"
"if( itab[(k1<<2)+k2] < itab[(mk1<<2)+mk2] )\n"
"mk1 = k1, mk2 = k2;\n"
"else if( itab[(k1<<2)+k2] > itab[(Mk1<<2)+Mk2] )\n"
"Mk1 = k1, Mk2 = k2;\n"
"}\n"
"diff<0 ? (itab[(Mk1<<2)+Mk2]=(short)(itab[(Mk1<<2)+Mk2]-diff)) : (itab[(mk1<<2)+mk2]=(short)(itab[(mk1<<2)+mk2]-diff));\n"
"}\n"
"if( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"int sum=0;\n"
"for ( i =0; i<16; i++ )\n"
"{\n"
"sum += v[i] * itab[i] ;\n"
"}\n"
"dst[dst_offset+dy*dstStep+dx] = convert_uchar_sat( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n"
"}\n"
"}\n"
"}\n"
"__kernel void warpAffineNN_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = (AB_SCALE >> 1);\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"int sx0 = (short)(X0 >> AB_BITS);\n"
"int sy0 = (short)(Y0 >> AB_BITS);\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>2)+dy*(dstStep>>2)+dx]= (sx0>=0 && sx0<src_cols && sy0>=0 && sy0<src_rows) ? src[(src_offset>>2)+sy0*(srcStep>>2)+sx0] : (uchar4)0;\n"
"}\n"
"}\n"
"__kernel void warpAffineLinear_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = AB_SCALE/INTER_TAB_SIZE/2;\n"
"src_offset = (src_offset>>2);\n"
"srcStep = (srcStep>>2);\n"
"int tmp = (dx << AB_BITS);\n"
"int X0 = rint(M[0] * tmp);\n"
"int Y0 = rint(M[3] * tmp);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"short sx0 = (short)(X0 >> INTER_BITS);\n"
"short sy0 = (short)(Y0 >> INTER_BITS);\n"
"short ax0 = (short)(X0 & (INTER_TAB_SIZE-1));\n"
"short ay0 = (short)(Y0 & (INTER_TAB_SIZE-1));\n"
"int4 v0, v1, v2, v3;\n"
"v0 = (sx0 >= 0 && sx0 < src_cols && sy0 >= 0 && sy0 < src_rows) ? convert_int4(src[src_offset+sy0 * srcStep + sx0]) : 0;\n"
"v1 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0 >= 0 && sy0 < src_rows) ? convert_int4(src[src_offset+sy0 * srcStep + sx0+1]) : 0;\n"
"v2 = (sx0 >= 0 && sx0 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? convert_int4(src[src_offset+(sy0+1) * srcStep + sx0]) : 0;\n"
"v3 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? convert_int4(src[src_offset+(sy0+1) * srcStep + sx0+1]) : 0;\n"
"int itab0, itab1, itab2, itab3;\n"
"float taby, tabx;\n"
"taby = 1.f/INTER_TAB_SIZE*ay0;\n"
"tabx = 1.f/INTER_TAB_SIZE*ax0;\n"
"itab0 = convert_short_sat(rint( (1.0f-taby)*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\n"
"itab1 = convert_short_sat(rint( (1.0f-taby)*tabx * INTER_REMAP_COEF_SCALE ));\n"
"itab2 = convert_short_sat(rint( taby*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\n"
"itab3 = convert_short_sat(rint( taby*tabx * INTER_REMAP_COEF_SCALE ));\n"
"int4 val;\n"
"val = v0 * itab0 +  v1 * itab1 + v2 * itab2 + v3 * itab3;\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>2)+dy*(dstStep>>2)+dx] =  convert_uchar4_sat ( (val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n"
"}\n"
"}\n"
"__kernel void warpAffineCubic_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = ((AB_SCALE>>INTER_BITS)>>1);\n"
"src_offset = (src_offset>>2);\n"
"srcStep = (srcStep>>2);\n"
"dst_offset = (dst_offset>>2);\n"
"dstStep = (dstStep>>2);\n"
"int tmp = (dx << AB_BITS);\n"
"int X0 = rint(M[0] * tmp);\n"
"int Y0 = rint(M[3] * tmp);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"int sx = (short)(X0 >> INTER_BITS) - 1;\n"
"int sy = (short)(Y0 >> INTER_BITS) - 1;\n"
"int ay = (short)(Y0 & (INTER_TAB_SIZE-1));\n"
"int ax = (short)(X0 & (INTER_TAB_SIZE-1));\n"
"uchar4 v[16];\n"
"int i,j;\n"
"#pragma unroll 4\n"
"for(i=0; i<4; i++)\n"
"for(j=0; j<4; j++)\n"
"{\n"
"v[i*4+j] = (sx+j >= 0 && sx+j < src_cols && sy+i >= 0 && sy+i < src_rows) ? (src[src_offset+(sy+i) * srcStep + (sx+j)])  : (uchar4)0;\n"
"}\n"
"int itab[16];\n"
"float tab1y[4], tab1x[4];\n"
"float axx, ayy;\n"
"ayy = INTER_SCALE * ay;\n"
"axx = INTER_SCALE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"int isum = 0;\n"
"#pragma unroll 16\n"
"for( i=0; i<16; i++ )\n"
"{\n"
"float tmp;\n"
"tmp = tab1y[(i>>2)] * tab1x[(i&3)] * INTER_REMAP_COEF_SCALE;\n"
"itab[i] = rint(tmp);\n"
"isum += itab[i];\n"
"}\n"
"if( isum != INTER_REMAP_COEF_SCALE )\n"
"{\n"
"int k1, k2;\n"
"int diff = isum - INTER_REMAP_COEF_SCALE;\n"
"int Mk1=2, Mk2=2, mk1=2, mk2=2;\n"
"for( k1 = 2; k1 < 4; k1++ )\n"
"for( k2 = 2; k2 < 4; k2++ )\n"
"{\n"
"if( itab[(k1<<2)+k2] < itab[(mk1<<2)+mk2] )\n"
"mk1 = k1, mk2 = k2;\n"
"else if( itab[(k1<<2)+k2] > itab[(Mk1<<2)+Mk2] )\n"
"Mk1 = k1, Mk2 = k2;\n"
"}\n"
"diff<0 ? (itab[(Mk1<<2)+Mk2]=(short)(itab[(Mk1<<2)+Mk2]-diff)) : (itab[(mk1<<2)+mk2]=(short)(itab[(mk1<<2)+mk2]-diff));\n"
"}\n"
"if( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"int4 sum=0;\n"
"for ( i =0; i<16; i++ )\n"
"{\n"
"sum += convert_int4(v[i]) * itab[i];\n"
"}\n"
"dst[dst_offset+dy*dstStep+dx] = convert_uchar4_sat( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n"
"}\n"
"}\n"
"}\n"
"__kernel void warpAffineNN_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = AB_SCALE/2;\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"short sx0 = (short)(X0 >> AB_BITS);\n"
"short sy0 = (short)(Y0 >> AB_BITS);\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>2)+dy*dstStep+dx]= (sx0>=0 && sx0<src_cols && sy0>=0 && sy0<src_rows) ? src[(src_offset>>2)+sy0*srcStep+sx0] : 0;\n"
"}\n"
"}\n"
"__kernel void warpAffineLinear_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = AB_SCALE/INTER_TAB_SIZE/2;\n"
"src_offset = (src_offset>>2);\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"short sx0 = (short)(X0 >> INTER_BITS);\n"
"short sy0 = (short)(Y0 >> INTER_BITS);\n"
"short ax0 = (short)(X0 & (INTER_TAB_SIZE-1));\n"
"short ay0 = (short)(Y0 & (INTER_TAB_SIZE-1));\n"
"float v0, v1, v2, v3;\n"
"v0 = (sx0 >= 0 && sx0 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0] : 0;\n"
"v1 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0+1] : 0;\n"
"v2 = (sx0 >= 0 && sx0 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0] : 0;\n"
"v3 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0+1] : 0;\n"
"float tab[4];\n"
"float taby[2], tabx[2];\n"
"taby[0] = 1.0 - 1.f/INTER_TAB_SIZE*ay0;\n"
"taby[1] = 1.f/INTER_TAB_SIZE*ay0;\n"
"tabx[0] = 1.0 - 1.f/INTER_TAB_SIZE*ax0;\n"
"tabx[1] = 1.f/INTER_TAB_SIZE*ax0;\n"
"tab[0] = taby[0] * tabx[0];\n"
"tab[1] = taby[0] * tabx[1];\n"
"tab[2] = taby[1] * tabx[0];\n"
"tab[3] = taby[1] * tabx[1];\n"
"float sum = 0;\n"
"sum += v0 * tab[0] +  v1 * tab[1] +  v2 * tab[2] +  v3 * tab[3];\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>2)+dy*dstStep+dx] = sum;\n"
"}\n"
"}\n"
"__kernel void warpAffineCubic_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = AB_SCALE/INTER_TAB_SIZE/2;\n"
"src_offset = (src_offset>>2);\n"
"dst_offset = (dst_offset>>2);\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"short sx = (short)(X0 >> INTER_BITS) - 1;\n"
"short sy = (short)(Y0 >> INTER_BITS) - 1;\n"
"short ay = (short)(Y0 & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X0 & (INTER_TAB_SIZE-1));\n"
"float v[16];\n"
"int i;\n"
"for(i=0; i<16;  i++)\n"
"v[i] = (sx+(i&3) >= 0 && sx+(i&3) < src_cols && sy+(i>>2) >= 0 && sy+(i>>2) < src_rows) ? src[src_offset+(sy+(i>>2)) * srcStep + (sx+(i&3))] : 0;\n"
"float tab[16];\n"
"float tab1y[4], tab1x[4];\n"
"float axx, ayy;\n"
"ayy = 1.f/INTER_TAB_SIZE * ay;\n"
"axx = 1.f/INTER_TAB_SIZE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"#pragma unroll 4\n"
"for( i=0; i<16; i++ )\n"
"{\n"
"tab[i] = tab1y[(i>>2)] * tab1x[(i&3)];\n"
"}\n"
"if( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"float sum = 0;\n"
"#pragma unroll 4\n"
"for ( i =0; i<16; i++ )\n"
"{\n"
"sum += v[i] * tab[i];\n"
"}\n"
"dst[dst_offset+dy*dstStep+dx] = sum;\n"
"}\n"
"}\n"
"}\n"
"__kernel void warpAffineNN_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = AB_SCALE/2;\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"short sx0 = (short)(X0 >> AB_BITS);\n"
"short sy0 = (short)(Y0 >> AB_BITS);\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>4)+dy*(dstStep>>2)+dx]= (sx0>=0 && sx0<src_cols && sy0>=0 && sy0<src_rows) ? src[(src_offset>>4)+sy0*(srcStep>>2)+sx0] : 0;\n"
"}\n"
"}\n"
"__kernel void warpAffineLinear_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = AB_SCALE/INTER_TAB_SIZE/2;\n"
"src_offset = (src_offset>>4);\n"
"dst_offset = (dst_offset>>4);\n"
"srcStep = (srcStep>>2);\n"
"dstStep = (dstStep>>2);\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"short sx0 = (short)(X0 >> INTER_BITS);\n"
"short sy0 = (short)(Y0 >> INTER_BITS);\n"
"short ax0 = (short)(X0 & (INTER_TAB_SIZE-1));\n"
"short ay0 = (short)(Y0 & (INTER_TAB_SIZE-1));\n"
"float4 v0, v1, v2, v3;\n"
"v0 = (sx0 >= 0 && sx0 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0] : 0;\n"
"v1 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0+1] : 0;\n"
"v2 = (sx0 >= 0 && sx0 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0] : 0;\n"
"v3 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0+1] : 0;\n"
"float tab[4];\n"
"float taby[2], tabx[2];\n"
"taby[0] = 1.0 - 1.f/INTER_TAB_SIZE*ay0;\n"
"taby[1] = 1.f/INTER_TAB_SIZE*ay0;\n"
"tabx[0] = 1.0 - 1.f/INTER_TAB_SIZE*ax0;\n"
"tabx[1] = 1.f/INTER_TAB_SIZE*ax0;\n"
"tab[0] = taby[0] * tabx[0];\n"
"tab[1] = taby[0] * tabx[1];\n"
"tab[2] = taby[1] * tabx[0];\n"
"tab[3] = taby[1] * tabx[1];\n"
"float4 sum = 0;\n"
"sum += v0 * tab[0] +  v1 * tab[1] +  v2 * tab[2] +  v3 * tab[3];\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[dst_offset+dy*dstStep+dx] = sum;\n"
"}\n"
"}\n"
"__kernel void warpAffineCubic_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"int round_delta = AB_SCALE/INTER_TAB_SIZE/2;\n"
"src_offset = (src_offset>>4);\n"
"dst_offset = (dst_offset>>4);\n"
"srcStep = (srcStep>>2);\n"
"dstStep = (dstStep>>2);\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"short sx = (short)(X0 >> INTER_BITS) - 1;\n"
"short sy = (short)(Y0 >> INTER_BITS) - 1;\n"
"short ay = (short)(Y0 & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X0 & (INTER_TAB_SIZE-1));\n"
"float4 v[16];\n"
"int i;\n"
"for(i=0; i<16;  i++)\n"
"v[i] = (sx+(i&3) >= 0 && sx+(i&3) < src_cols && sy+(i>>2) >= 0 && sy+(i>>2) < src_rows) ? src[src_offset+(sy+(i>>2)) * srcStep + (sx+(i&3))] : 0;\n"
"float tab[16];\n"
"float tab1y[4], tab1x[4];\n"
"float axx, ayy;\n"
"ayy = 1.f/INTER_TAB_SIZE * ay;\n"
"axx = 1.f/INTER_TAB_SIZE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"#pragma unroll 4\n"
"for( i=0; i<16; i++ )\n"
"{\n"
"tab[i] = tab1y[(i>>2)] * tab1x[(i&3)];\n"
"}\n"
"if( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"float4 sum = 0;\n"
"#pragma unroll 4\n"
"for ( i =0; i<16; i++ )\n"
"{\n"
"sum += v[i] * tab[i];\n"
"}\n"
"dst[dst_offset+dy*dstStep+dx] = sum;\n"
"}\n"
"}\n"
"}\n"
;
const char* imgproc_warpPerspective="#if defined DOUBLE_SUPPORT\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"typedef double F;\n"
"typedef double4 F4;\n"
"#define convert_F4 convert_double4\n"
"#else\n"
"typedef float F;\n"
"typedef float4 F4;\n"
"#define convert_F4 convert_float4\n"
"#endif\n"
"#define INTER_BITS 5\n"
"#define INTER_TAB_SIZE (1 << INTER_BITS)\n"
"#define INTER_SCALE 1.f/INTER_TAB_SIZE\n"
"#define AB_BITS max(10, (int)INTER_BITS)\n"
"#define AB_SCALE (1 << AB_BITS)\n"
"#define INTER_REMAP_COEF_BITS 15\n"
"#define INTER_REMAP_COEF_SCALE (1 << INTER_REMAP_COEF_BITS)\n"
"inline void interpolateCubic( float x, float* coeffs )\n"
"{\n"
"const float A = -0.75f;\n"
"coeffs[0] = ((A*(x + 1.f) - 5.0f*A)*(x + 1.f) + 8.0f*A)*(x + 1.f) - 4.0f*A;\n"
"coeffs[1] = ((A + 2.f)*x - (A + 3.f))*x*x + 1.f;\n"
"coeffs[2] = ((A + 2.f)*(1.f - x) - (A + 3.f))*(1.f - x)*(1.f - x) + 1.f;\n"
"coeffs[3] = 1.f - coeffs[0] - coeffs[1] - coeffs[2];\n"
"}\n"
"__kernel void warpPerspectiveNN_C1_D0(__global uchar const * restrict src, __global uchar * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"dx = (dx<<2) - (dst_offset&3);\n"
"F4 DX = (F4)(dx, dx+1, dx+2, dx+3);\n"
"F4 X0 = M[0]*DX + M[1]*dy + M[2];\n"
"F4 Y0 = M[3]*DX + M[4]*dy + M[5];\n"
"F4 W = M[6]*DX + M[7]*dy + M[8],one=1,zero=0;\n"
"W = (W!=zero) ? one/W : zero;\n"
"short4 X = convert_short4(rint(X0*W));\n"
"short4 Y = convert_short4(rint(Y0*W));\n"
"int4 sx = convert_int4(X);\n"
"int4 sy = convert_int4(Y);\n"
"int4 DXD = (int4)(dx, dx+1, dx+2, dx+3);\n"
"__global uchar4 * d = (__global uchar4 *)(dst+dst_offset+dy*dstStep+dx);\n"
"uchar4 dval = *d;\n"
"int4 dcon = DXD >= 0 && DXD < dst_cols && dy >= 0 && dy < dst_rows;\n"
"int4 scon = sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows;\n"
"int4 spos = src_offset + sy * srcStep + sx;\n"
"uchar4 sval;\n"
"sval.s0 = scon.s0 ? src[spos.s0] : 0;\n"
"sval.s1 = scon.s1 ? src[spos.s1] : 0;\n"
"sval.s2 = scon.s2 ? src[spos.s2] : 0;\n"
"sval.s3 = scon.s3 ? src[spos.s3] : 0;\n"
"dval = convert_uchar4(dcon != 0) ? sval : dval;\n"
"*d = dval;\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveLinear_C1_D0(__global const uchar * restrict src, __global uchar * dst,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\n"
"int dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? INTER_TAB_SIZE/W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"int sx = (short)(X >> INTER_BITS);\n"
"int sy = (short)(Y >> INTER_BITS);\n"
"int ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"int ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"uchar v[4];\n"
"int i;\n"
"#pragma unroll 4\n"
"for(i=0; i<4;  i++)\n"
"v[i] = (sx+(i&1) >= 0 && sx+(i&1) < src_cols && sy+(i>>1) >= 0 && sy+(i>>1) < src_rows) ? src[src_offset + (sy+(i>>1)) * srcStep + (sx+(i&1))] : 0;\n"
"short itab[4];\n"
"float tab1y[2], tab1x[2];\n"
"tab1y[0] = 1.0 - 1.f/INTER_TAB_SIZE*ay;\n"
"tab1y[1] = 1.f/INTER_TAB_SIZE*ay;\n"
"tab1x[0] = 1.0 - 1.f/INTER_TAB_SIZE*ax;\n"
"tab1x[1] = 1.f/INTER_TAB_SIZE*ax;\n"
"#pragma unroll 4\n"
"for(i=0; i<4;  i++)\n"
"{\n"
"float v = tab1y[(i>>1)] * tab1x[(i&1)];\n"
"itab[i] = convert_short_sat(rint( v * INTER_REMAP_COEF_SCALE ));\n"
"}\n"
"if(dx >=0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"int sum = 0;\n"
"for ( i =0; i<4; i++ )\n"
"{\n"
"sum += v[i] * itab[i] ;\n"
"}\n"
"dst[dst_offset+dy*dstStep+dx] = convert_uchar_sat ( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n"
"}\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveCubic_C1_D0(__global uchar * src, __global uchar * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? INTER_TAB_SIZE/W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx = (short)(X >> INTER_BITS) - 1;\n"
"short sy = (short)(Y >> INTER_BITS) - 1;\n"
"short ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"uchar v[16];\n"
"int i, j;\n"
"#pragma unroll 4\n"
"for(i=0; i<4;  i++)\n"
"for(j=0; j<4;  j++)\n"
"{\n"
"v[i*4+j] = (sx+j >= 0 && sx+j < src_cols && sy+i >= 0 && sy+i < src_rows) ? src[src_offset+(sy+i) * srcStep + (sx+j)] : 0;\n"
"}\n"
"short itab[16];\n"
"float tab1y[4], tab1x[4];\n"
"float axx, ayy;\n"
"ayy = 1.f/INTER_TAB_SIZE * ay;\n"
"axx = 1.f/INTER_TAB_SIZE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"int isum = 0;\n"
"#pragma unroll 16\n"
"for( i=0; i<16; i++ )\n"
"{\n"
"F v = tab1y[(i>>2)] * tab1x[(i&3)];\n"
"isum += itab[i] = convert_short_sat( rint( v * INTER_REMAP_COEF_SCALE ) );\n"
"}\n"
"if( isum != INTER_REMAP_COEF_SCALE )\n"
"{\n"
"int k1, k2;\n"
"int diff = isum - INTER_REMAP_COEF_SCALE;\n"
"int Mk1=2, Mk2=2, mk1=2, mk2=2;\n"
"for( k1 = 2; k1 < 4; k1++ )\n"
"for( k2 = 2; k2 < 4; k2++ )\n"
"{\n"
"if( itab[(k1<<2)+k2] < itab[(mk1<<2)+mk2] )\n"
"mk1 = k1, mk2 = k2;\n"
"else if( itab[(k1<<2)+k2] > itab[(Mk1<<2)+Mk2] )\n"
"Mk1 = k1, Mk2 = k2;\n"
"}\n"
"diff<0 ? (itab[(Mk1<<2)+Mk2]=(short)(itab[(Mk1<<2)+Mk2]-diff)) : (itab[(mk1<<2)+mk2]=(short)(itab[(mk1<<2)+mk2]-diff));\n"
"}\n"
"if( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"int sum=0;\n"
"for ( i =0; i<16; i++ )\n"
"{\n"
"sum += v[i] * itab[i] ;\n"
"}\n"
"dst[dst_offset+dy*dstStep+dx] = convert_uchar_sat( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n"
"}\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveNN_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\n"
"int dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? 1./W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx = (short)X;\n"
"short sy = (short)Y;\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>2)+dy*(dstStep>>2)+dx]= (sx>=0 && sx<src_cols && sy>=0 && sy<src_rows) ? src[(src_offset>>2)+sy*(srcStep>>2)+sx] : (uchar4)0;\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveLinear_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\n"
"int dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"src_offset = (src_offset>>2);\n"
"srcStep = (srcStep>>2);\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? INTER_TAB_SIZE/W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx = (short)(X >> INTER_BITS);\n"
"short sy = (short)(Y >> INTER_BITS);\n"
"short ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"int4 v0, v1, v2, v3;\n"
"v0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows) ? convert_int4(src[src_offset+sy * srcStep + sx]) : 0;\n"
"v1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows) ? convert_int4(src[src_offset+sy * srcStep + sx+1]) : 0;\n"
"v2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows) ? convert_int4(src[src_offset+(sy+1) * srcStep + sx]) : 0;\n"
"v3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows) ? convert_int4(src[src_offset+(sy+1) * srcStep + sx+1]) : 0;\n"
"int itab0, itab1, itab2, itab3;\n"
"float taby, tabx;\n"
"taby = 1.f/INTER_TAB_SIZE*ay;\n"
"tabx = 1.f/INTER_TAB_SIZE*ax;\n"
"itab0 = convert_short_sat(rint( (1.0f-taby)*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\n"
"itab1 = convert_short_sat(rint( (1.0f-taby)*tabx * INTER_REMAP_COEF_SCALE ));\n"
"itab2 = convert_short_sat(rint( taby*(1.0f-tabx) * INTER_REMAP_COEF_SCALE ));\n"
"itab3 = convert_short_sat(rint( taby*tabx * INTER_REMAP_COEF_SCALE ));\n"
"int4 val;\n"
"val = v0 * itab0 +  v1 * itab1 + v2 * itab2 + v3 * itab3;\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>2)+dy*(dstStep>>2)+dx] =  convert_uchar4_sat ( (val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveCubic_C4_D0(__global uchar4 const * restrict src, __global uchar4 * dst,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\n"
"int dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"src_offset = (src_offset>>2);\n"
"srcStep = (srcStep>>2);\n"
"dst_offset = (dst_offset>>2);\n"
"dstStep = (dstStep>>2);\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? INTER_TAB_SIZE/W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx = (short)(X >> INTER_BITS) - 1;\n"
"short sy = (short)(Y >> INTER_BITS) - 1;\n"
"short ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"uchar4 v[16];\n"
"int i,j;\n"
"#pragma unroll 4\n"
"for(i=0; i<4; i++)\n"
"for(j=0; j<4; j++)\n"
"{\n"
"v[i*4+j] = (sx+j >= 0 && sx+j < src_cols && sy+i >= 0 && sy+i < src_rows) ? (src[src_offset+(sy+i) * srcStep + (sx+j)])  : (uchar4)0;\n"
"}\n"
"int itab[16];\n"
"float tab1y[4], tab1x[4];\n"
"float axx, ayy;\n"
"ayy = INTER_SCALE * ay;\n"
"axx = INTER_SCALE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"int isum = 0;\n"
"#pragma unroll 16\n"
"for( i=0; i<16; i++ )\n"
"{\n"
"float tmp;\n"
"tmp = tab1y[(i>>2)] * tab1x[(i&3)] * INTER_REMAP_COEF_SCALE;\n"
"itab[i] = rint(tmp);\n"
"isum += itab[i];\n"
"}\n"
"if( isum != INTER_REMAP_COEF_SCALE )\n"
"{\n"
"int k1, k2;\n"
"int diff = isum - INTER_REMAP_COEF_SCALE;\n"
"int Mk1=2, Mk2=2, mk1=2, mk2=2;\n"
"for( k1 = 2; k1 < 4; k1++ )\n"
"for( k2 = 2; k2 < 4; k2++ )\n"
"{\n"
"if( itab[(k1<<2)+k2] < itab[(mk1<<2)+mk2] )\n"
"mk1 = k1, mk2 = k2;\n"
"else if( itab[(k1<<2)+k2] > itab[(Mk1<<2)+Mk2] )\n"
"Mk1 = k1, Mk2 = k2;\n"
"}\n"
"diff<0 ? (itab[(Mk1<<2)+Mk2]=(short)(itab[(Mk1<<2)+Mk2]-diff)) : (itab[(mk1<<2)+mk2]=(short)(itab[(mk1<<2)+mk2]-diff));\n"
"}\n"
"if( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"int4 sum=0;\n"
"for ( i =0; i<16; i++ )\n"
"{\n"
"sum += convert_int4(v[i]) * itab[i];\n"
"}\n"
"dst[dst_offset+dy*dstStep+dx] = convert_uchar4_sat( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ) ;\n"
"}\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveNN_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? 1./W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx = (short)X;\n"
"short sy = (short)Y;\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>2)+dy*dstStep+dx]= (sx>=0 && sx<src_cols && sy>=0 && sy<src_rows) ? src[(src_offset>>2)+sy*srcStep+sx] : 0;\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveLinear_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"src_offset = (src_offset>>2);\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? INTER_TAB_SIZE/W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx = (short)(X >> INTER_BITS);\n"
"short sy = (short)(Y >> INTER_BITS);\n"
"short ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"float v0, v1, v2, v3;\n"
"v0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows) ? src[src_offset+sy * srcStep + sx] : 0;\n"
"v1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows) ? src[src_offset+sy * srcStep + sx+1] : 0;\n"
"v2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows) ? src[src_offset+(sy+1) * srcStep + sx] : 0;\n"
"v3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows) ? src[src_offset+(sy+1) * srcStep + sx+1] : 0;\n"
"float tab[4];\n"
"float taby[2], tabx[2];\n"
"taby[0] = 1.0 - 1.f/INTER_TAB_SIZE*ay;\n"
"taby[1] = 1.f/INTER_TAB_SIZE*ay;\n"
"tabx[0] = 1.0 - 1.f/INTER_TAB_SIZE*ax;\n"
"tabx[1] = 1.f/INTER_TAB_SIZE*ax;\n"
"tab[0] = taby[0] * tabx[0];\n"
"tab[1] = taby[0] * tabx[1];\n"
"tab[2] = taby[1] * tabx[0];\n"
"tab[3] = taby[1] * tabx[1];\n"
"float sum = 0;\n"
"sum += v0 * tab[0] +  v1 * tab[1] +  v2 * tab[2] +  v3 * tab[3];\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>2)+dy*dstStep+dx] = sum;\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveCubic_C1_D5(__global float * src, __global float * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"src_offset = (src_offset>>2);\n"
"dst_offset = (dst_offset>>2);\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? INTER_TAB_SIZE/W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx = (short)(X >> INTER_BITS) - 1;\n"
"short sy = (short)(Y >> INTER_BITS) - 1;\n"
"short ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"float v[16];\n"
"int i;\n"
"for(i=0; i<16;  i++)\n"
"v[i] = (sx+(i&3) >= 0 && sx+(i&3) < src_cols && sy+(i>>2) >= 0 && sy+(i>>2) < src_rows) ? src[src_offset+(sy+(i>>2)) * srcStep + (sx+(i&3))] : 0;\n"
"float tab[16];\n"
"float tab1y[4], tab1x[4];\n"
"float axx, ayy;\n"
"ayy = 1.f/INTER_TAB_SIZE * ay;\n"
"axx = 1.f/INTER_TAB_SIZE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"#pragma unroll 4\n"
"for( i=0; i<16; i++ )\n"
"{\n"
"tab[i] = tab1y[(i>>2)] * tab1x[(i&3)];\n"
"}\n"
"if( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"float sum = 0;\n"
"#pragma unroll 4\n"
"for ( i =0; i<16; i++ )\n"
"{\n"
"sum += v[i] * tab[i];\n"
"}\n"
"dst[dst_offset+dy*dstStep+dx] = sum;\n"
"}\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveNN_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W =(W != 0.0)? 1./W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx = (short)X;\n"
"short sy = (short)Y;\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[(dst_offset>>4)+dy*(dstStep>>2)+dx]= (sx>=0 && sx<src_cols && sy>=0 && sy<src_rows) ? src[(src_offset>>4)+sy*(srcStep>>2)+sx] : 0;\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveLinear_C4_D5(__global float4 * src, __global float4 * dst, int src_cols, int src_rows,\n"
"int dst_cols, int dst_rows, int srcStep, int dstStep,\n"
"int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows)\n"
"{\n"
"src_offset = (src_offset>>4);\n"
"dst_offset = (dst_offset>>4);\n"
"srcStep = (srcStep>>2);\n"
"dstStep = (dstStep>>2);\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? INTER_TAB_SIZE/W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx0 = (short)(X >> INTER_BITS);\n"
"short sy0 = (short)(Y >> INTER_BITS);\n"
"short ay0 = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax0 = (short)(X & (INTER_TAB_SIZE-1));\n"
"float4 v0, v1, v2, v3;\n"
"v0 = (sx0 >= 0 && sx0 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0] : 0;\n"
"v1 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0 >= 0 && sy0 < src_rows) ? src[src_offset+sy0 * srcStep + sx0+1] : 0;\n"
"v2 = (sx0 >= 0 && sx0 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0] : 0;\n"
"v3 = (sx0+1 >= 0 && sx0+1 < src_cols && sy0+1 >= 0 && sy0+1 < src_rows) ? src[src_offset+(sy0+1) * srcStep + sx0+1] : 0;\n"
"float tab[4];\n"
"float taby[2], tabx[2];\n"
"taby[0] = 1.0 - 1.f/INTER_TAB_SIZE*ay0;\n"
"taby[1] = 1.f/INTER_TAB_SIZE*ay0;\n"
"tabx[0] = 1.0 - 1.f/INTER_TAB_SIZE*ax0;\n"
"tabx[1] = 1.f/INTER_TAB_SIZE*ax0;\n"
"tab[0] = taby[0] * tabx[0];\n"
"tab[1] = taby[0] * tabx[1];\n"
"tab[2] = taby[1] * tabx[0];\n"
"tab[3] = taby[1] * tabx[1];\n"
"float4 sum = 0;\n"
"sum += v0 * tab[0] +  v1 * tab[1] +  v2 * tab[2] +  v3 * tab[3];\n"
"if(dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"dst[dst_offset+dy*dstStep+dx] = sum;\n"
"}\n"
"}\n"
"__kernel void warpPerspectiveCubic_C4_D5(__global float4 * src, __global float4 * dst,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, int srcStep,\n"
"int dstStep, int src_offset, int dst_offset,  __constant F * M, int threadCols )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if( dx < threadCols && dy < dst_rows )\n"
"{\n"
"src_offset = (src_offset>>4);\n"
"dst_offset = (dst_offset>>4);\n"
"srcStep = (srcStep>>2);\n"
"dstStep = (dstStep>>2);\n"
"F X0 = M[0]*dx + M[1]*dy + M[2];\n"
"F Y0 = M[3]*dx + M[4]*dy + M[5];\n"
"F W = M[6]*dx + M[7]*dy + M[8];\n"
"W = (W != 0.0) ? INTER_TAB_SIZE/W : 0.0;\n"
"int X = rint(X0*W);\n"
"int Y = rint(Y0*W);\n"
"short sx = (short)(X >> INTER_BITS)-1;\n"
"short sy = (short)(Y >> INTER_BITS)-1;\n"
"short ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"float4 v[16];\n"
"int i;\n"
"for(i=0; i<16;  i++)\n"
"v[i] = (sx+(i&3) >= 0 && sx+(i&3) < src_cols && sy+(i>>2) >= 0 && sy+(i>>2) < src_rows) ? src[src_offset+(sy+(i>>2)) * srcStep + (sx+(i&3))] : 0;\n"
"float tab[16];\n"
"float tab1y[4], tab1x[4];\n"
"float axx, ayy;\n"
"ayy = 1.f/INTER_TAB_SIZE * ay;\n"
"axx = 1.f/INTER_TAB_SIZE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"#pragma unroll 4\n"
"for( i=0; i<16; i++ )\n"
"{\n"
"tab[i] = tab1y[(i>>2)] * tab1x[(i&3)];\n"
"}\n"
"if( dx >= 0 && dx < dst_cols && dy >= 0 && dy < dst_rows)\n"
"{\n"
"float4 sum = 0;\n"
"#pragma unroll 4\n"
"for ( i =0; i<16; i++ )\n"
"{\n"
"sum += v[i] * tab[i];\n"
"}\n"
"dst[dst_offset+dy*dstStep+dx] = sum;\n"
"}\n"
"}\n"
"}\n"
;
const char* interpolate_frames="#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n"
"__constant sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\n"
"inline void atomic_addf(volatile __global float *source, const float operand) {\n"
"union {\n"
"unsigned int intVal;\n"
"float floatVal;\n"
"} newVal;\n"
"union {\n"
"unsigned int intVal;\n"
"float floatVal;\n"
"} prevVal;\n"
"do {\n"
"prevVal.floatVal = *source;\n"
"newVal.floatVal = prevVal.floatVal + operand;\n"
"} while (atomic_cmpxchg((volatile __global unsigned int *)source, prevVal.intVal, newVal.intVal) != prevVal.intVal);\n"
"}\n"
"__kernel void memsetKernel(\n"
"float val,\n"
"__global float * image,\n"
"int width,\n"
"int height,\n"
"int step,\n"
"int offset\n"
")\n"
"{\n"
"if(get_global_id(0) >= width || get_global_id(1) >= height)\n"
"{\n"
"return;\n"
"}\n"
"image += offset;\n"
"image[get_global_id(0) + get_global_id(1) * step] = val;\n"
"}\n"
"__kernel void normalizeKernel(\n"
"__global float * buffer,\n"
"int width,\n"
"int height,\n"
"int step,\n"
"int f_offset,\n"
"int d_offset\n"
")\n"
"{\n"
"__global float * factors = buffer + f_offset;\n"
"__global float * dst     = buffer + d_offset;\n"
"int j = get_global_id(0);\n"
"int i = get_global_id(1);\n"
"if(j >= width || i >= height)\n"
"{\n"
"return;\n"
"}\n"
"float scale = factors[step * i + j];\n"
"float invScale = (scale == 0.0f) ? 1.0f : (1.0f / scale);\n"
"dst[step * i + j] *= invScale;\n"
"}\n"
"__kernel void forwardWarpKernel(\n"
"__global const float * src,\n"
"__global float * buffer,\n"
"__global const float * u,\n"
"__global const float * v,\n"
"const int w,\n"
"const int h,\n"
"const int flow_stride,\n"
"const int image_stride,\n"
"const int factor_offset,\n"
"const int dst_offset,\n"
"const float time_scale\n"
")\n"
"{\n"
"int j = get_global_id(0);\n"
"int i = get_global_id(1);\n"
"if (i >= h || j >= w) return;\n"
"volatile __global float * normalization_factor = (volatile __global float *) buffer + factor_offset;\n"
"volatile __global float * dst = (volatile __global float *)buffer + dst_offset;\n"
"int flow_row_offset  = i * flow_stride;\n"
"int image_row_offset = i * image_stride;\n"
"float cx = u[flow_row_offset + j] * time_scale + (float)j + 1.0f;\n"
"float cy = v[flow_row_offset + j] * time_scale + (float)i + 1.0f;\n"
"float px;\n"
"float py;\n"
"float dx = modf(cx, &px);\n"
"float dy = modf(cy, &py);\n"
"int tx;\n"
"int ty;\n"
"tx = (int) px;\n"
"ty = (int) py;\n"
"float value = src[image_row_offset + j];\n"
"float weight;\n"
"if (!((tx >= w) || (tx < 0) || (ty >= h) || (ty < 0)))\n"
"{\n"
"weight = dx * dy;\n"
"atomic_addf(dst + ty * image_stride + tx, value * weight);\n"
"atomic_addf(normalization_factor + ty * image_stride + tx, weight);\n"
"}\n"
"tx -= 1;\n"
"if (!((tx >= w) || (tx < 0) || (ty >= h) || (ty < 0)))\n"
"{\n"
"weight = (1.0f - dx) * dy;\n"
"atomic_addf(dst + ty * image_stride + tx, value * weight);\n"
"atomic_addf(normalization_factor + ty * image_stride + tx, weight);\n"
"}\n"
"ty -= 1;\n"
"if (!((tx >= w) || (tx < 0) || (ty >= h) || (ty < 0)))\n"
"{\n"
"weight = (1.0f - dx) * (1.0f - dy);\n"
"atomic_addf(dst + ty * image_stride + tx, value * weight);\n"
"atomic_addf(normalization_factor + ty * image_stride + tx, weight);\n"
"}\n"
"tx += 1;\n"
"if (!((tx >= w) || (tx < 0) || (ty >= h) || (ty < 0)))\n"
"{\n"
"weight = dx * (1.0f - dy);\n"
"atomic_addf(dst + ty * image_stride + tx, value * weight);\n"
"atomic_addf(normalization_factor + ty * image_stride + tx, weight);\n"
"}\n"
"}\n"
"enum\n"
"{\n"
"O0_OS = 0,\n"
"O1_OS,\n"
"U_OS,\n"
"V_OS,\n"
"UR_OS,\n"
"VR_OS\n"
"};\n"
"__kernel void blendFramesKernel(\n"
"image2d_t tex_src0,\n"
"image2d_t tex_src1,\n"
"__global float * buffer,\n"
"__global float * out,\n"
"int w,\n"
"int h,\n"
"int step,\n"
"float theta\n"
")\n"
"{\n"
"__global float * u  = buffer + h * step * U_OS;\n"
"__global float * v  = buffer + h * step * V_OS;\n"
"__global float * ur = buffer + h * step * UR_OS;\n"
"__global float * vr = buffer + h * step * VR_OS;\n"
"__global float * o0 = buffer + h * step * O0_OS;\n"
"__global float * o1 = buffer + h * step * O1_OS;\n"
"int ix = get_global_id(0);\n"
"int iy = get_global_id(1);\n"
"if(ix >= w || iy >= h) return;\n"
"int pos = ix + step * iy;\n"
"float _u  = u[pos];\n"
"float _v  = v[pos];\n"
"float _ur = ur[pos];\n"
"float _vr = vr[pos];\n"
"float x = (float)ix + 0.5f;\n"
"float y = (float)iy + 0.5f;\n"
"bool b0 = o0[pos] > 1e-4f;\n"
"bool b1 = o1[pos] > 1e-4f;\n"
"float2 coord0 = (float2)(x - _u * theta, y - _v * theta);\n"
"float2 coord1 = (float2)(x + _u * (1.0f - theta), y + _v * (1.0f - theta));\n"
"if (b0 && b1)\n"
"{\n"
"out[pos] = read_imagef(tex_src0, sampler, coord0).x * (1.0f - theta) +\n"
"read_imagef(tex_src1, sampler, coord1).x * theta;\n"
"}\n"
"else if (b0)\n"
"{\n"
"out[pos] = read_imagef(tex_src0, sampler, coord0).x;\n"
"}\n"
"else\n"
"{\n"
"out[pos] = read_imagef(tex_src1, sampler, coord1).x;\n"
"}\n"
"}\n"
;
const char* match_template="#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#define TYPE_IMAGE_SQSUM double\n"
"#else\n"
"#define TYPE_IMAGE_SQSUM float\n"
"#endif\n"
"#ifndef CN4\n"
"#define CN4 1\n"
"#else\n"
"#define CN4 4\n"
"#endif\n"
"#define SQSUMS_PTR(ox, oy) mad24(gidy + oy, img_sqsums_step, (gidx + img_sqsums_offset + ox) * CN4)\n"
"#define SUMS_PTR(ox, oy) mad24(gidy + oy, img_sums_step, gidx + img_sums_offset + ox)\n"
"float normAcc(float num, float denum)\n"
"{\n"
"if(fabs(num) < denum)\n"
"{\n"
"return num / denum;\n"
"}\n"
"if(fabs(num) < denum * 1.125f)\n"
"{\n"
"return num > 0 ? 1 : -1;\n"
"}\n"
"return 0;\n"
"}\n"
"float normAcc_SQDIFF(float num, float denum)\n"
"{\n"
"if(fabs(num) < denum)\n"
"{\n"
"return num / denum;\n"
"}\n"
"if(fabs(num) < denum * 1.125f)\n"
"{\n"
"return num > 0 ? 1 : -1;\n"
"}\n"
"return 1;\n"
"}\n"
"__kernel\n"
"void normalizeKernel_C1_D0\n"
"(\n"
"__global const float * img_sqsums,\n"
"__global float * res,\n"
"ulong tpl_sqsum,\n"
"int res_rows,\n"
"int res_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int img_sqsums_offset,\n"
"int img_sqsums_step,\n"
"int res_offset,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"img_sqsums_step /= sizeof(*img_sqsums);\n"
"img_sqsums_offset /= sizeof(*img_sqsums);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"float image_sqsum_ = (float)(\n"
"(img_sqsums[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(img_sqsums[SQSUMS_PTR(0, tpl_rows)] - img_sqsums[SQSUMS_PTR(0, 0)]));\n"
"res[res_idx] = normAcc(res[res_idx], sqrt(image_sqsum_ * tpl_sqsum));\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Prepared_SQDIFF_C1_D0\n"
"(\n"
"__global const TYPE_IMAGE_SQSUM * img_sqsums,\n"
"__global float * res,\n"
"ulong tpl_sqsum,\n"
"int res_rows,\n"
"int res_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int img_sqsums_offset,\n"
"int img_sqsums_step,\n"
"int res_offset,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"img_sqsums_step /= sizeof(*img_sqsums);\n"
"img_sqsums_offset /= sizeof(*img_sqsums);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"float image_sqsum_ = (float)(\n"
"(img_sqsums[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(img_sqsums[SQSUMS_PTR(0, tpl_rows)] - img_sqsums[SQSUMS_PTR(0, 0)]));\n"
"res[res_idx] = image_sqsum_ - 2.f * res[res_idx] + tpl_sqsum;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Prepared_SQDIFF_NORMED_C1_D0\n"
"(\n"
"__global const float * img_sqsums,\n"
"__global float * res,\n"
"ulong tpl_sqsum,\n"
"int res_rows,\n"
"int res_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int img_sqsums_offset,\n"
"int img_sqsums_step,\n"
"int res_offset,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"img_sqsums_step /= sizeof(*img_sqsums);\n"
"img_sqsums_offset /= sizeof(*img_sqsums);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"float image_sqsum_ = (float)(\n"
"(img_sqsums[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(img_sqsums[SQSUMS_PTR(0, tpl_rows)] - img_sqsums[SQSUMS_PTR(0, 0)]));\n"
"res[res_idx] = normAcc_SQDIFF(image_sqsum_ - 2.f * res[res_idx] + tpl_sqsum,\n"
"sqrt(image_sqsum_ * tpl_sqsum));\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Naive_SQDIFF_C1_D0\n"
"(\n"
"__global const uchar * img,\n"
"__global const uchar * tpl,\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int img_offset,\n"
"int tpl_offset,\n"
"int res_offset,\n"
"int img_step,\n"
"int tpl_step,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"int delta;\n"
"int sum = 0;\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const uchar * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n"
"__global const uchar * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"{\n"
"delta = img_ptr[j] - tpl_ptr[j];\n"
"sum   = mad24(delta, delta, sum);\n"
"}\n"
"}\n"
"res[res_idx] = sum;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Naive_SQDIFF_C1_D5\n"
"(\n"
"__global const float * img,\n"
"__global const float * tpl,\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int img_offset,\n"
"int tpl_offset,\n"
"int res_offset,\n"
"int img_step,\n"
"int tpl_step,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"float delta;\n"
"float sum = 0;\n"
"img_step   /= sizeof(*img);\n"
"img_offset /= sizeof(*img);\n"
"tpl_step   /= sizeof(*tpl);\n"
"tpl_offset /= sizeof(*tpl);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const float * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n"
"__global const float * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"{\n"
"delta = img_ptr[j] - tpl_ptr[j];\n"
"sum   = mad(delta, delta, sum);\n"
"}\n"
"}\n"
"res[res_idx] = sum;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Naive_SQDIFF_C4_D0\n"
"(\n"
"__global const uchar4 * img,\n"
"__global const uchar4 * tpl,\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int img_offset,\n"
"int tpl_offset,\n"
"int res_offset,\n"
"int img_step,\n"
"int tpl_step,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"int4 delta;\n"
"int4 sum = (int4)(0, 0, 0, 0);\n"
"img_step   /= sizeof(*img);\n"
"img_offset /= sizeof(*img);\n"
"tpl_step   /= sizeof(*tpl);\n"
"tpl_offset /= sizeof(*tpl);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const uchar4 * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n"
"__global const uchar4 * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"{\n"
"delta.x = img_ptr[j].x - tpl_ptr[j].x;\n"
"delta.y = img_ptr[j].y - tpl_ptr[j].y;\n"
"delta.z = img_ptr[j].z - tpl_ptr[j].z;\n"
"delta.w = img_ptr[j].w - tpl_ptr[j].w;\n"
"sum   = mad24(delta, delta, sum);\n"
"}\n"
"}\n"
"res[res_idx] = sum.x + sum.y + sum.z + sum.w;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Naive_SQDIFF_C4_D5\n"
"(\n"
"__global const float4 * img,\n"
"__global const float4 * tpl,\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int img_offset,\n"
"int tpl_offset,\n"
"int res_offset,\n"
"int img_step,\n"
"int tpl_step,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"float4 delta;\n"
"float4 sum = (float4)(0, 0, 0, 0);\n"
"img_step   /= sizeof(*img);\n"
"img_offset /= sizeof(*img);\n"
"tpl_step   /= sizeof(*tpl);\n"
"tpl_offset /= sizeof(*tpl);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const float4 * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n"
"__global const float4 * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"{\n"
"delta.x = img_ptr[j].x - tpl_ptr[j].x;\n"
"delta.y = img_ptr[j].y - tpl_ptr[j].y;\n"
"delta.z = img_ptr[j].z - tpl_ptr[j].z;\n"
"delta.w = img_ptr[j].w - tpl_ptr[j].w;\n"
"sum   = mad(delta, delta, sum);\n"
"}\n"
"}\n"
"res[res_idx] = sum.x + sum.y + sum.z + sum.w;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Naive_CCORR_C1_D0\n"
"(\n"
"__global const uchar * img,\n"
"__global const uchar * tpl,\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int img_offset,\n"
"int tpl_offset,\n"
"int res_offset,\n"
"int img_step,\n"
"int tpl_step,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"int sum = 0;\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const uchar * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n"
"__global const uchar * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"{\n"
"sum = mad24(img_ptr[j], tpl_ptr[j], sum);\n"
"}\n"
"}\n"
"res[res_idx] = sum;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Naive_CCORR_C1_D5\n"
"(\n"
"__global const float * img,\n"
"__global const float * tpl,\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int img_offset,\n"
"int tpl_offset,\n"
"int res_offset,\n"
"int img_step,\n"
"int tpl_step,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"float sum = 0;\n"
"img_step   /= sizeof(*img);\n"
"img_offset /= sizeof(*img);\n"
"tpl_step   /= sizeof(*tpl);\n"
"tpl_offset /= sizeof(*tpl);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const float * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n"
"__global const float * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"{\n"
"sum = mad(img_ptr[j], tpl_ptr[j], sum);\n"
"}\n"
"}\n"
"res[res_idx] = sum;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Naive_CCORR_C4_D0\n"
"(\n"
"__global const uchar4 * img,\n"
"__global const uchar4 * tpl,\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int img_offset,\n"
"int tpl_offset,\n"
"int res_offset,\n"
"int img_step,\n"
"int tpl_step,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"int4 sum = (int4)(0, 0, 0, 0);\n"
"img_step   /= sizeof(*img);\n"
"img_offset /= sizeof(*img);\n"
"tpl_step   /= sizeof(*tpl);\n"
"tpl_offset /= sizeof(*tpl);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const uchar4 * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n"
"__global const uchar4 * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"{\n"
"sum   = mad24(convert_int4(img_ptr[j]), convert_int4(tpl_ptr[j]), sum);\n"
"}\n"
"}\n"
"res[res_idx] = sum.x + sum.y + sum.z + sum.w;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Naive_CCORR_C4_D5\n"
"(\n"
"__global const float4 * img,\n"
"__global const float4 * tpl,\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int img_offset,\n"
"int tpl_offset,\n"
"int res_offset,\n"
"int img_step,\n"
"int tpl_step,\n"
"int res_step\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int i,j;\n"
"float4 sum = (float4)(0, 0, 0, 0);\n"
"img_step   /= sizeof(*img);\n"
"img_offset /= sizeof(*img);\n"
"tpl_step   /= sizeof(*tpl);\n"
"tpl_offset /= sizeof(*tpl);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"for(i = 0; i < tpl_rows; i ++)\n"
"{\n"
"__global const float4 * img_ptr = img + mad24(gidy + i, img_step, gidx + img_offset);\n"
"__global const float4 * tpl_ptr = tpl + mad24(i, tpl_step, tpl_offset);\n"
"for(j = 0; j < tpl_cols; j ++)\n"
"{\n"
"sum = mad(convert_float4(img_ptr[j]), convert_float4(tpl_ptr[j]), sum);\n"
"}\n"
"}\n"
"res[res_idx] = sum.x + sum.y + sum.z + sum.w;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Prepared_CCOFF_C1_D0\n"
"(\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int res_offset,\n"
"int res_step,\n"
"__global const uint * img_sums,\n"
"int img_sums_offset,\n"
"int img_sums_step,\n"
"float tpl_sum\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sums_offset   /= sizeof(*img_sums);\n"
"img_sums_step     /= sizeof(*img_sums);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"float sum = (float)(\n"
"(img_sums[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums[SUMS_PTR(0, tpl_rows)] - img_sums[SUMS_PTR(0, 0)]));\n"
"res[res_idx] -= sum * tpl_sum;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Prepared_CCOFF_C4_D0\n"
"(\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int res_offset,\n"
"int res_step,\n"
"__global const uint * img_sums_c0,\n"
"__global const uint * img_sums_c1,\n"
"__global const uint * img_sums_c2,\n"
"__global const uint * img_sums_c3,\n"
"int img_sums_offset,\n"
"int img_sums_step,\n"
"float tpl_sum_c0,\n"
"float tpl_sum_c1,\n"
"float tpl_sum_c2,\n"
"float tpl_sum_c3\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sums_offset   /= sizeof(*img_sums_c0);\n"
"img_sums_step     /= sizeof(*img_sums_c0);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"float ccorr = res[res_idx];\n"
"ccorr -= tpl_sum_c0*(float)(\n"
"(img_sums_c0[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c0[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums_c0[SUMS_PTR(0, tpl_rows)] - img_sums_c0[SUMS_PTR(0, 0)]));\n"
"ccorr -= tpl_sum_c1*(float)(\n"
"(img_sums_c1[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c1[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums_c1[SUMS_PTR(0, tpl_rows)] - img_sums_c1[SUMS_PTR(0, 0)]));\n"
"ccorr -= tpl_sum_c2*(float)(\n"
"(img_sums_c2[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c2[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums_c2[SUMS_PTR(0, tpl_rows)] - img_sums_c2[SUMS_PTR(0, 0)]));\n"
"ccorr -= tpl_sum_c3*(float)(\n"
"(img_sums_c3[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c3[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums_c3[SUMS_PTR(0, tpl_rows)] - img_sums_c3[SUMS_PTR(0, 0)]));\n"
"res[res_idx] = ccorr;\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Prepared_CCOFF_NORMED_C1_D0\n"
"(\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int res_offset,\n"
"int res_step,\n"
"float weight,\n"
"__global const uint * img_sums,\n"
"int img_sums_offset,\n"
"int img_sums_step,\n"
"__global const float * img_sqsums,\n"
"int img_sqsums_offset,\n"
"int img_sqsums_step,\n"
"float tpl_sum,\n"
"float tpl_sqsum\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sqsums_step   /= sizeof(*img_sqsums);\n"
"img_sqsums_offset /= sizeof(*img_sqsums);\n"
"img_sums_offset   /= sizeof(*img_sums);\n"
"img_sums_step     /= sizeof(*img_sums);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"float image_sum_ =  (float)(\n"
"(img_sums[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums[SUMS_PTR(0, tpl_rows)] - img_sums[SUMS_PTR(0, 0)]));\n"
"float image_sqsum_ = (float)(\n"
"(img_sqsums[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(img_sqsums[SQSUMS_PTR(0, tpl_rows)] - img_sqsums[SQSUMS_PTR(0, 0)]));\n"
"res[res_idx] = normAcc(res[res_idx] - image_sum_ * tpl_sum,\n"
"sqrt(tpl_sqsum * (image_sqsum_ - weight * image_sum_ * image_sum_)));\n"
"}\n"
"}\n"
"__kernel\n"
"void matchTemplate_Prepared_CCOFF_NORMED_C4_D0\n"
"(\n"
"__global float * res,\n"
"int img_rows,\n"
"int img_cols,\n"
"int tpl_rows,\n"
"int tpl_cols,\n"
"int res_rows,\n"
"int res_cols,\n"
"int res_offset,\n"
"int res_step,\n"
"float weight,\n"
"__global const uint * img_sums_c0,\n"
"__global const uint * img_sums_c1,\n"
"__global const uint * img_sums_c2,\n"
"__global const uint * img_sums_c3,\n"
"int img_sums_offset,\n"
"int img_sums_step,\n"
"__global const float * img_sqsums_c0,\n"
"__global const float * img_sqsums_c1,\n"
"__global const float * img_sqsums_c2,\n"
"__global const float * img_sqsums_c3,\n"
"int img_sqsums_offset,\n"
"int img_sqsums_step,\n"
"float tpl_sum_c0,\n"
"float tpl_sum_c1,\n"
"float tpl_sum_c2,\n"
"float tpl_sum_c3,\n"
"float tpl_sqsum\n"
")\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"img_sqsums_step   /= sizeof(*img_sqsums_c0);\n"
"img_sqsums_offset /= sizeof(*img_sqsums_c0);\n"
"img_sums_offset   /= sizeof(*img_sums_c0);\n"
"img_sums_step     /= sizeof(*img_sums_c0);\n"
"res_step   /= sizeof(*res);\n"
"res_offset /= sizeof(*res);\n"
"int res_idx = mad24(gidy, res_step, res_offset + gidx);\n"
"if(gidx < res_cols && gidy < res_rows)\n"
"{\n"
"float image_sum_c0 =  (float)(\n"
"(img_sums_c0[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c0[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums_c0[SUMS_PTR(0, tpl_rows)] - img_sums_c0[SUMS_PTR(0, 0)]));\n"
"float image_sum_c1 =  (float)(\n"
"(img_sums_c1[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c1[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums_c1[SUMS_PTR(0, tpl_rows)] - img_sums_c1[SUMS_PTR(0, 0)]));\n"
"float image_sum_c2 =  (float)(\n"
"(img_sums_c2[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c2[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums_c2[SUMS_PTR(0, tpl_rows)] - img_sums_c2[SUMS_PTR(0, 0)]));\n"
"float image_sum_c3 =  (float)(\n"
"(img_sums_c3[SUMS_PTR(tpl_cols, tpl_rows)] - img_sums_c3[SUMS_PTR(tpl_cols, 0)])\n"
"- (img_sums_c3[SUMS_PTR(0, tpl_rows)] - img_sums_c3[SUMS_PTR(0, 0)]));\n"
"float image_sqsum_c0 = (float)(\n"
"(img_sqsums_c0[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums_c0[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(img_sqsums_c0[SQSUMS_PTR(0, tpl_rows)] - img_sqsums_c0[SQSUMS_PTR(0, 0)]));\n"
"float image_sqsum_c1 = (float)(\n"
"(img_sqsums_c1[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums_c1[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(img_sqsums_c1[SQSUMS_PTR(0, tpl_rows)] - img_sqsums_c1[SQSUMS_PTR(0, 0)]));\n"
"float image_sqsum_c2 = (float)(\n"
"(img_sqsums_c2[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums_c2[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(img_sqsums_c2[SQSUMS_PTR(0, tpl_rows)] - img_sqsums_c2[SQSUMS_PTR(0, 0)]));\n"
"float image_sqsum_c3 = (float)(\n"
"(img_sqsums_c3[SQSUMS_PTR(tpl_cols, tpl_rows)] - img_sqsums_c3[SQSUMS_PTR(tpl_cols, 0)]) -\n"
"(img_sqsums_c3[SQSUMS_PTR(0, tpl_rows)] - img_sqsums_c3[SQSUMS_PTR(0, 0)]));\n"
"float num = res[res_idx] -\n"
"image_sum_c0 * tpl_sum_c0 -\n"
"image_sum_c1 * tpl_sum_c1 -\n"
"image_sum_c2 * tpl_sum_c2 -\n"
"image_sum_c3 * tpl_sum_c3;\n"
"float denum = sqrt( tpl_sqsum * (\n"
"image_sqsum_c0 - weight * image_sum_c0 * image_sum_c0 +\n"
"image_sqsum_c1 - weight * image_sum_c1 * image_sum_c1 +\n"
"image_sqsum_c2 - weight * image_sum_c2 * image_sum_c2 +\n"
"image_sqsum_c3 - weight * image_sum_c0 * image_sum_c3)\n"
");\n"
"res[res_idx] = normAcc(num, denum);\n"
"}\n"
"}\n"
"__kernel\n"
"void extractFirstChannel\n"
"(\n"
"const __global float4* img,\n"
"__global float* res,\n"
"int rows,\n"
"int cols,\n"
"int img_offset,\n"
"int res_offset,\n"
"int img_step,\n"
"int res_step\n"
")\n"
"{\n"
"img_step   /= sizeof(float4);\n"
"res_step   /= sizeof(float);\n"
"img_offset /= sizeof(float4);\n"
"res_offset /= sizeof(float);\n"
"img += img_offset;\n"
"res += res_offset;\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"if(gidx < cols && gidy < rows)\n"
"{\n"
"res[gidx + gidy * res_step] = img[gidx + gidy * img_step].x;\n"
"}\n"
"}\n"
;
const char* meanShift="short2 do_mean_shift(int x0, int y0, __global uchar4* out,int out_step,\n"
"__global uchar4* in, int in_step, int dst_off, int src_off,\n"
"int cols, int rows, int sp, int sr, int maxIter, float eps)\n"
"{\n"
"int isr2 = sr*sr;\n"
"in_step = in_step >> 2;\n"
"out_step = out_step >> 2;\n"
"src_off = src_off >> 2;\n"
"dst_off = dst_off >> 2;\n"
"int idx = src_off + y0 * in_step + x0;\n"
"uchar4 c = in[idx];\n"
"int base = dst_off + get_global_id(1)*out_step + get_global_id(0) ;\n"
"for( int iter = 0; iter < maxIter; iter++ )\n"
"{\n"
"int count = 0;\n"
"int4 s = (int4)0;\n"
"int sx = 0, sy = 0;\n"
"int minx = (x0-sp)>0 ? x0-sp : 0;\n"
"int miny = (y0-sp)>0 ? y0-sp : 0;\n"
"int maxx = (x0+sp)<cols ? x0+sp : cols-1;\n"
"int maxy = (y0+sp)<rows ? y0+sp : rows-1;\n"
"for( int y = miny; y <= maxy; y++)\n"
"{\n"
"int rowCount = 0;\n"
"int x = minx;\n"
"for( ; x+3 <= maxx; x+=4 )\n"
"{\n"
"int id = src_off + y*in_step + x;\n"
"uchar16 t = (uchar16)(in[id],in[id+1],in[id+2],in[id+3]);\n"
"int norm2_1 = (t.s0 - c.x) * (t.s0 - c.x) + (t.s1 - c.y) * (t.s1 - c.y) +\n"
"(t.s2 - c.z) * (t.s2 - c.z);\n"
"int norm2_2 = (t.s4 - c.x) * (t.s4 - c.x) + (t.s5 - c.y) * (t.s5 - c.y) +\n"
"(t.s6 - c.z) * (t.s6 - c.z);\n"
"int norm2_3 = (t.s8 - c.x) * (t.s8 - c.x) + (t.s9 - c.y) * (t.s9 - c.y) +\n"
"(t.sa - c.z) * (t.sa - c.z);\n"
"int norm2_4 = (t.sc - c.x) * (t.sc - c.x) + (t.sd - c.y) * (t.sd - c.y) +\n"
"(t.se - c.z) * (t.se - c.z);\n"
"if( norm2_1 <= isr2 )\n"
"{\n"
"s.x += t.s0; s.y += t.s1; s.z += t.s2;\n"
"sx += x; rowCount++;\n"
"}\n"
"if( norm2_2 <= isr2 )\n"
"{\n"
"s.x += t.s4; s.y += t.s5; s.z += t.s6;\n"
"sx += x+1; rowCount++;\n"
"}\n"
"if( norm2_3 <= isr2 )\n"
"{\n"
"s.x += t.s8; s.y += t.s9; s.z += t.sa;\n"
"sx += x+2; rowCount++;\n"
"}\n"
"if( norm2_4 <= isr2 )\n"
"{\n"
"s.x += t.sc; s.y += t.sd; s.z += t.se;\n"
"sx += x+3; rowCount++;\n"
"}\n"
"}\n"
"if(x == maxx)\n"
"{\n"
"int id = src_off + y*in_step + x;\n"
"uchar4 t = in[id];\n"
"int norm2 = (t.s0 - c.x) * (t.s0 - c.x) + (t.s1 - c.y) * (t.s1 - c.y) +\n"
"(t.s2 - c.z) * (t.s2 - c.z);\n"
"if( norm2 <= isr2 )\n"
"{\n"
"s.x += t.s0; s.y += t.s1; s.z += t.s2;\n"
"sx += x; rowCount++;\n"
"}\n"
"}\n"
"if(x+1 == maxx)\n"
"{\n"
"int id = src_off + y*in_step + x;\n"
"uchar8 t = (uchar8)(in[id],in[id+1]);\n"
"int norm2_1 = (t.s0 - c.x) * (t.s0 - c.x) + (t.s1 - c.y) * (t.s1 - c.y) +\n"
"(t.s2 - c.z) * (t.s2 - c.z);\n"
"int norm2_2 = (t.s4 - c.x) * (t.s4 - c.x) + (t.s5 - c.y) * (t.s5 - c.y) +\n"
"(t.s6 - c.z) * (t.s6 - c.z);\n"
"if( norm2_1 <= isr2 )\n"
"{\n"
"s.x += t.s0; s.y += t.s1; s.z += t.s2;\n"
"sx += x; rowCount++;\n"
"}\n"
"if( norm2_2 <= isr2 )\n"
"{\n"
"s.x += t.s4; s.y += t.s5; s.z += t.s6;\n"
"sx += x+1; rowCount++;\n"
"}\n"
"}\n"
"if(x+2 == maxx)\n"
"{\n"
"int id = src_off + y*in_step + x;\n"
"uchar16 t = (uchar16)(in[id],in[id+1],in[id+2],in[id+3]);\n"
"int norm2_1 = (t.s0 - c.x) * (t.s0 - c.x) + (t.s1 - c.y) * (t.s1 - c.y) +\n"
"(t.s2 - c.z) * (t.s2 - c.z);\n"
"int norm2_2 = (t.s4 - c.x) * (t.s4 - c.x) + (t.s5 - c.y) * (t.s5 - c.y) +\n"
"(t.s6 - c.z) * (t.s6 - c.z);\n"
"int norm2_3 = (t.s8 - c.x) * (t.s8 - c.x) + (t.s9 - c.y) * (t.s9 - c.y) +\n"
"(t.sa - c.z) * (t.sa - c.z);\n"
"if( norm2_1 <= isr2 )\n"
"{\n"
"s.x += t.s0; s.y += t.s1; s.z += t.s2;\n"
"sx += x; rowCount++;\n"
"}\n"
"if( norm2_2 <= isr2 )\n"
"{\n"
"s.x += t.s4; s.y += t.s5; s.z += t.s6;\n"
"sx += x+1; rowCount++;\n"
"}\n"
"if( norm2_3 <= isr2 )\n"
"{\n"
"s.x += t.s8; s.y += t.s9; s.z += t.sa;\n"
"sx += x+2; rowCount++;\n"
"}\n"
"}\n"
"if(rowCount == 0)\n"
"continue;\n"
"count += rowCount;\n"
"if(y == 0)\n"
"continue;\n"
"sy += y*rowCount;\n"
"}\n"
"if( count == 0 )\n"
"break;\n"
"int x1 = sx/count;\n"
"int y1 = sy/count;\n"
"s.x = s.x/count;\n"
"s.y = s.y/count;\n"
"s.z = s.z/count;\n"
"int4 tmp = s - convert_int4(c);\n"
"int norm2 = tmp.x * tmp.x + tmp.y *  tmp.y +\n"
"tmp.z * tmp.z;\n"
"bool stopFlag = (x1 == x0 && y1 == y0) || (abs(x1-x0) + abs(y1-y0) + norm2 <= eps);\n"
"x0 = x1;\n"
"y0 = y1;\n"
"c.x = s.x;\n"
"c.y = s.y;\n"
"c.z = s.z;\n"
"if( stopFlag )\n"
"break;\n"
"}\n"
"out[base] = c;\n"
"return (short2)((short)x0, (short)y0);\n"
"}\n"
"__kernel void meanshift_kernel(__global uchar4* out, int out_step,\n"
"__global uchar4* in, int in_step,\n"
"int dst_off, int src_off, int cols, int rows,\n"
"int sp, int sr, int maxIter, float eps)\n"
"{\n"
"int x0 = get_global_id(0);\n"
"int y0 = get_global_id(1);\n"
"if( x0 < cols && y0 < rows )\n"
"do_mean_shift(x0, y0, out, out_step, in, in_step, dst_off, src_off,\n"
"cols, rows, sp, sr, maxIter, eps);\n"
"}\n"
"__kernel void meanshiftproc_kernel( __global uchar4* in, __global uchar4* outr,\n"
"__global short2* outsp, int instep, int outrstep,\n"
"int outspstep, int in_off, int outr_off, int outsp_off,\n"
"int cols, int rows, int sp, int sr, int maxIter, float eps )\n"
"{\n"
"int x0 = get_global_id(0);\n"
"int y0 = get_global_id(1);\n"
"if( x0 < cols && y0 < rows )\n"
"{\n"
"outsp_off >>= 2;\n"
"outspstep >>= 2;\n"
"int basesp = outsp_off + y0 * outspstep + x0;\n"
"outsp[basesp] = do_mean_shift(x0, y0, outr, outrstep, in, instep, outr_off, in_off, cols, rows, sp, sr, maxIter, eps);\n"
"}\n"
"}\n"
;
const char* merge_mat="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void merge_vector_C2_D0(__global uchar *mat_dst,  int dst_step,  int dst_offset,\n"
"__global uchar *mat_src0, int src0_step, int src0_offset,\n"
"__global uchar *mat_src1, int src1_step, int src1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"#define dst_align  ((dst_offset & 3) >> 1)\n"
"int src0_index = mad24(y, src0_step, src0_offset + x - dst_align);\n"
"int src1_index = mad24(y, src1_step, src1_offset + x - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"__global uchar4 * dst  = (__global uchar4 *)(mat_dst + dst_index);\n"
"__global uchar  * src0 = mat_src0 + src0_index;\n"
"__global uchar  * src1 = src0     + 1;\n"
"__global uchar  * src2 = mat_src1 + src1_index;\n"
"__global uchar  * src3 = src2     + 1;\n"
"uchar4 dst_data = *dst;\n"
"uchar  data_0   = *(src0);\n"
"uchar  data_1   = *(src1);\n"
"uchar  data_2   = *(src2);\n"
"uchar  data_3   = *(src3);\n"
"uchar4 tmp_data = (uchar4)(data_0, data_2, data_1, data_3);\n"
"tmp_data.xy = dst_index + 0 >= dst_start ? tmp_data.xy : dst_data.xy;\n"
"tmp_data.zw = dst_index + 2 <  dst_end   ? tmp_data.zw : dst_data.zw;\n"
"*dst = tmp_data;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D1(__global char *mat_dst,  int dst_step,  int dst_offset,\n"
"__global char *mat_src0, int src0_step, int src0_offset,\n"
"__global char *mat_src1, int src1_step, int src1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"#define dst_align  ((dst_offset & 3) >> 1)\n"
"int src0_index = mad24(y, src0_step, src0_offset + x - dst_align);\n"
"int src1_index = mad24(y, src1_step, src1_offset + x - dst_align);\n"
"int dst_start  = mad24(y, dst_step, dst_offset);\n"
"int dst_end    = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index  = mad24(y, dst_step, dst_offset + (x << 1) & (int)0xfffffffc);\n"
"__global char4 * dst  = (__global char4 *)(mat_dst + dst_index);\n"
"__global char  * src0 = mat_src0 + src0_index;\n"
"__global char  * src1 = src0     + 1;\n"
"__global char  * src2 = mat_src1 + src1_index;\n"
"__global char  * src3 = src2     + 1;\n"
"char4 dst_data = *dst;\n"
"char  data_0   = *(src0);\n"
"char  data_1   = *(src1);\n"
"char  data_2   = *(src2);\n"
"char  data_3   = *(src3);\n"
"char4 tmp_data = (char4)(data_0, data_2, data_1, data_3);\n"
"tmp_data.xy = dst_index + 0 >= dst_start ? tmp_data.xy : dst_data.xy;\n"
"tmp_data.zw = dst_index + 2 <  dst_end   ? tmp_data.zw : dst_data.zw;\n"
"*dst = tmp_data;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D2(__global ushort *mat_dst,  int dst_step,  int dst_offset,\n"
"__global ushort *mat_src0, int src0_step, int src0_offset,\n"
"__global ushort *mat_src1, int src1_step, int src1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"__global ushort*  src0 = (__global ushort * )((__global uchar *)mat_src0 + src0_index + (x << 1));\n"
"__global ushort*  src1 = (__global ushort * )((__global uchar *)mat_src1 + src1_index + (x << 1));\n"
"__global ushort2* dist = (__global ushort2 *)((__global uchar *)mat_dst  + dst_index  + (x << 2));\n"
"ushort  src0_data = *src0;\n"
"ushort  src1_data = *src1;\n"
"*dist = (ushort2)(src0_data, src1_data);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D3(__global short *mat_dst,  int dst_step,  int dst_offset,\n"
"__global short *mat_src0, int src0_step, int src0_offset,\n"
"__global short *mat_src1, int src1_step, int src1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"__global short*  src0 = (__global short * )((__global uchar *)mat_src0 + src0_index + (x << 1));\n"
"__global short*  src1 = (__global short * )((__global uchar *)mat_src1 + src1_index + (x << 1));\n"
"__global short2* dist = (__global short2 *)((__global uchar *)mat_dst  + dst_index   + (x << 2));\n"
"short  src0_data = *src0;\n"
"short  src1_data = *src1;\n"
"*dist = (short2)(src0_data, src1_data);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D4(__global int *mat_dst,  int dst_step,  int dst_offset,\n"
"__global int *mat_src0, int src0_step, int src0_offset,\n"
"__global int *mat_src1, int src1_step, int src1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"int src0 = *((__global int *)((__global uchar *)mat_src0 + src0_index + (x << 2)));\n"
"int src1 = *((__global int *)((__global uchar *)mat_src1 + src1_index + (x << 2)));\n"
"*((__global int2 *)((__global uchar *)mat_dst  + dst_index + (x << 4))) = (int2)(src0, src1);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D5(__global float *mat_dst,  int dst_step,  int dst_offset,\n"
"__global float *mat_src0, int src0_step, int src0_offset,\n"
"__global float *mat_src1, int src1_step, int src1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"float src0 = *((__global float *)((__global uchar *)mat_src0 + src0_index + (x << 2)));\n"
"float src1 = *((__global float *)((__global uchar *)mat_src1 + src1_index + (x << 2)));\n"
"*((__global float2 *)((__global uchar *)mat_dst  + dst_index + (x << 4))) = (float2)(src0, src1);\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void merge_vector_C2_D6(__global double *mat_dst,  int dst_step,  int dst_offset,\n"
"__global double *mat_src0, int src0_step, int src0_offset,\n"
"__global double *mat_src1, int src1_step, int src1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"double src0 = *((__global double *)((__global uchar *)mat_src0 + src0_index + (x << 3)));\n"
"double src1 = *((__global double *)((__global uchar *)mat_src1 + src1_index + (x << 3)));\n"
"*((__global double2 *)((__global uchar *)mat_dst  + dst_index + (x << 4))) = (double2)(src0, src1);\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void merge_vector_C3_D0(__global uchar *mat_dst,  int dst_step,  int dst_offset,\n"
"__global uchar *mat_src0, int src0_step, int src0_offset,\n"
"__global uchar *mat_src1, int src1_step, int src1_offset,\n"
"__global uchar *mat_src2, int src2_step, int src2_offset, int offset_cols,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"x = x << 2;\n"
"int src0_index = mad24(y, src0_step, x + src0_offset - offset_cols);\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - offset_cols);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - offset_cols);\n"
"int dst_start = mad24(y, dst_step, dst_offset);\n"
"int dst_end   = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index = mad24(y, dst_step, dst_offset + 3 * x - offset_cols * 3);\n"
"uchar data0_0 = *(mat_src0 + src0_index + 0);\n"
"uchar data0_1 = *(mat_src0 + src0_index + 1);\n"
"uchar data0_2 = *(mat_src0 + src0_index + 2);\n"
"uchar data0_3 = *(mat_src0 + src0_index + 3);\n"
"uchar data1_0 = *(mat_src1 + src1_index + 0);\n"
"uchar data1_1 = *(mat_src1 + src1_index + 1);\n"
"uchar data1_2 = *(mat_src1 + src1_index + 2);\n"
"uchar data1_3 = *(mat_src1 + src1_index + 3);\n"
"uchar data2_0 = *(mat_src2 + src2_index + 0);\n"
"uchar data2_1 = *(mat_src2 + src2_index + 1);\n"
"uchar data2_2 = *(mat_src2 + src2_index + 2);\n"
"uchar data2_3 = *(mat_src2 + src2_index + 3);\n"
"uchar4 tmp_data0 = (uchar4)(data0_0, data1_0, data2_0, data0_1);\n"
"uchar4 tmp_data1 = (uchar4)(data1_1, data2_1, data0_2, data1_2);\n"
"uchar4 tmp_data2 = (uchar4)(data2_2, data0_3, data1_3, data2_3);\n"
"uchar4 dst_data0 = *((__global uchar4*)(mat_dst + dst_index + 0));\n"
"uchar4 dst_data1 = *((__global uchar4*)(mat_dst + dst_index + 4));\n"
"uchar4 dst_data2 = *((__global uchar4*)(mat_dst + dst_index + 8));\n"
"tmp_data0.x = ((dst_index + 0  >= dst_start) && (dst_index + 0  < dst_end)) ? tmp_data0.x : dst_data0.x;\n"
"tmp_data0.y = ((dst_index + 1  >= dst_start) && (dst_index + 1  < dst_end)) ? tmp_data0.y : dst_data0.y;\n"
"tmp_data0.z = ((dst_index + 2  >= dst_start) && (dst_index + 2  < dst_end)) ? tmp_data0.z : dst_data0.z;\n"
"tmp_data0.w = ((dst_index + 3  >= dst_start) && (dst_index + 3  < dst_end)) ? tmp_data0.w : dst_data0.w;\n"
"tmp_data1.x = ((dst_index + 4  >= dst_start) && (dst_index + 4  < dst_end)) ? tmp_data1.x : dst_data1.x;\n"
"tmp_data1.y = ((dst_index + 5  >= dst_start) && (dst_index + 5  < dst_end)) ? tmp_data1.y : dst_data1.y;\n"
"tmp_data1.z = ((dst_index + 6  >= dst_start) && (dst_index + 6  < dst_end)) ? tmp_data1.z : dst_data1.z;\n"
"tmp_data1.w = ((dst_index + 7  >= dst_start) && (dst_index + 7  < dst_end)) ? tmp_data1.w : dst_data1.w;\n"
"tmp_data2.x = ((dst_index + 8  >= dst_start) && (dst_index + 8  < dst_end)) ? tmp_data2.x : dst_data2.x;\n"
"tmp_data2.y = ((dst_index + 9  >= dst_start) && (dst_index + 9  < dst_end)) ? tmp_data2.y : dst_data2.y;\n"
"tmp_data2.z = ((dst_index + 10 >= dst_start) && (dst_index + 10 < dst_end)) ? tmp_data2.z : dst_data2.z;\n"
"tmp_data2.w = ((dst_index + 11 >= dst_start) && (dst_index + 11 < dst_end)) ? tmp_data2.w : dst_data2.w;\n"
"*((__global uchar4*)(mat_dst + dst_index + 0)) = tmp_data0;\n"
"*((__global uchar4*)(mat_dst + dst_index + 4)) = tmp_data1;\n"
"*((__global uchar4*)(mat_dst + dst_index + 8)) = tmp_data2;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D1(__global char *mat_dst,  int dst_step,  int dst_offset,\n"
"__global char *mat_src0, int src0_step, int src0_offset,\n"
"__global char *mat_src1, int src1_step, int src1_offset,\n"
"__global char *mat_src2, int src2_step, int src2_offset, int offset_cols,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"x = x << 2;\n"
"int src0_index = mad24(y, src0_step, x + src0_offset - offset_cols);\n"
"int src1_index = mad24(y, src1_step, x + src1_offset - offset_cols);\n"
"int src2_index = mad24(y, src2_step, x + src2_offset - offset_cols);\n"
"int dst_start = mad24(y, dst_step, dst_offset);\n"
"int dst_end   = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index = mad24(y, dst_step, dst_offset + 3 * x - offset_cols * 3);\n"
"char data0_0 = *(mat_src0 + src0_index + 0);\n"
"char data0_1 = *(mat_src0 + src0_index + 1);\n"
"char data0_2 = *(mat_src0 + src0_index + 2);\n"
"char data0_3 = *(mat_src0 + src0_index + 3);\n"
"char data1_0 = *(mat_src1 + src1_index + 0);\n"
"char data1_1 = *(mat_src1 + src1_index + 1);\n"
"char data1_2 = *(mat_src1 + src1_index + 2);\n"
"char data1_3 = *(mat_src1 + src1_index + 3);\n"
"char data2_0 = *(mat_src2 + src2_index + 0);\n"
"char data2_1 = *(mat_src2 + src2_index + 1);\n"
"char data2_2 = *(mat_src2 + src2_index + 2);\n"
"char data2_3 = *(mat_src2 + src2_index + 3);\n"
"char4 tmp_data0 = (char4)(data0_0, data1_0, data2_0, data0_1);\n"
"char4 tmp_data1 = (char4)(data1_1, data2_1, data0_2, data1_2);\n"
"char4 tmp_data2 = (char4)(data2_2, data0_3, data1_3, data2_3);\n"
"char4 dst_data0 = *((__global char4*)(mat_dst + dst_index + 0));\n"
"char4 dst_data1 = *((__global char4*)(mat_dst + dst_index + 4));\n"
"char4 dst_data2 = *((__global char4*)(mat_dst + dst_index + 8));\n"
"tmp_data0.x = ((dst_index + 0  >= dst_start) && (dst_index + 0  < dst_end)) ? tmp_data0.x : dst_data0.x;\n"
"tmp_data0.y = ((dst_index + 1  >= dst_start) && (dst_index + 1  < dst_end)) ? tmp_data0.y : dst_data0.y;\n"
"tmp_data0.z = ((dst_index + 2  >= dst_start) && (dst_index + 2  < dst_end)) ? tmp_data0.z : dst_data0.z;\n"
"tmp_data0.w = ((dst_index + 3  >= dst_start) && (dst_index + 3  < dst_end)) ? tmp_data0.w : dst_data0.w;\n"
"tmp_data1.x = ((dst_index + 4  >= dst_start) && (dst_index + 4  < dst_end)) ? tmp_data1.x : dst_data1.x;\n"
"tmp_data1.y = ((dst_index + 5  >= dst_start) && (dst_index + 5  < dst_end)) ? tmp_data1.y : dst_data1.y;\n"
"tmp_data1.z = ((dst_index + 6  >= dst_start) && (dst_index + 6  < dst_end)) ? tmp_data1.z : dst_data1.z;\n"
"tmp_data1.w = ((dst_index + 7  >= dst_start) && (dst_index + 7  < dst_end)) ? tmp_data1.w : dst_data1.w;\n"
"tmp_data2.x = ((dst_index + 8  >= dst_start) && (dst_index + 8  < dst_end)) ? tmp_data2.x : dst_data2.x;\n"
"tmp_data2.y = ((dst_index + 9  >= dst_start) && (dst_index + 9  < dst_end)) ? tmp_data2.y : dst_data2.y;\n"
"tmp_data2.z = ((dst_index + 10 >= dst_start) && (dst_index + 10 < dst_end)) ? tmp_data2.z : dst_data2.z;\n"
"tmp_data2.w = ((dst_index + 11 >= dst_start) && (dst_index + 11 < dst_end)) ? tmp_data2.w : dst_data2.w;\n"
"*((__global char4*)(mat_dst + dst_index + 0)) = tmp_data0;\n"
"*((__global char4*)(mat_dst + dst_index + 4)) = tmp_data1;\n"
"*((__global char4*)(mat_dst + dst_index + 8)) = tmp_data2;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D2(__global ushort *mat_dst,  int dst_step,  int dst_offset,\n"
"__global ushort *mat_src0, int src0_step, int src0_offset,\n"
"__global ushort *mat_src1, int src1_step, int src1_offset,\n"
"__global ushort *mat_src2, int src2_step, int src2_offset, int offset_cols,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"int src0_index = mad24(y, src0_step, (x << 1) + src0_offset - offset_cols);\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - offset_cols);\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - offset_cols);\n"
"int dst_start = mad24(y, dst_step, dst_offset);\n"
"int dst_end   = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index = mad24(y, dst_step, dst_offset + 6 * x - offset_cols * 6);\n"
"ushort data0_0 = *((__global ushort *)((__global char *)mat_src0 + src0_index + 0));\n"
"ushort data0_1 = *((__global ushort *)((__global char *)mat_src0 + src0_index + 2));\n"
"ushort data1_0 = *((__global ushort *)((__global char *)mat_src1 + src1_index + 0));\n"
"ushort data1_1 = *((__global ushort *)((__global char *)mat_src1 + src1_index + 2));\n"
"ushort data2_0 = *((__global ushort *)((__global char *)mat_src2 + src2_index + 0));\n"
"ushort data2_1 = *((__global ushort *)((__global char *)mat_src2 + src2_index + 2));\n"
"ushort2 tmp_data0 = (ushort2)(data0_0, data1_0);\n"
"ushort2 tmp_data1 = (ushort2)(data2_0, data0_1);\n"
"ushort2 tmp_data2 = (ushort2)(data1_1, data2_1);\n"
"ushort2 dst_data0 = *((__global ushort2*)((__global char *)mat_dst + dst_index + 0));\n"
"ushort2 dst_data1 = *((__global ushort2*)((__global char *)mat_dst + dst_index + 4));\n"
"ushort2 dst_data2 = *((__global ushort2*)((__global char *)mat_dst + dst_index + 8));\n"
"tmp_data0.x = ((dst_index + 0  >= dst_start) && (dst_index + 0  < dst_end)) ? tmp_data0.x : dst_data0.x;\n"
"tmp_data0.y = ((dst_index + 2  >= dst_start) && (dst_index + 2  < dst_end)) ? tmp_data0.y : dst_data0.y;\n"
"tmp_data1.x = ((dst_index + 4  >= dst_start) && (dst_index + 4  < dst_end)) ? tmp_data1.x : dst_data1.x;\n"
"tmp_data1.y = ((dst_index + 6  >= dst_start) && (dst_index + 6  < dst_end)) ? tmp_data1.y : dst_data1.y;\n"
"tmp_data2.x = ((dst_index + 8  >= dst_start) && (dst_index + 8  < dst_end)) ? tmp_data2.x : dst_data2.x;\n"
"tmp_data2.y = ((dst_index + 10 >= dst_start) && (dst_index + 10 < dst_end)) ? tmp_data2.y : dst_data2.y;\n"
"*((__global ushort2*)((__global char *)mat_dst + dst_index + 0)) = tmp_data0;\n"
"*((__global ushort2*)((__global char *)mat_dst + dst_index + 4)) = tmp_data1;\n"
"*((__global ushort2*)((__global char *)mat_dst + dst_index + 8)) = tmp_data2;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D3(__global short *mat_dst,  int dst_step,  int dst_offset,\n"
"__global short *mat_src0, int src0_step, int src0_offset,\n"
"__global short *mat_src1, int src1_step, int src1_offset,\n"
"__global short *mat_src2, int src2_step, int src2_offset, int offset_cols,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"int src0_index = mad24(y, src0_step, (x << 1) + src0_offset - offset_cols);\n"
"int src1_index = mad24(y, src1_step, (x << 1) + src1_offset - offset_cols);\n"
"int src2_index = mad24(y, src2_step, (x << 1) + src2_offset - offset_cols);\n"
"int dst_start = mad24(y, dst_step, dst_offset);\n"
"int dst_end   = mad24(y, dst_step, dst_offset + dst_step1);\n"
"int dst_index = mad24(y, dst_step, dst_offset + 6 * x - offset_cols * 6);\n"
"short data0_0 = *((__global short *)((__global char *)mat_src0 + src0_index + 0));\n"
"short data0_1 = *((__global short *)((__global char *)mat_src0 + src0_index + 2));\n"
"short data1_0 = *((__global short *)((__global char *)mat_src1 + src1_index + 0));\n"
"short data1_1 = *((__global short *)((__global char *)mat_src1 + src1_index + 2));\n"
"short data2_0 = *((__global short *)((__global char *)mat_src2 + src2_index + 0));\n"
"short data2_1 = *((__global short *)((__global char *)mat_src2 + src2_index + 2));\n"
"short2 tmp_data0 = (short2)(data0_0, data1_0);\n"
"short2 tmp_data1 = (short2)(data2_0, data0_1);\n"
"short2 tmp_data2 = (short2)(data1_1, data2_1);\n"
"short2 dst_data0 = *((__global short2*)((__global char *)mat_dst + dst_index + 0));\n"
"short2 dst_data1 = *((__global short2*)((__global char *)mat_dst + dst_index + 4));\n"
"short2 dst_data2 = *((__global short2*)((__global char *)mat_dst + dst_index + 8));\n"
"tmp_data0.x = ((dst_index + 0  >= dst_start) && (dst_index + 0  < dst_end)) ? tmp_data0.x : dst_data0.x;\n"
"tmp_data0.y = ((dst_index + 2  >= dst_start) && (dst_index + 2  < dst_end)) ? tmp_data0.y : dst_data0.y;\n"
"tmp_data1.x = ((dst_index + 4  >= dst_start) && (dst_index + 4  < dst_end)) ? tmp_data1.x : dst_data1.x;\n"
"tmp_data1.y = ((dst_index + 6  >= dst_start) && (dst_index + 6  < dst_end)) ? tmp_data1.y : dst_data1.y;\n"
"tmp_data2.x = ((dst_index + 8  >= dst_start) && (dst_index + 8  < dst_end)) ? tmp_data2.x : dst_data2.x;\n"
"tmp_data2.y = ((dst_index + 10 >= dst_start) && (dst_index + 10 < dst_end)) ? tmp_data2.y : dst_data2.y;\n"
"*((__global short2*)((__global char *)mat_dst + dst_index + 0)) = tmp_data0;\n"
"*((__global short2*)((__global char *)mat_dst + dst_index + 4)) = tmp_data1;\n"
"*((__global short2*)((__global char *)mat_dst + dst_index + 8)) = tmp_data2;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D4(__global int *mat_dst,  int dst_step,  int dst_offset,\n"
"__global int *mat_src0, int src0_step, int src0_offset,\n"
"__global int *mat_src1, int src1_step, int src1_offset,\n"
"__global int *mat_src2, int src2_step, int src2_offset, int offset_cols,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"__global int* src0 = (__global int * )((__global uchar *)mat_src0 + src0_index + (x << 2));\n"
"__global int* src1 = (__global int * )((__global uchar *)mat_src1 + src1_index + (x << 2));\n"
"__global int* src2 = (__global int * )((__global uchar *)mat_src2 + src2_index + (x << 2));\n"
"__global int* dist0 = (__global int *)((__global uchar *)mat_dst  + dst_index  + 3 * (x << 2));\n"
"__global int* dist1 = dist0 + 1;\n"
"__global int* dist2 = dist0 + 2;\n"
"int  src0_data = *src0;\n"
"int  src1_data = *src1;\n"
"int  src2_data = *src2;\n"
"*dist0 = src0_data;\n"
"*dist1 = src1_data;\n"
"*dist2 = src2_data;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D5(__global float *mat_dst,  int dst_step,  int dst_offset,\n"
"__global float *mat_src0, int src0_step, int src0_offset,\n"
"__global float *mat_src1, int src1_step, int src1_offset,\n"
"__global float *mat_src2, int src2_step, int src2_offset, int offset_cols,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"__global float* src0 = (__global float * )((__global uchar *)mat_src0 + src0_index + (x << 2));\n"
"__global float* src1 = (__global float * )((__global uchar *)mat_src1 + src1_index + (x << 2));\n"
"__global float* src2 = (__global float * )((__global uchar *)mat_src2 + src2_index + (x << 2));\n"
"__global float* dist0 = (__global float *)((__global uchar *)mat_dst  + dst_index  + 3 * (x << 2));\n"
"__global float* dist1 = dist0 + 1;\n"
"__global float* dist2 = dist0 + 2;\n"
"float  src0_data = *src0;\n"
"float  src1_data = *src1;\n"
"float  src2_data = *src2;\n"
"*dist0 = src0_data;\n"
"*dist1 = src1_data;\n"
"*dist2 = src2_data;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void merge_vector_C3_D6(__global double *mat_dst,  int dst_step,  int dst_offset,\n"
"__global double *mat_src0, int src0_step, int src0_offset,\n"
"__global double *mat_src1, int src1_step, int src1_offset,\n"
"__global double *mat_src2, int src2_step, int src2_offset, int offset_cols,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"__global double* src0 = (__global double * )((__global uchar *)mat_src0 + src0_index + (x << 3));\n"
"__global double* src1 = (__global double * )((__global uchar *)mat_src1 + src1_index + (x << 3));\n"
"__global double* src2 = (__global double * )((__global uchar *)mat_src2 + src2_index + (x << 3));\n"
"__global double* dist0 = (__global double *)((__global uchar *)mat_dst  + dst_index  + 3 * (x << 3));\n"
"__global double* dist1 = dist0 + 1;\n"
"__global double* dist2 = dist0 + 2;\n"
"double  src0_data = *src0;\n"
"double  src1_data = *src1;\n"
"double  src2_data = *src2;\n"
"*dist0 = src0_data;\n"
"*dist1 = src1_data;\n"
"*dist2 = src2_data;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void merge_vector_C4_D0(__global uchar *mat_dst,  int dst_step,  int dst_offset,\n"
"__global uchar *mat_src0, int src0_step, int src0_offset,\n"
"__global uchar *mat_src1, int src1_step, int src1_offset,\n"
"__global uchar *mat_src2, int src2_step, int src2_offset,\n"
"__global uchar *mat_src3, int src3_step, int src3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int src3_index = mad24(y, src3_step, src3_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"uchar src0 = *(mat_src0 + src0_index + x );\n"
"uchar src1 = *(mat_src1 + src1_index + x);\n"
"uchar src2 = *(mat_src2 + src2_index + x);\n"
"uchar src3 = *(mat_src3 + src3_index + x);\n"
"*((__global uchar4 *)(mat_dst  + dst_index + (x << 2))) = (uchar4)(src0, src1, src2, src3);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D1(__global char *mat_dst,  int dst_step,  int dst_offset,\n"
"__global char *mat_src0, int src0_step, int src0_offset,\n"
"__global char *mat_src1, int src1_step, int src1_offset,\n"
"__global char *mat_src2, int src2_step, int src2_offset,\n"
"__global char *mat_src3, int src3_step, int src3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int src3_index = mad24(y, src3_step, src3_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"char src0 = *(mat_src0 + src0_index + x );\n"
"char src1 = *(mat_src1 + src1_index + x);\n"
"char src2 = *(mat_src2 + src2_index + x);\n"
"char src3 = *(mat_src3 + src3_index + x);\n"
"*((__global char4 *)(mat_dst  + dst_index + (x << 2))) = (char4)(src0, src1, src2, src3);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D2(__global ushort *mat_dst,  int dst_step,  int dst_offset,\n"
"__global ushort *mat_src0, int src0_step, int src0_offset,\n"
"__global ushort *mat_src1, int src1_step, int src1_offset,\n"
"__global ushort *mat_src2, int src2_step, int src2_offset,\n"
"__global ushort *mat_src3, int src3_step, int src3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int src3_index = mad24(y, src3_step, src3_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"ushort src0 = *((__global ushort *)((__global uchar *)mat_src0 + src0_index + (x << 1)));\n"
"ushort src1 = *((__global ushort *)((__global uchar *)mat_src1 + src1_index + (x << 1)));\n"
"ushort src2 = *((__global ushort *)((__global uchar *)mat_src2 + src2_index + (x << 1)));\n"
"ushort src3 = *((__global ushort *)((__global uchar *)mat_src3 + src3_index + (x << 1)));\n"
"*((__global ushort4 *)((__global uchar *)mat_dst  + dst_index + (x << 3))) = (ushort4)(src0, src1, src2, src3);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D3(__global short *mat_dst,  int dst_step,  int dst_offset,\n"
"__global short *mat_src0, int src0_step, int src0_offset,\n"
"__global short *mat_src1, int src1_step, int src1_offset,\n"
"__global short *mat_src2, int src2_step, int src2_offset,\n"
"__global short *mat_src3, int src3_step, int src3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int src3_index = mad24(y, src3_step, src3_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"short src0 = *((__global short *)((__global uchar *)mat_src0 + src0_index + (x << 1)));\n"
"short src1 = *((__global short *)((__global uchar *)mat_src1 + src1_index + (x << 1)));\n"
"short src2 = *((__global short *)((__global uchar *)mat_src2 + src2_index + (x << 1)));\n"
"short src3 = *((__global short *)((__global uchar *)mat_src3 + src3_index + (x << 1)));\n"
"*((__global short4 *)((__global uchar *)mat_dst  + dst_index + (x << 3))) = (short4)(src0, src1, src2, src3);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D4(__global int *mat_dst,  int dst_step,  int dst_offset,\n"
"__global int *mat_src0, int src0_step, int src0_offset,\n"
"__global int *mat_src1, int src1_step, int src1_offset,\n"
"__global int *mat_src2, int src2_step, int src2_offset,\n"
"__global int *mat_src3, int src3_step, int src3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int src3_index = mad24(y, src3_step, src3_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"int src0 = *((__global int *)((__global uchar *)mat_src0 + src0_index + (x << 2)));\n"
"int src1 = *((__global int *)((__global uchar *)mat_src1 + src1_index + (x << 2)));\n"
"int src2 = *((__global int *)((__global uchar *)mat_src2 + src2_index + (x << 2)));\n"
"int src3 = *((__global int *)((__global uchar *)mat_src3 + src3_index + (x << 2)));\n"
"*((__global int4 *)((__global uchar *)mat_dst  + dst_index + (x << 4))) = (int4)(src0, src1, src2, src3);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D5(__global float *mat_dst,  int dst_step,  int dst_offset,\n"
"__global float *mat_src0, int src0_step, int src0_offset,\n"
"__global float *mat_src1, int src1_step, int src1_offset,\n"
"__global float *mat_src2, int src2_step, int src2_offset,\n"
"__global float *mat_src3, int src3_step, int src3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int src3_index = mad24(y, src3_step, src3_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"float src0 = *((__global float *)((__global uchar *)mat_src0 + src0_index + (x << 2)));\n"
"float src1 = *((__global float *)((__global uchar *)mat_src1 + src1_index + (x << 2)));\n"
"float src2 = *((__global float *)((__global uchar *)mat_src2 + src2_index + (x << 2)));\n"
"float src3 = *((__global float *)((__global uchar *)mat_src3 + src3_index + (x << 2)));\n"
"*((__global float4 *)((__global uchar *)mat_dst  + dst_index + (x << 4))) = (float4)(src0, src1, src2, src3);\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void merge_vector_C4_D6(__global double *mat_dst,  int dst_step,  int dst_offset,\n"
"__global double *mat_src0, int src0_step, int src0_offset,\n"
"__global double *mat_src1, int src1_step, int src1_offset,\n"
"__global double *mat_src2, int src2_step, int src2_offset,\n"
"__global double *mat_src3, int src3_step, int src3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"int src0_index = mad24(y, src0_step, src0_offset);\n"
"int src1_index = mad24(y, src1_step, src1_offset);\n"
"int src2_index = mad24(y, src2_step, src2_offset);\n"
"int src3_index = mad24(y, src3_step, src3_offset);\n"
"int dst_index  = mad24(y, dst_step , dst_offset);\n"
"double src0 = *((__global double *)((__global uchar *)mat_src0 + src0_index + (x << 3)));\n"
"double src1 = *((__global double *)((__global uchar *)mat_src1 + src1_index + (x << 3)));\n"
"double src2 = *((__global double *)((__global uchar *)mat_src2 + src2_index + (x << 3)));\n"
"double src3 = *((__global double *)((__global uchar *)mat_src3 + src3_index + (x << 3)));\n"
"*((__global double4 *)((__global uchar *)mat_dst  + dst_index + (x << 5))) = (double4)(src0, src1, src2, src3);\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void merge_vector_C2_D0_1(int rows, int cols,\n"
"__global uchar *mat_dst,  int dst_step,\n"
"__global uchar *mat_src0, int src0_step,\n"
"__global uchar *mat_src1, int src1_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global uchar4  *src0_y = (__global uchar4 * )(mat_src0 + y * src0_step);\n"
"__global uchar4  *src1_y = (__global uchar4 * )(mat_src1 + y * src1_step);\n"
"__global uchar8 *dst_y  = (__global uchar8 *)(mat_dst  + y * dst_step);\n"
"uchar4 value1 = src0_y[x];\n"
"uchar4 value2 = src1_y[x];\n"
"uchar8 value;\n"
"value.even = value1;\n"
"value.odd = value2;\n"
"dst_y[x] = value;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D1_1(int rows, int cols,\n"
"__global char *mat_dst,  int dst_step,\n"
"__global char *mat_src0, int src0_step,\n"
"__global char *mat_src1, int src1_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global char4  *src0_y = (__global char4 * )(mat_src0 + y * src0_step);\n"
"__global char4  *src1_y = (__global char4 * )(mat_src1 + y * src1_step);\n"
"__global char8 *dst_y  = (__global char8 *)(mat_dst  + y * dst_step);\n"
"char4 value1 = src0_y[x];\n"
"char4 value2 = src1_y[x];\n"
"char8 value;\n"
"value.even = value1;\n"
"value.odd = value2;\n"
"dst_y[x] = value;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D2_1(int rows, int cols,\n"
"__global ushort *mat_dst,  int dst_step,\n"
"__global ushort *mat_src0, int src0_step,\n"
"__global ushort *mat_src1, int src1_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global ushort2  *src0_y = (__global ushort2 *)((__global uchar *)mat_src0 + y * src0_step);\n"
"__global ushort2  *src1_y = (__global ushort2 *)((__global uchar *)mat_src1 + y * src1_step);\n"
"__global ushort4  *dst_y  = (__global ushort4 *)((__global uchar *)mat_dst  + y * dst_step);\n"
"ushort2 value1 = src0_y[x];\n"
"ushort2 value2 = src1_y[x];\n"
"ushort4 value;\n"
"value.even = value1;\n"
"value.odd = value2;\n"
"dst_y[x] = value;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D3_1(int rows, int cols,\n"
"__global short *mat_dst,  int dst_step,\n"
"__global short *mat_src0, int src0_step,\n"
"__global short *mat_src1, int src1_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global short2  *src0_y = (__global short2 *)((__global uchar *)mat_src0 + y * src0_step);\n"
"__global short2  *src1_y = (__global short2 *)((__global uchar *)mat_src1 + y * src1_step);\n"
"__global short4 *dst_y   = (__global short4 *)((__global uchar *)mat_dst  + y * dst_step);\n"
"short2 value1 = src0_y[x];\n"
"short2 value2 = src1_y[x];\n"
"short4 value;\n"
"value.even = value1;\n"
"value.odd = value2;\n"
"dst_y[x] = value;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D4_1(int rows, int cols,\n"
"__global int *mat_dst,  int dst_step,\n"
"__global int *mat_src0, int src0_step,\n"
"__global int *mat_src1, int src1_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global int  *src0_y = (__global int *)((__global uchar *)mat_src0 + y * src0_step);\n"
"__global int  *src1_y = (__global int *)((__global uchar *)mat_src1 + y * src1_step);\n"
"__global int2  *dst_y  = (__global int2 *)((__global uchar *)mat_dst  + y * dst_step);\n"
"int value1 = src0_y[x];\n"
"int value2 = src1_y[x];\n"
"int2 value;\n"
"value.even = value1;\n"
"value.odd = value2;\n"
"dst_y[x] = value;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C2_D5_1(int rows, int cols,\n"
"__global float *mat_dst,  int dst_step,\n"
"__global float *mat_src0, int src0_step,\n"
"__global float *mat_src1, int src1_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global float  *src0_y = (__global float *)((__global uchar *)mat_src0 + y * src0_step);\n"
"__global float  *src1_y = (__global float *)((__global uchar *)mat_src1 + y * src1_step);\n"
"__global float2  *dst_y  = (__global float2 *)((__global uchar *)mat_dst  + y * dst_step);\n"
"float value1 = src0_y[x];\n"
"float value2 = src1_y[x];\n"
"dst_y[x] = (float2)(value1, value2);\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void merge_vector_C2_D6_1(int rows, int cols,\n"
"__global double *mat_dst,  int dst_step,\n"
"__global double *mat_src0, int src0_step,\n"
"__global double *mat_src1, int src1_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global double  *src0_y = (__global double *)((__global uchar *)mat_src0 + y * src0_step);\n"
"__global double  *src1_y = (__global double *)((__global uchar *)mat_src1 + y * src1_step);\n"
"__global double2 *dst_y  = (__global double2 *)((__global uchar *)mat_dst  + y * dst_step);\n"
"double value1 = src0_y[x];\n"
"double value2 = src1_y[x];\n"
"dst_y[x] = (double2)(value1, value2);\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void merge_vector_C3_D0_1(int rows, int cols,\n"
"__global uchar *mat_dst,  int dst_step,\n"
"__global uchar *mat_src0, int src0_step,\n"
"__global uchar *mat_src1, int src1_step,\n"
"__global uchar *mat_src2, int src2_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global uchar4  *src0_y = (__global uchar4 * )(mat_src0 + y * src0_step);\n"
"__global uchar4  *src1_y = (__global uchar4 * )(mat_src1 + y * src1_step);\n"
"__global uchar4  *src2_y = (__global uchar4 * )(mat_src2 + y * src0_step);\n"
"__global uchar4 *dst_y  = (__global uchar4 *)(mat_dst  + y * dst_step);\n"
"uchar4 value0 = src0_y[x];\n"
"uchar4 value1 = src1_y[x];\n"
"uchar4 value2 = src2_y[x];\n"
"dst_y[3 * x + 0] = (uchar4)(value0.s0, value1.s0, value2.s0,\n"
"value0.s1);\n"
"dst_y[3 * x + 1] = (uchar4)(value1.s1, value2.s1,\n"
"value0.s2, value1.s2);\n"
"dst_y[3 * x + 2] = (uchar4)(value2.s2,\n"
"value0.s3, value1.s3, value2.s3);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D1_1(int rows, int cols,\n"
"__global char *mat_dst,  int dst_step,\n"
"__global char *mat_src0, int src0_step,\n"
"__global char *mat_src1, int src1_step,\n"
"__global char *mat_src2, int src2_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global char4  *src0_y = (__global char4 * )(mat_src0 + y * src0_step);\n"
"__global char4  *src1_y = (__global char4 * )(mat_src1 + y * src1_step);\n"
"__global char4  *src2_y = (__global char4 * )(mat_src2 + y * src0_step);\n"
"__global char4 *dst_y  = (__global char4 *)(mat_dst  + y * dst_step);\n"
"char4 value0 = src0_y[x];\n"
"char4 value1 = src1_y[x];\n"
"char4 value2 = src2_y[x];\n"
"dst_y[3 * x + 0] = (char4)(value0.s0, value1.s0, value2.s0,\n"
"value0.s1);\n"
"dst_y[3 * x + 1] = (char4)(value1.s1, value2.s1,\n"
"value0.s2, value1.s2);\n"
"dst_y[3 * x + 2] = (char4)(value2.s2,\n"
"value0.s3, value1.s3, value2.s3);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D2_1(int rows, int cols,\n"
"__global ushort *mat_dst,  int dst_step,\n"
"__global ushort *mat_src0, int src0_step,\n"
"__global ushort *mat_src1, int src1_step,\n"
"__global ushort *mat_src2, int src2_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global ushort2  *src0_y = (__global ushort2 * )((__global char *)mat_src0 + y * src0_step);\n"
"__global ushort2  *src1_y = (__global ushort2 * )((__global char *)mat_src1 + y * src1_step);\n"
"__global ushort2  *src2_y = (__global ushort2 * )((__global char *)mat_src2 + y * src0_step);\n"
"__global ushort2 *dst_y  = (__global ushort2 *)((__global char *)mat_dst  + y * dst_step);\n"
"ushort2 value0 = src0_y[x];\n"
"ushort2 value1 = src1_y[x];\n"
"ushort2 value2 = src2_y[x];\n"
"dst_y[3 * x + 0] = (ushort2)(value0.x, value1.x);\n"
"dst_y[3 * x + 1] = (ushort2)(value2.x, value0.y);\n"
"dst_y[3 * x + 2] = (ushort2)(value1.y, value2.y);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D3_1(int rows, int cols,\n"
"__global short *mat_dst,  int dst_step,\n"
"__global short *mat_src0, int src0_step,\n"
"__global short *mat_src1, int src1_step,\n"
"__global short *mat_src2, int src2_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global short2  *src0_y = (__global short2 * )((__global char *)mat_src0 + y * src0_step);\n"
"__global short2  *src1_y = (__global short2 * )((__global char *)mat_src1 + y * src1_step);\n"
"__global short2  *src2_y = (__global short2 * )((__global char *)mat_src2 + y * src0_step);\n"
"__global short2 *dst_y  = (__global short2 *)((__global char *)mat_dst  + y * dst_step);\n"
"short2 value0 = src0_y[x];\n"
"short2 value1 = src1_y[x];\n"
"short2 value2 = src2_y[x];\n"
"dst_y[3 * x + 0] = (short2)(value0.x, value1.x);\n"
"dst_y[3 * x + 1] = (short2)(value2.x, value0.y);\n"
"dst_y[3 * x + 2] = (short2)(value1.y, value2.y);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D4_1(int rows, int cols,\n"
"__global int *mat_dst,  int dst_step,\n"
"__global int *mat_src0, int src0_step,\n"
"__global int *mat_src1, int src1_step,\n"
"__global int *mat_src2, int src2_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global int  *src0_y = (__global int * )((__global char *)mat_src0 + y * src0_step);\n"
"__global int  *src1_y = (__global int * )((__global char *)mat_src1 + y * src1_step);\n"
"__global int  *src2_y = (__global int * )((__global char *)mat_src2 + y * src0_step);\n"
"__global int *dst_y  = (__global int *)((__global char *)mat_dst  + y * dst_step);\n"
"int value0 = src0_y[x];\n"
"int value1 = src1_y[x];\n"
"int value2 = src2_y[x];\n"
"dst_y[3 * x + 0] = value0;\n"
"dst_y[3 * x + 1] = value1;\n"
"dst_y[3 * x + 2] = value2;\n"
"}\n"
"}\n"
"__kernel void merge_vector_C3_D5_1(int rows, int cols,\n"
"__global float *mat_dst,  int dst_step,\n"
"__global float *mat_src0, int src0_step,\n"
"__global float *mat_src1, int src1_step,\n"
"__global float *mat_src2, int src2_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global float  *src0_y = (__global float * )((__global char *)mat_src0 + y * src0_step);\n"
"__global float  *src1_y = (__global float * )((__global char *)mat_src1 + y * src1_step);\n"
"__global float  *src2_y = (__global float * )((__global char *)mat_src2 + y * src0_step);\n"
"__global float *dst_y  = (__global float *)((__global char *)mat_dst  + y * dst_step);\n"
"float value0 = src0_y[x];\n"
"float value1 = src1_y[x];\n"
"float value2 = src2_y[x];\n"
"dst_y[3 * x + 0] = value0;\n"
"dst_y[3 * x + 1] = value1;\n"
"dst_y[3 * x + 2] = value2;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void merge_vector_C3_D6_1(int rows, int cols,\n"
"__global double *mat_dst,  int dst_step,\n"
"__global double *mat_src0, int src0_step,\n"
"__global double *mat_src1, int src1_step,\n"
"__global double *mat_src2, int src2_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global double  *src0_y = (__global double * )((__global char *)mat_src0 + y * src0_step);\n"
"__global double  *src1_y = (__global double * )((__global char *)mat_src1 + y * src1_step);\n"
"__global double  *src2_y = (__global double * )((__global char *)mat_src2 + y * src0_step);\n"
"__global double *dst_y  = (__global double *)((__global char *)mat_dst  + y * dst_step);\n"
"double value0 = src0_y[x];\n"
"double value1 = src1_y[x];\n"
"double value2 = src2_y[x];\n"
"dst_y[3 * x + 0] = value0;\n"
"dst_y[3 * x + 1] = value1;\n"
"dst_y[3 * x + 2] = value2;\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void merge_vector_C4_D0_1(int rows, int cols,\n"
"__global uchar *mat_dst,  int dst_step,\n"
"__global uchar *mat_src0, int src0_step,\n"
"__global uchar *mat_src1, int src1_step,\n"
"__global uchar *mat_src2, int src2_step,\n"
"__global uchar *mat_src3, int src3_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global uchar4  *src0_y = (__global uchar4 * )(mat_src0 + y * src0_step);\n"
"__global uchar4  *src1_y = (__global uchar4 * )(mat_src1 + y * src1_step);\n"
"__global uchar4  *src2_y = (__global uchar4 * )(mat_src2 + y * src0_step);\n"
"__global uchar4  *src3_y = (__global uchar4 * )(mat_src3 + y * src1_step);\n"
"__global uchar16 *dst_y  = (__global uchar16 *)(mat_dst  + y * dst_step);\n"
"uchar4 value0 = src0_y[x];\n"
"uchar4 value1 = src1_y[x];\n"
"uchar4 value2 = src2_y[x];\n"
"uchar4 value3 = src3_y[x];\n"
"dst_y[x] = (uchar16)(value0.x, value1.x, value2.x, value3.x,\n"
"value0.y, value1.y, value2.y, value3.y,\n"
"value0.z, value1.z, value2.z, value3.z,\n"
"value0.w, value1.w, value2.w, value3.w);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D1_1(int rows, int cols,\n"
"__global char *mat_dst,  int dst_step,\n"
"__global char *mat_src0, int src0_step,\n"
"__global char *mat_src1, int src1_step,\n"
"__global char *mat_src2, int src2_step,\n"
"__global char *mat_src3, int src3_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global char4  *src0_y = (__global char4 * )(mat_src0 + y * src0_step);\n"
"__global char4  *src1_y = (__global char4 * )(mat_src1 + y * src1_step);\n"
"__global char4  *src2_y = (__global char4 * )(mat_src2 + y * src0_step);\n"
"__global char4  *src3_y = (__global char4 * )(mat_src3 + y * src1_step);\n"
"__global char16 *dst_y  = (__global char16 *)(mat_dst  + y * dst_step);\n"
"char4 value0 = src0_y[x];\n"
"char4 value1 = src1_y[x];\n"
"char4 value2 = src2_y[x];\n"
"char4 value3 = src3_y[x];\n"
"dst_y[x] = (char16)(value0.x, value1.x, value2.x, value3.x,\n"
"value0.y, value1.y, value2.y, value3.y,\n"
"value0.z, value1.z, value2.z, value3.z,\n"
"value0.w, value1.w, value2.w, value3.w);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D2_1(int rows, int cols,\n"
"__global ushort *mat_dst,  int dst_step,\n"
"__global ushort *mat_src0, int src0_step,\n"
"__global ushort *mat_src1, int src1_step,\n"
"__global ushort *mat_src2, int src2_step,\n"
"__global ushort *mat_src3, int src3_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global ushort2  *src0_y = (__global ushort2 * )((__global uchar*)mat_src0 + y * src0_step);\n"
"__global ushort2  *src1_y = (__global ushort2 * )((__global uchar*)mat_src1 + y * src1_step);\n"
"__global ushort2  *src2_y = (__global ushort2 * )((__global uchar*)mat_src2 + y * src0_step);\n"
"__global ushort2  *src3_y = (__global ushort2 * )((__global uchar*)mat_src3 + y * src1_step);\n"
"__global ushort8 *dst_y  = (__global ushort8 *)((__global uchar*)mat_dst  + y * dst_step);\n"
"ushort2 value0 = src0_y[x];\n"
"ushort2 value1 = src1_y[x];\n"
"ushort2 value2 = src2_y[x];\n"
"ushort2 value3 = src3_y[x];\n"
"dst_y[x] = (ushort8)(value0.x, value1.x, value2.x, value3.x,\n"
"value0.y, value1.y, value2.y, value3.y);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D3_1(int rows, int cols,\n"
"__global short *mat_dst,  int dst_step,\n"
"__global short *mat_src0, int src0_step,\n"
"__global short *mat_src1, int src1_step,\n"
"__global short *mat_src2, int src2_step,\n"
"__global short *mat_src3, int src3_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global short2  *src0_y = (__global short2 * )((__global uchar*)mat_src0 + y * src0_step);\n"
"__global short2  *src1_y = (__global short2 * )((__global uchar*)mat_src1 + y * src1_step);\n"
"__global short2  *src2_y = (__global short2 * )((__global uchar*)mat_src2 + y * src0_step);\n"
"__global short2  *src3_y = (__global short2 * )((__global uchar*)mat_src3 + y * src1_step);\n"
"__global short8 *dst_y  = (__global short8 *)((__global uchar*)mat_dst  + y * dst_step);\n"
"short2 value0 = src0_y[x];\n"
"short2 value1 = src1_y[x];\n"
"short2 value2 = src2_y[x];\n"
"short2 value3 = src3_y[x];\n"
"dst_y[x] = (short8)(value0.x, value1.x, value2.x, value3.x,\n"
"value0.y, value1.y, value2.y, value3.y);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D4_1(int rows, int cols,\n"
"__global int *mat_dst,  int dst_step,\n"
"__global int *mat_src0, int src0_step,\n"
"__global int *mat_src1, int src1_step,\n"
"__global int *mat_src2, int src2_step,\n"
"__global int *mat_src3, int src3_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global int *src0_y = (__global int * )((__global uchar*)mat_src0 + y * src0_step);\n"
"__global int *src1_y = (__global int * )((__global uchar*)mat_src1 + y * src1_step);\n"
"__global int *src2_y = (__global int * )((__global uchar*)mat_src2 + y * src0_step);\n"
"__global int *src3_y = (__global int * )((__global uchar*)mat_src3 + y * src1_step);\n"
"__global int4 *dst_y  = (__global int4 *)((__global uchar*)mat_dst  + y * dst_step);\n"
"int value0 = src0_y[x];\n"
"int value1 = src1_y[x];\n"
"int value2 = src2_y[x];\n"
"int value3 = src3_y[x];\n"
"dst_y[x] = (int4)(value0, value1, value2, value3);\n"
"}\n"
"}\n"
"__kernel void merge_vector_C4_D5_1(int rows, int cols,\n"
"__global float *mat_dst,  int dst_step,\n"
"__global float *mat_src0, int src0_step,\n"
"__global float *mat_src1, int src1_step,\n"
"__global float *mat_src2, int src2_step,\n"
"__global float *mat_src3, int src3_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global float *src0_y = (__global float * )((__global uchar*)mat_src0 + y * src0_step);\n"
"__global float *src1_y = (__global float * )((__global uchar*)mat_src1 + y * src1_step);\n"
"__global float *src2_y = (__global float * )((__global uchar*)mat_src2 + y * src0_step);\n"
"__global float *src3_y = (__global float * )((__global uchar*)mat_src3 + y * src1_step);\n"
"__global float4 *dst_y  = (__global float4 *)((__global uchar*)mat_dst  + y * dst_step);\n"
"float value0 = src0_y[x];\n"
"float value1 = src1_y[x];\n"
"float value2 = src2_y[x];\n"
"float value3 = src3_y[x];\n"
"dst_y[x] = (float4)(value0, value1, value2, value3);\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void merge_vector_C4_D6_1(int rows, int cols,\n"
"__global double *mat_dst,  int dst_step,\n"
"__global double *mat_src0, int src0_step,\n"
"__global double *mat_src1, int src1_step,\n"
"__global double *mat_src2, int src2_step,\n"
"__global double *mat_src3, int src3_step)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if ((x < cols) && (y < rows))\n"
"{\n"
"__global double *src0_y = (__global double * )((__global uchar*)mat_src0 + y * src0_step);\n"
"__global double *src1_y = (__global double * )((__global uchar*)mat_src1 + y * src1_step);\n"
"__global double *src2_y = (__global double * )((__global uchar*)mat_src2 + y * src0_step);\n"
"__global double *src3_y = (__global double * )((__global uchar*)mat_src3 + y * src1_step);\n"
"__global double4 *dst_y  = (__global double4 *)((__global uchar*)mat_dst  + y * dst_step);\n"
"double value0 = src0_y[x];\n"
"double value1 = src1_y[x];\n"
"double value2 = src2_y[x];\n"
"double value3 = src3_y[x];\n"
"dst_y[x] = (double4)(value0, value1, value2, value3);\n"
"}\n"
"}\n"
"#endif\n"
;
const char* moments="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"typedef double T;\n"
"typedef double F;\n"
"typedef double4 F4;\n"
"#define convert_F4 convert_double4\n"
"#else\n"
"typedef float F;\n"
"typedef float4 F4;\n"
"typedef long T;\n"
"#define convert_F4 convert_float4\n"
"#endif\n"
"#define DST_ROW_00     0\n"
"#define DST_ROW_10     1\n"
"#define DST_ROW_01     2\n"
"#define DST_ROW_20     3\n"
"#define DST_ROW_11     4\n"
"#define DST_ROW_02     5\n"
"#define DST_ROW_30     6\n"
"#define DST_ROW_21     7\n"
"#define DST_ROW_12     8\n"
"#define DST_ROW_03     9\n"
"__kernel void icvContourMoments(int contour_total,\n"
"__global float* reader_oclmat_data,\n"
"__global T* dst_a,\n"
"int dst_step)\n"
"{\n"
"T xi_1, yi_1, xi_12, yi_12, xi, yi, xi2, yi2, dxy, xii_1, yii_1;\n"
"int idx = get_global_id(0);\n"
"if (idx < 0 || idx >= contour_total)\n"
"return;\n"
"xi_1 = (T)(*(reader_oclmat_data + (get_global_id(0) << 1)));\n"
"yi_1 = (T)(*(reader_oclmat_data + (get_global_id(0) << 1) + 1));\n"
"xi_12 = xi_1 * xi_1;\n"
"yi_12 = yi_1 * yi_1;\n"
"if(idx == contour_total - 1)\n"
"{\n"
"xi = (T)(*(reader_oclmat_data));\n"
"yi = (T)(*(reader_oclmat_data + 1));\n"
"}\n"
"else\n"
"{\n"
"xi = (T)(*(reader_oclmat_data + (idx + 1) * 2));\n"
"yi = (T)(*(reader_oclmat_data + (idx + 1) * 2 + 1));\n"
"}\n"
"xi2 = xi * xi;\n"
"yi2 = yi * yi;\n"
"dxy = xi_1 * yi - xi * yi_1;\n"
"xii_1 = xi_1 + xi;\n"
"yii_1 = yi_1 + yi;\n"
"dst_step /= sizeof(T);\n"
"*( dst_a + DST_ROW_00 * dst_step + idx) = dxy;\n"
"*( dst_a + DST_ROW_10 * dst_step + idx) = dxy * xii_1;\n"
"*( dst_a + DST_ROW_01 * dst_step + idx) = dxy * yii_1;\n"
"*( dst_a + DST_ROW_20 * dst_step + idx) = dxy * (xi_1 * xii_1 + xi2);\n"
"*( dst_a + DST_ROW_11 * dst_step + idx) = dxy * (xi_1 * (yii_1 + yi_1) + xi * (yii_1 + yi));\n"
"*( dst_a + DST_ROW_02 * dst_step + idx) = dxy * (yi_1 * yii_1 + yi2);\n"
"*( dst_a + DST_ROW_30 * dst_step + idx) = dxy * xii_1 * (xi_12 + xi2);\n"
"*( dst_a + DST_ROW_03 * dst_step + idx) = dxy * yii_1 * (yi_12 + yi2);\n"
"*( dst_a + DST_ROW_21 * dst_step + idx) =\n"
"dxy * (xi_12 * (3 * yi_1 + yi) + 2 * xi * xi_1 * yii_1 +\n"
"xi2 * (yi_1 + 3 * yi));\n"
"*( dst_a + DST_ROW_12 * dst_step + idx) =\n"
"dxy * (yi_12 * (3 * xi_1 + xi) + 2 * yi * yi_1 * xii_1 +\n"
"yi2 * (xi_1 + 3 * xi));\n"
"}\n"
"__kernel void dst_sum(int src_rows, int src_cols, int tile_height, int tile_width, int TILE_SIZE,\n"
"__global F* sum, __global F* dst_m, int dst_step)\n"
"{\n"
"int gidy = get_global_id(0);\n"
"int gidx = get_global_id(1);\n"
"int block_y = src_rows/tile_height;\n"
"int block_x = src_cols/tile_width;\n"
"int block_num;\n"
"if(src_rows > TILE_SIZE && src_rows % TILE_SIZE != 0)\n"
"block_y ++;\n"
"if(src_cols > TILE_SIZE && src_cols % TILE_SIZE != 0)\n"
"block_x ++;\n"
"block_num = block_y * block_x;\n"
"__local F dst_sum[10][128];\n"
"if(gidy<128-block_num)\n"
"for(int i=0; i<10; i++)\n"
"dst_sum[i][gidy+block_num]=0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"dst_step /= sizeof(F);\n"
"if(gidy<block_num)\n"
"{\n"
"dst_sum[0][gidy] = *(dst_m + mad24(DST_ROW_00 * block_y, dst_step, gidy));\n"
"dst_sum[1][gidy] = *(dst_m + mad24(DST_ROW_10 * block_y, dst_step, gidy));\n"
"dst_sum[2][gidy] = *(dst_m + mad24(DST_ROW_01 * block_y, dst_step, gidy));\n"
"dst_sum[3][gidy] = *(dst_m + mad24(DST_ROW_20 * block_y, dst_step, gidy));\n"
"dst_sum[4][gidy] = *(dst_m + mad24(DST_ROW_11 * block_y, dst_step, gidy));\n"
"dst_sum[5][gidy] = *(dst_m + mad24(DST_ROW_02 * block_y, dst_step, gidy));\n"
"dst_sum[6][gidy] = *(dst_m + mad24(DST_ROW_30 * block_y, dst_step, gidy));\n"
"dst_sum[7][gidy] = *(dst_m + mad24(DST_ROW_21 * block_y, dst_step, gidy));\n"
"dst_sum[8][gidy] = *(dst_m + mad24(DST_ROW_12 * block_y, dst_step, gidy));\n"
"dst_sum[9][gidy] = *(dst_m + mad24(DST_ROW_03 * block_y, dst_step, gidy));\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int lsize=64; lsize>0; lsize>>=1)\n"
"{\n"
"if(gidy<lsize)\n"
"{\n"
"int lsize2 = gidy + lsize;\n"
"for(int i=0; i<10; i++)\n"
"dst_sum[i][gidy] += dst_sum[i][lsize2];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if(gidy==0)\n"
"for(int i=0; i<10; i++)\n"
"sum[i] = dst_sum[i][0];\n"
"}\n"
"__kernel void CvMoments_D0(__global uchar16* src_data, int src_rows, int src_cols, int src_step, int tileSize_width, int tileSize_height,\n"
"__global F* dst_m,\n"
"int dst_cols, int dst_step, int blocky,\n"
"int type, int depth, int cn, int coi, int binary, int TILE_SIZE)\n"
"{\n"
"uchar tmp_coi[16];\n"
"uchar16 tmp[16];\n"
"int VLEN_C = 16;\n"
"int gidy = get_global_id(0);\n"
"int gidx = get_global_id(1);\n"
"int wgidy = get_group_id(0);\n"
"int wgidx = get_group_id(1);\n"
"int lidy = get_local_id(0);\n"
"int lidx = get_local_id(1);\n"
"int y = wgidy*TILE_SIZE;\n"
"int x = wgidx*TILE_SIZE;\n"
"int kcn = (cn==2)?2:4;\n"
"int rstep = min(src_step, TILE_SIZE);\n"
"tileSize_height = min(TILE_SIZE, src_rows - y);\n"
"tileSize_width = min(TILE_SIZE, src_cols - x);\n"
"if( tileSize_width < TILE_SIZE )\n"
"for(int i = tileSize_width; i < rstep; i++ )\n"
"*((__global uchar*)src_data+(y+lidy)*src_step+x+i) = 0;\n"
"if( coi > 0 )\n"
"for(int i = 0; i < tileSize_width; i += VLEN_C)\n"
"{\n"
"for(int j=0; j<VLEN_C; j++)\n"
"tmp_coi[j] = *((__global uchar*)src_data+(y+lidy)*src_step+(x+i+j)*kcn+coi-1);\n"
"tmp[i/VLEN_C] = (uchar16)(tmp_coi[0],tmp_coi[1],tmp_coi[2],tmp_coi[3],tmp_coi[4],tmp_coi[5],tmp_coi[6],tmp_coi[7],\n"
"tmp_coi[8],tmp_coi[9],tmp_coi[10],tmp_coi[11],tmp_coi[12],tmp_coi[13],tmp_coi[14],tmp_coi[15]);\n"
"}\n"
"else\n"
"for(int i=0; i < tileSize_width; i+=VLEN_C)\n"
"tmp[i/VLEN_C] = *(src_data+(y+lidy)*src_step/VLEN_C+(x+i)/VLEN_C);\n"
"uchar16 zero = (uchar16)(0);\n"
"uchar16 full = (uchar16)(255);\n"
"if( binary )\n"
"for(int i=0; i < tileSize_width; i+=VLEN_C)\n"
"tmp[i/VLEN_C] = (tmp[i/VLEN_C]!=zero)?full:zero;\n"
"F mom[10];\n"
"__local int m[10][128];\n"
"if(lidy == 0)\n"
"for(int i=0; i<10; i++)\n"
"for(int j=0; j<128; j++)\n"
"m[i][j]=0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int lm[10] = {0};\n"
"int16 x0 = (int16)(0);\n"
"int16 x1 = (int16)(0);\n"
"int16 x2 = (int16)(0);\n"
"int16 x3 = (int16)(0);\n"
"for( int xt = 0 ; xt < tileSize_width; xt+=(VLEN_C) )\n"
"{\n"
"int16 v_xt = (int16)(xt, xt+1, xt+2, xt+3, xt+4, xt+5, xt+6, xt+7, xt+8, xt+9, xt+10, xt+11, xt+12, xt+13, xt+14, xt+15);\n"
"int16 p = convert_int16(tmp[xt/VLEN_C]);\n"
"int16 xp = v_xt * p, xxp = xp *v_xt;\n"
"x0 += p;\n"
"x1 += xp;\n"
"x2 += xxp;\n"
"x3 += xxp * v_xt;\n"
"}\n"
"x0.s0 += x0.s1 + x0.s2 + x0.s3 + x0.s4 + x0.s5 + x0.s6 + x0.s7 + x0.s8 + x0.s9 + x0.sa + x0.sb + x0.sc + x0.sd + x0.se + x0.sf;\n"
"x1.s0 += x1.s1 + x1.s2 + x1.s3 + x1.s4 + x1.s5 + x1.s6 + x1.s7 + x1.s8 + x1.s9 + x1.sa + x1.sb + x1.sc + x1.sd + x1.se + x1.sf;\n"
"x2.s0 += x2.s1 + x2.s2 + x2.s3 + x2.s4 + x2.s5 + x2.s6 + x2.s7 + x2.s8 + x2.s9 + x2.sa + x2.sb + x2.sc + x2.sd + x2.se + x2.sf;\n"
"x3.s0 += x3.s1 + x3.s2 + x3.s3 + x3.s4 + x3.s5 + x3.s6 + x3.s7 + x3.s8 + x3.s9 + x3.sa + x3.sb + x3.sc + x3.sd + x3.se + x3.sf;\n"
"int py = lidy * ((int)x0.s0);\n"
"int sy = lidy*lidy;\n"
"int bheight = min(tileSize_height, TILE_SIZE/2);\n"
"if(bheight >= TILE_SIZE/2&&lidy > bheight-1&&lidy < tileSize_height)\n"
"{\n"
"m[9][lidy-bheight] = ((int)py) * sy;\n"
"m[8][lidy-bheight] = ((int)x1.s0) * sy;\n"
"m[7][lidy-bheight] = ((int)x2.s0) * lidy;\n"
"m[6][lidy-bheight] = x3.s0;\n"
"m[5][lidy-bheight] = x0.s0 * sy;\n"
"m[4][lidy-bheight] = x1.s0 * lidy;\n"
"m[3][lidy-bheight] = x2.s0;\n"
"m[2][lidy-bheight] = py;\n"
"m[1][lidy-bheight] = x1.s0;\n"
"m[0][lidy-bheight] = x0.s0;\n"
"}\n"
"else if(lidy < bheight)\n"
"{\n"
"lm[9] = ((int)py) * sy;\n"
"lm[8] = ((int)x1.s0) * sy;\n"
"lm[7] = ((int)x2.s0) * lidy;\n"
"lm[6] = x3.s0;\n"
"lm[5] = x0.s0 * sy;\n"
"lm[4] = x1.s0 * lidy;\n"
"lm[3] = x2.s0;\n"
"lm[2] = py;\n"
"lm[1] = x1.s0;\n"
"lm[0] = x0.s0;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for( int j = bheight; j >= 1; j = j/2 )\n"
"{\n"
"if(lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"lm[i] = lm[i] + m[i][lidy];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lidy >= j/2&&lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"m[i][lidy-j/2] = lm[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if(lidy == 0&&lidx == 0)\n"
"{\n"
"for( int mt = 0; mt < 10; mt++ )\n"
"mom[mt] = (F)lm[mt];\n"
"if(binary)\n"
"{\n"
"F s = 1./255;\n"
"for( int mt = 0; mt < 10; mt++ )\n"
"mom[mt] *= s;\n"
"}\n"
"F xm = x * mom[0], ym = y * mom[0];\n"
"dst_step /= sizeof(F);\n"
"*(dst_m + mad24(DST_ROW_00 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[0];\n"
"*(dst_m + mad24(DST_ROW_10 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[1] + xm;\n"
"*(dst_m + mad24(DST_ROW_01 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[2] + ym;\n"
"*(dst_m + mad24(DST_ROW_20 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[3] + x * (mom[1] * 2 + xm);\n"
"*(dst_m + mad24(DST_ROW_11 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[4] + x * (mom[2] + ym) + y * mom[1];\n"
"*(dst_m + mad24(DST_ROW_02 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[5] + y * (mom[2] * 2 + ym);\n"
"*(dst_m + mad24(DST_ROW_30 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[6] + x * (3. * mom[3] + x * (3. * mom[1] + xm));\n"
"*(dst_m + mad24(DST_ROW_21 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[7] + x * (2 * (mom[4] + y * mom[1]) + x * (mom[2] + ym)) + y * mom[3];\n"
"*(dst_m + mad24(DST_ROW_12 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[8] + y * (2 * (mom[4] + x * mom[2]) + y * (mom[1] + xm)) + x * mom[5];\n"
"*(dst_m + mad24(DST_ROW_03 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[9] + y * (3. * mom[5] + y * (3. * mom[2] + ym));\n"
"}\n"
"}\n"
"__kernel void CvMoments_D2(__global ushort8* src_data, int src_rows, int src_cols, int src_step, int tileSize_width, int tileSize_height,\n"
"__global F* dst_m,\n"
"int dst_cols, int dst_step, int blocky,\n"
"int type, int depth, int cn, int coi, int binary, const int TILE_SIZE)\n"
"{\n"
"ushort tmp_coi[8];\n"
"ushort8 tmp[32];\n"
"int VLEN_US = 8;\n"
"int gidy = get_global_id(0);\n"
"int gidx = get_global_id(1);\n"
"int wgidy = get_group_id(0);\n"
"int wgidx = get_group_id(1);\n"
"int lidy = get_local_id(0);\n"
"int lidx = get_local_id(1);\n"
"int y = wgidy*TILE_SIZE;\n"
"int x = wgidx*TILE_SIZE;\n"
"int kcn = (cn==2)?2:4;\n"
"int rstep = min(src_step/2, TILE_SIZE);\n"
"tileSize_height = min(TILE_SIZE, src_rows - y);\n"
"tileSize_width = min(TILE_SIZE, src_cols -x);\n"
"if(src_cols > TILE_SIZE && tileSize_width < TILE_SIZE)\n"
"for(int i=tileSize_width; i < rstep; i++ )\n"
"*((__global ushort*)src_data+(y+lidy)*src_step/2+x+i) = 0;\n"
"if( coi > 0 )\n"
"for(int i=0; i < tileSize_width; i+=VLEN_US)\n"
"{\n"
"for(int j=0; j<VLEN_US; j++)\n"
"tmp_coi[j] = *((__global ushort*)src_data+(y+lidy)*(int)src_step/2+(x+i+j)*kcn+coi-1);\n"
"tmp[i/VLEN_US] = (ushort8)(tmp_coi[0],tmp_coi[1],tmp_coi[2],tmp_coi[3],tmp_coi[4],tmp_coi[5],tmp_coi[6],tmp_coi[7]);\n"
"}\n"
"else\n"
"for(int i=0; i < tileSize_width; i+=VLEN_US)\n"
"tmp[i/VLEN_US] = *(src_data+(y+lidy)*src_step/(2*VLEN_US)+(x+i)/VLEN_US);\n"
"ushort8 zero = (ushort8)(0);\n"
"ushort8 full = (ushort8)(255);\n"
"if( binary )\n"
"for(int i=0; i < tileSize_width; i+=VLEN_US)\n"
"tmp[i/VLEN_US] = (tmp[i/VLEN_US]!=zero)?full:zero;\n"
"F mom[10];\n"
"__local long m[10][128];\n"
"if(lidy == 0)\n"
"for(int i=0; i<10; i++)\n"
"for(int j=0; j<128; j++)\n"
"m[i][j]=0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"long lm[10] = {0};\n"
"int8 x0 = (int8)(0);\n"
"int8 x1 = (int8)(0);\n"
"int8 x2 = (int8)(0);\n"
"long8 x3 = (long8)(0);\n"
"for( int xt = 0 ; xt < tileSize_width; xt+=(VLEN_US) )\n"
"{\n"
"int8 v_xt = (int8)(xt, xt+1, xt+2, xt+3, xt+4, xt+5, xt+6, xt+7);\n"
"int8 p = convert_int8(tmp[xt/VLEN_US]);\n"
"int8 xp = v_xt * p, xxp = xp * v_xt;\n"
"x0 += p;\n"
"x1 += xp;\n"
"x2 += xxp;\n"
"x3 += convert_long8(xxp) *convert_long8(v_xt);\n"
"}\n"
"x0.s0 += x0.s1 + x0.s2 + x0.s3 + x0.s4 + x0.s5 + x0.s6 + x0.s7;\n"
"x1.s0 += x1.s1 + x1.s2 + x1.s3 + x1.s4 + x1.s5 + x1.s6 + x1.s7;\n"
"x2.s0 += x2.s1 + x2.s2 + x2.s3 + x2.s4 + x2.s5 + x2.s6 + x2.s7;\n"
"x3.s0 += x3.s1 + x3.s2 + x3.s3 + x3.s4 + x3.s5 + x3.s6 + x3.s7;\n"
"int py = lidy * x0.s0, sy = lidy*lidy;\n"
"int bheight = min(tileSize_height, TILE_SIZE/2);\n"
"if(bheight >= TILE_SIZE/2&&lidy > bheight-1&&lidy < tileSize_height)\n"
"{\n"
"m[9][lidy-bheight] = ((long)py) * sy;\n"
"m[8][lidy-bheight] = ((long)x1.s0) * sy;\n"
"m[7][lidy-bheight] = ((long)x2.s0) * lidy;\n"
"m[6][lidy-bheight] = x3.s0;\n"
"m[5][lidy-bheight] = x0.s0 * sy;\n"
"m[4][lidy-bheight] = x1.s0 * lidy;\n"
"m[3][lidy-bheight] = x2.s0;\n"
"m[2][lidy-bheight] = py;\n"
"m[1][lidy-bheight] = x1.s0;\n"
"m[0][lidy-bheight] = x0.s0;\n"
"}\n"
"else if(lidy < bheight)\n"
"{\n"
"lm[9] = ((long)py) * sy;\n"
"lm[8] = ((long)x1.s0) * sy;\n"
"lm[7] = ((long)x2.s0) * lidy;\n"
"lm[6] = x3.s0;\n"
"lm[5] = x0.s0 * sy;\n"
"lm[4] = x1.s0 * lidy;\n"
"lm[3] = x2.s0;\n"
"lm[2] = py;\n"
"lm[1] = x1.s0;\n"
"lm[0] = x0.s0;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for( int j = TILE_SIZE/2; j >= 1; j = j/2 )\n"
"{\n"
"if(lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"lm[i] = lm[i] + m[i][lidy];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lidy >= j/2&&lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"m[i][lidy-j/2] = lm[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if(lidy == 0&&lidx == 0)\n"
"{\n"
"for(int mt = 0; mt < 10; mt++ )\n"
"mom[mt] = (F)lm[mt];\n"
"if(binary)\n"
"{\n"
"F s = 1./255;\n"
"for( int mt = 0; mt < 10; mt++ )\n"
"mom[mt] *= s;\n"
"}\n"
"F xm = x  *mom[0], ym = y * mom[0];\n"
"dst_step /= sizeof(F);\n"
"*(dst_m + mad24(DST_ROW_00 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[0];\n"
"*(dst_m + mad24(DST_ROW_10 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[1] + xm;\n"
"*(dst_m + mad24(DST_ROW_01 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[2] + ym;\n"
"*(dst_m + mad24(DST_ROW_20 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[3] + x * (mom[1] * 2 + xm);\n"
"*(dst_m + mad24(DST_ROW_11 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[4] + x * (mom[2] + ym) + y * mom[1];\n"
"*(dst_m + mad24(DST_ROW_02 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[5] + y * (mom[2] * 2 + ym);\n"
"*(dst_m + mad24(DST_ROW_30 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[6] + x * (3. * mom[3] + x * (3. * mom[1] + xm));\n"
"*(dst_m + mad24(DST_ROW_21 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[7] + x * (2 * (mom[4] + y * mom[1]) + x * (mom[2] + ym)) + y * mom[3];\n"
"*(dst_m + mad24(DST_ROW_12 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[8] + y * (2 * (mom[4] + x * mom[2]) + y * (mom[1] + xm)) + x * mom[5];\n"
"*(dst_m + mad24(DST_ROW_03 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[9] + y * (3. * mom[5] + y * (3. * mom[2] + ym));\n"
"}\n"
"}\n"
"__kernel void CvMoments_D3(__global short8* src_data, int src_rows, int src_cols, int src_step, int tileSize_width, int tileSize_height,\n"
"__global F* dst_m,\n"
"int dst_cols, int dst_step, int blocky,\n"
"int type, int depth, int cn, int coi, int binary, const int TILE_SIZE)\n"
"{\n"
"short tmp_coi[8];\n"
"short8 tmp[32];\n"
"int VLEN_S =8;\n"
"int gidy = get_global_id(0);\n"
"int gidx = get_global_id(1);\n"
"int wgidy = get_group_id(0);\n"
"int wgidx = get_group_id(1);\n"
"int lidy = get_local_id(0);\n"
"int lidx = get_local_id(1);\n"
"int y = wgidy*TILE_SIZE;\n"
"int x = wgidx*TILE_SIZE;\n"
"int kcn = (cn==2)?2:4;\n"
"int rstep = min(src_step/2, TILE_SIZE);\n"
"tileSize_height = min(TILE_SIZE, src_rows - y);\n"
"tileSize_width = min(TILE_SIZE, src_cols -x);\n"
"if(tileSize_width < TILE_SIZE)\n"
"for(int i = tileSize_width; i < rstep; i++ )\n"
"*((__global short*)src_data+(y+lidy)*src_step/2+x+i) = 0;\n"
"if( coi > 0 )\n"
"for(int i=0; i < tileSize_width; i+=VLEN_S)\n"
"{\n"
"for(int j=0; j<VLEN_S; j++)\n"
"tmp_coi[j] = *((__global short*)src_data+(y+lidy)*src_step/2+(x+i+j)*kcn+coi-1);\n"
"tmp[i/VLEN_S] = (short8)(tmp_coi[0],tmp_coi[1],tmp_coi[2],tmp_coi[3],tmp_coi[4],tmp_coi[5],tmp_coi[6],tmp_coi[7]);\n"
"}\n"
"else\n"
"for(int i=0; i < tileSize_width; i+=VLEN_S)\n"
"tmp[i/VLEN_S] = *(src_data+(y+lidy)*src_step/(2*VLEN_S)+(x+i)/VLEN_S);\n"
"short8 zero = (short8)(0);\n"
"short8 full = (short8)(255);\n"
"if( binary )\n"
"for(int i=0; i < tileSize_width; i+=(VLEN_S))\n"
"tmp[i/VLEN_S] = (tmp[i/VLEN_S]!=zero)?full:zero;\n"
"F mom[10];\n"
"__local long m[10][128];\n"
"if(lidy == 0)\n"
"for(int i=0; i<10; i++)\n"
"for(int j=0; j<128; j++)\n"
"m[i][j]=0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"long lm[10] = {0};\n"
"int8 x0 = (int8)(0);\n"
"int8 x1 = (int8)(0);\n"
"int8 x2 = (int8)(0);\n"
"long8 x3 = (long8)(0);\n"
"for( int xt = 0 ; xt < tileSize_width; xt+= (VLEN_S))\n"
"{\n"
"int8 v_xt = (int8)(xt, xt+1, xt+2, xt+3, xt+4, xt+5, xt+6, xt+7);\n"
"int8 p = convert_int8(tmp[xt/VLEN_S]);\n"
"int8 xp = v_xt * p, xxp = xp * v_xt;\n"
"x0 += p;\n"
"x1 += xp;\n"
"x2 += xxp;\n"
"x3 += convert_long8(xxp) * convert_long8(v_xt);\n"
"}\n"
"x0.s0 += x0.s1 + x0.s2 + x0.s3 + x0.s4 + x0.s5 + x0.s6 + x0.s7;\n"
"x1.s0 += x1.s1 + x1.s2 + x1.s3 + x1.s4 + x1.s5 + x1.s6 + x1.s7;\n"
"x2.s0 += x2.s1 + x2.s2 + x2.s3 + x2.s4 + x2.s5 + x2.s6 + x2.s7;\n"
"x3.s0 += x3.s1 + x3.s2 + x3.s3 + x3.s4 + x3.s5 + x3.s6 + x3.s7;\n"
"int py = lidy * x0.s0, sy = lidy*lidy;\n"
"int bheight = min(tileSize_height, TILE_SIZE/2);\n"
"if(bheight >= TILE_SIZE/2&&lidy > bheight-1&&lidy < tileSize_height)\n"
"{\n"
"m[9][lidy-bheight] = ((long)py) * sy;\n"
"m[8][lidy-bheight] = ((long)x1.s0) * sy;\n"
"m[7][lidy-bheight] = ((long)x2.s0) * lidy;\n"
"m[6][lidy-bheight] = x3.s0;\n"
"m[5][lidy-bheight] = x0.s0 * sy;\n"
"m[4][lidy-bheight] = x1.s0 * lidy;\n"
"m[3][lidy-bheight] = x2.s0;\n"
"m[2][lidy-bheight] = py;\n"
"m[1][lidy-bheight] = x1.s0;\n"
"m[0][lidy-bheight] = x0.s0;\n"
"}\n"
"else if(lidy < bheight)\n"
"{\n"
"lm[9] = ((long)py) * sy;\n"
"lm[8] = ((long)(x1.s0)) * sy;\n"
"lm[7] = ((long)(x2.s0)) * lidy;\n"
"lm[6] = x3.s0;\n"
"lm[5] = x0.s0 * sy;\n"
"lm[4] = x1.s0 * lidy;\n"
"lm[3] = x2.s0;\n"
"lm[2] = py;\n"
"lm[1] = x1.s0;\n"
"lm[0] = x0.s0;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for( int j = TILE_SIZE/2; j >=1; j = j/2 )\n"
"{\n"
"if(lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"lm[i] = lm[i] + m[i][lidy];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lidy >= j/2&&lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"m[i][lidy-j/2] = lm[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if(lidy ==0 &&lidx ==0)\n"
"{\n"
"for(int mt = 0; mt < 10; mt++ )\n"
"mom[mt] = (F)lm[mt];\n"
"if(binary)\n"
"{\n"
"F s = 1./255;\n"
"for( int mt = 0; mt < 10; mt++ )\n"
"mom[mt] *= s;\n"
"}\n"
"F xm = x * mom[0], ym = y*mom[0];\n"
"dst_step /= sizeof(F);\n"
"*(dst_m + mad24(DST_ROW_00 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[0];\n"
"*(dst_m + mad24(DST_ROW_10 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[1] + xm;\n"
"*(dst_m + mad24(DST_ROW_01 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[2] + ym;\n"
"*(dst_m + mad24(DST_ROW_20 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[3] + x * (mom[1] * 2 + xm);\n"
"*(dst_m + mad24(DST_ROW_11 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[4] + x * (mom[2] + ym) + y * mom[1];\n"
"*(dst_m + mad24(DST_ROW_02 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[5] + y * (mom[2] * 2 + ym);\n"
"*(dst_m + mad24(DST_ROW_30 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[6] + x * (3. * mom[3] + x * (3. * mom[1] + xm));\n"
"*(dst_m + mad24(DST_ROW_21 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[7] + x * (2 * (mom[4] + y * mom[1]) + x * (mom[2] + ym)) + y * mom[3];\n"
"*(dst_m + mad24(DST_ROW_12 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[8] + y * (2 * (mom[4] + x * mom[2]) + y * (mom[1] + xm)) + x * mom[5];\n"
"*(dst_m + mad24(DST_ROW_03 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[9] + y * (3. * mom[5] + y * (3. * mom[2] + ym));\n"
"}\n"
"}\n"
"__kernel void CvMoments_D5( __global float* src_data, int src_rows, int src_cols, int src_step, int tileSize_width, int tileSize_height,\n"
"__global F* dst_m,\n"
"int dst_cols, int dst_step, int blocky,\n"
"int type, int depth, int cn, int coi, int binary, const int TILE_SIZE)\n"
"{\n"
"float tmp_coi[4];\n"
"float4 tmp[64] ;\n"
"int VLEN_F = 4;\n"
"int gidy = get_global_id(0);\n"
"int gidx = get_global_id(1);\n"
"int wgidy = get_group_id(0);\n"
"int wgidx = get_group_id(1);\n"
"int lidy = get_local_id(0);\n"
"int lidx = get_local_id(1);\n"
"int y = wgidy*TILE_SIZE;\n"
"int x = wgidx*TILE_SIZE;\n"
"int kcn = (cn==2)?2:4;\n"
"int rstep = min(src_step/4, TILE_SIZE);\n"
"tileSize_height = min(TILE_SIZE, src_rows - y);\n"
"tileSize_width = min(TILE_SIZE, src_cols -x);\n"
"if(tileSize_width < TILE_SIZE)\n"
"for(int i = tileSize_width; i < rstep; i++ )\n"
"*((__global float*)src_data+(y+lidy)*src_step/4+x+i) = 0;\n"
"if( coi > 0 )\n"
"for(int i=0; i < tileSize_width; i+=VLEN_F)\n"
"{\n"
"for(int j=0; j<4; j++)\n"
"tmp_coi[j] = *(src_data+(y+lidy)*src_step/4+(x+i+j)*kcn+coi-1);\n"
"tmp[i/VLEN_F] = (float4)(tmp_coi[0],tmp_coi[1],tmp_coi[2],tmp_coi[3]);\n"
"}\n"
"else\n"
"for(int i=0; i < tileSize_width; i+=VLEN_F)\n"
"tmp[i/VLEN_F] = (float4)(*(src_data+(y+lidy)*src_step/4+x+i),*(src_data+(y+lidy)*src_step/4+x+i+1),*(src_data+(y+lidy)*src_step/4+x+i+2),*(src_data+(y+lidy)*src_step/4+x+i+3));\n"
"float4 zero = (float4)(0);\n"
"float4 full = (float4)(255);\n"
"if( binary )\n"
"for(int i=0; i < tileSize_width; i+=4)\n"
"tmp[i/VLEN_F] = (tmp[i/VLEN_F]!=zero)?full:zero;\n"
"F mom[10];\n"
"__local F m[10][128];\n"
"if(lidy == 0)\n"
"for(int i = 0; i < 10; i ++)\n"
"for(int j = 0; j < 128; j ++)\n"
"m[i][j] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"F lm[10] = {0};\n"
"F4 x0 = (F4)(0);\n"
"F4 x1 = (F4)(0);\n"
"F4 x2 = (F4)(0);\n"
"F4 x3 = (F4)(0);\n"
"for( int xt = 0 ; xt < tileSize_width; xt+=VLEN_F )\n"
"{\n"
"F4 v_xt = (F4)(xt, xt+1, xt+2, xt+3);\n"
"F4 p = convert_F4(tmp[xt/VLEN_F]);\n"
"F4 xp = v_xt * p, xxp = xp * v_xt;\n"
"x0 += p;\n"
"x1 += xp;\n"
"x2 += xxp;\n"
"x3 += xxp * v_xt;\n"
"}\n"
"x0.s0 += x0.s1 + x0.s2 + x0.s3;\n"
"x1.s0 += x1.s1 + x1.s2 + x1.s3;\n"
"x2.s0 += x2.s1 + x2.s2 + x2.s3;\n"
"x3.s0 += x3.s1 + x3.s2 + x3.s3;\n"
"F py = lidy * x0.s0, sy = lidy*lidy;\n"
"int bheight = min(tileSize_height, TILE_SIZE/2);\n"
"if(bheight >= TILE_SIZE/2&&lidy > bheight-1&&lidy < tileSize_height)\n"
"{\n"
"m[9][lidy-bheight] = ((F)py) * sy;\n"
"m[8][lidy-bheight] = ((F)x1.s0) * sy;\n"
"m[7][lidy-bheight] = ((F)x2.s0) * lidy;\n"
"m[6][lidy-bheight] = x3.s0;\n"
"m[5][lidy-bheight] = x0.s0 * sy;\n"
"m[4][lidy-bheight] = x1.s0 * lidy;\n"
"m[3][lidy-bheight] = x2.s0;\n"
"m[2][lidy-bheight] = py;\n"
"m[1][lidy-bheight] = x1.s0;\n"
"m[0][lidy-bheight] = x0.s0;\n"
"}\n"
"else if(lidy < bheight)\n"
"{\n"
"lm[9] = ((F)py) * sy;\n"
"lm[8] = ((F)x1.s0) * sy;\n"
"lm[7] = ((F)x2.s0) * lidy;\n"
"lm[6] = x3.s0;\n"
"lm[5] = x0.s0 * sy;\n"
"lm[4] = x1.s0 * lidy;\n"
"lm[3] = x2.s0;\n"
"lm[2] = py;\n"
"lm[1] = x1.s0;\n"
"lm[0] = x0.s0;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for( int j = TILE_SIZE/2; j >= 1; j = j/2 )\n"
"{\n"
"if(lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"lm[i] = lm[i] + m[i][lidy];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lidy >= j/2&&lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"m[i][lidy-j/2] = lm[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if(lidy == 0&&lidx == 0)\n"
"{\n"
"for( int mt = 0; mt < 10; mt++ )\n"
"mom[mt] = (F)lm[mt];\n"
"if(binary)\n"
"{\n"
"F s = 1./255;\n"
"for( int mt = 0; mt < 10; mt++ )\n"
"mom[mt] *= s;\n"
"}\n"
"F xm = x * mom[0], ym = y * mom[0];\n"
"dst_step /= sizeof(F);\n"
"*(dst_m + mad24(DST_ROW_00 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[0];\n"
"*(dst_m + mad24(DST_ROW_10 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[1] + xm;\n"
"*(dst_m + mad24(DST_ROW_01 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[2] + ym;\n"
"*(dst_m + mad24(DST_ROW_20 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[3] + x * (mom[1] * 2 + xm);\n"
"*(dst_m + mad24(DST_ROW_11 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[4] + x * (mom[2] + ym) + y * mom[1];\n"
"*(dst_m + mad24(DST_ROW_02 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[5] + y * (mom[2] * 2 + ym);\n"
"*(dst_m + mad24(DST_ROW_30 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[6] + x * (3. * mom[3] + x * (3. * mom[1] + xm));\n"
"*(dst_m + mad24(DST_ROW_21 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[7] + x * (2 * (mom[4] + y * mom[1]) + x * (mom[2] + ym)) + y * mom[3];\n"
"*(dst_m + mad24(DST_ROW_12 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[8] + y * (2 * (mom[4] + x * mom[2]) + y * (mom[1] + xm)) + x * mom[5];\n"
"*(dst_m + mad24(DST_ROW_03 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[9] + y * (3. * mom[5] + y * (3. * mom[2] + ym));\n"
"}\n"
"}\n"
"__kernel void CvMoments_D6(__global F* src_data,  int src_rows, int src_cols, int src_step, int tileSize_width, int tileSize_height,\n"
"__global F* dst_m,\n"
"int dst_cols, int dst_step, int blocky,\n"
"int type, int depth, int cn, int coi, int binary, const int TILE_SIZE)\n"
"{\n"
"F tmp_coi[4];\n"
"F4 tmp[64];\n"
"int VLEN_D = 4;\n"
"int gidy = get_global_id(0);\n"
"int gidx = get_global_id(1);\n"
"int wgidy = get_group_id(0);\n"
"int wgidx = get_group_id(1);\n"
"int lidy = get_local_id(0);\n"
"int lidx = get_local_id(1);\n"
"int y = wgidy*TILE_SIZE;\n"
"int x = wgidx*TILE_SIZE;\n"
"int kcn = (cn==2)?2:4;\n"
"int rstep = min(src_step/8, TILE_SIZE);\n"
"tileSize_height = min(TILE_SIZE,  src_rows - y);\n"
"tileSize_width = min(TILE_SIZE, src_cols - x);\n"
"if(tileSize_width < TILE_SIZE)\n"
"for(int i = tileSize_width; i < rstep; i++ )\n"
"*((__global F*)src_data+(y+lidy)*src_step/8+x+i) = 0;\n"
"if( coi > 0 )\n"
"for(int i=0; i < tileSize_width; i+=VLEN_D)\n"
"{\n"
"for(int j=0; j<4; j++)\n"
"tmp_coi[j] = *(src_data+(y+lidy)*src_step/8+(x+i+j)*kcn+coi-1);\n"
"tmp[i/VLEN_D] = (F4)(tmp_coi[0],tmp_coi[1],tmp_coi[2],tmp_coi[3]);\n"
"}\n"
"else\n"
"for(int i=0; i < tileSize_width; i+=VLEN_D)\n"
"tmp[i/VLEN_D] = (F4)(*(src_data+(y+lidy)*src_step/8+x+i),*(src_data+(y+lidy)*src_step/8+x+i+1),*(src_data+(y+lidy)*src_step/8+x+i+2),*(src_data+(y+lidy)*src_step/8+x+i+3));\n"
"F4 zero = (F4)(0);\n"
"F4 full = (F4)(255);\n"
"if( binary )\n"
"for(int i=0; i < tileSize_width; i+=VLEN_D)\n"
"tmp[i/VLEN_D] = (tmp[i/VLEN_D]!=zero)?full:zero;\n"
"F mom[10];\n"
"__local F m[10][128];\n"
"if(lidy == 0)\n"
"for(int i=0; i<10; i++)\n"
"for(int j=0; j<128; j++)\n"
"m[i][j]=0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"F lm[10] = {0};\n"
"F4 x0 = (F4)(0);\n"
"F4 x1 = (F4)(0);\n"
"F4 x2 = (F4)(0);\n"
"F4 x3 = (F4)(0);\n"
"for( int xt = 0 ; xt < tileSize_width; xt+=VLEN_D )\n"
"{\n"
"F4 v_xt = (F4)(xt, xt+1, xt+2, xt+3);\n"
"F4 p = tmp[xt/VLEN_D];\n"
"F4 xp = v_xt * p, xxp = xp * v_xt;\n"
"x0 += p;\n"
"x1 += xp;\n"
"x2 += xxp;\n"
"x3 += xxp *v_xt;\n"
"}\n"
"x0.s0 += x0.s1 + x0.s2 + x0.s3;\n"
"x1.s0 += x1.s1 + x1.s2 + x1.s3;\n"
"x2.s0 += x2.s1 + x2.s2 + x2.s3;\n"
"x3.s0 += x3.s1 + x3.s2 + x3.s3;\n"
"F py = lidy * x0.s0, sy = lidy*lidy;\n"
"int bheight = min(tileSize_height, TILE_SIZE/2);\n"
"if(bheight >= TILE_SIZE/2&&lidy > bheight-1&&lidy < tileSize_height)\n"
"{\n"
"m[9][lidy-bheight] = ((F)py) * sy;\n"
"m[8][lidy-bheight] = ((F)x1.s0) * sy;\n"
"m[7][lidy-bheight] = ((F)x2.s0) * lidy;\n"
"m[6][lidy-bheight] = x3.s0;\n"
"m[5][lidy-bheight] = x0.s0 * sy;\n"
"m[4][lidy-bheight] = x1.s0 * lidy;\n"
"m[3][lidy-bheight] = x2.s0;\n"
"m[2][lidy-bheight] = py;\n"
"m[1][lidy-bheight] = x1.s0;\n"
"m[0][lidy-bheight] = x0.s0;\n"
"}\n"
"else if(lidy < bheight)\n"
"{\n"
"lm[9] = ((F)py) * sy;\n"
"lm[8] = ((F)x1.s0) * sy;\n"
"lm[7] = ((F)x2.s0) * lidy;\n"
"lm[6] = x3.s0;\n"
"lm[5] = x0.s0 * sy;\n"
"lm[4] = x1.s0 * lidy;\n"
"lm[3] = x2.s0;\n"
"lm[2] = py;\n"
"lm[1] = x1.s0;\n"
"lm[0] = x0.s0;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for( int j = TILE_SIZE/2; j >= 1; j = j/2 )\n"
"{\n"
"if(lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"lm[i] = lm[i] + m[i][lidy];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lidy >= j/2&&lidy < j)\n"
"for( int i = 0; i < 10; i++ )\n"
"m[i][lidy-j/2] = lm[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if(lidy == 0&&lidx == 0)\n"
"{\n"
"for( int mt = 0; mt < 10; mt++ )\n"
"mom[mt] = (F)lm[mt];\n"
"if(binary)\n"
"{\n"
"F s = 1./255;\n"
"for( int mt = 0; mt < 10; mt++ )\n"
"mom[mt] *= s;\n"
"}\n"
"F xm = x * mom[0], ym = y * mom[0];\n"
"dst_step /= sizeof(F);\n"
"*(dst_m + mad24(DST_ROW_00 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[0];\n"
"*(dst_m + mad24(DST_ROW_10 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[1] + xm;\n"
"*(dst_m + mad24(DST_ROW_01 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[2] + ym;\n"
"*(dst_m + mad24(DST_ROW_20 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[3] + x * (mom[1] * 2 + xm);\n"
"*(dst_m + mad24(DST_ROW_11 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[4] + x * (mom[2] + ym) + y * mom[1];\n"
"*(dst_m + mad24(DST_ROW_02 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[5] + y * (mom[2] * 2 + ym);\n"
"*(dst_m + mad24(DST_ROW_30 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[6] + x * (3. * mom[3] + x * (3. * mom[1] + xm));\n"
"*(dst_m + mad24(DST_ROW_21 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[7] + x * (2 * (mom[4] + y * mom[1]) + x * (mom[2] + ym)) + y * mom[3];\n"
"*(dst_m + mad24(DST_ROW_12 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[8] + y * (2 * (mom[4] + x * mom[2]) + y * (mom[1] + xm)) + x * mom[5];\n"
"*(dst_m + mad24(DST_ROW_03 * blocky, dst_step, mad24(wgidy, dst_cols, wgidx))) = mom[9] + y * (3. * mom[5] + y * (3. * mom[2] + ym));\n"
"}\n"
"}\n"
;
const char* objdetect_hog="#define CELL_WIDTH 8\n"
"#define CELL_HEIGHT 8\n"
"#define CELLS_PER_BLOCK_X 2\n"
"#define CELLS_PER_BLOCK_Y 2\n"
"#define NTHREADS 256\n"
"#define CV_PI_F 3.1415926535897932384626433832795f\n"
"__kernel void compute_hists_kernel(const int width, const int cblock_stride_x, const int cblock_stride_y,\n"
"const int cnbins, const int cblock_hist_size, const int img_block_width,\n"
"const int grad_quadstep, const int qangle_step,\n"
"__global const float* grad, __global const uchar* qangle,\n"
"const float scale, __global float* block_hists, __local float* smem)\n"
"{\n"
"const int lidX = get_local_id(0);\n"
"const int lidY = get_local_id(1);\n"
"const int gidX = get_group_id(0);\n"
"const int gidY = get_group_id(1);\n"
"const int cell_x = lidX / 16;\n"
"const int cell_y = lidY;\n"
"const int cell_thread_x = lidX & 0xF;\n"
"__local float* hists = smem;\n"
"__local float* final_hist = smem + cnbins * 48;\n"
"const int offset_x = gidX * cblock_stride_x + (cell_x << 2) + cell_thread_x;\n"
"const int offset_y = gidY * cblock_stride_y + (cell_y << 2);\n"
"__global const float* grad_ptr = grad + offset_y * grad_quadstep + (offset_x << 1);\n"
"__global const uchar* qangle_ptr = qangle + offset_y * qangle_step + (offset_x << 1);\n"
"if (cell_thread_x < 12)\n"
"{\n"
"__local float* hist = hists + 12 * (cell_y * CELLS_PER_BLOCK_Y + cell_x) + cell_thread_x;\n"
"for (int bin_id = 0; bin_id < cnbins; ++bin_id)\n"
"hist[bin_id * 48] = 0.f;\n"
"const int dist_x = -4 + cell_thread_x - 4 * cell_x;\n"
"const int dist_y_begin = -4 - 4 * lidY;\n"
"for (int dist_y = dist_y_begin; dist_y < dist_y_begin + 12; ++dist_y)\n"
"{\n"
"float2 vote = (float2) (grad_ptr[0], grad_ptr[1]);\n"
"uchar2 bin = (uchar2) (qangle_ptr[0], qangle_ptr[1]);\n"
"grad_ptr += grad_quadstep;\n"
"qangle_ptr += qangle_step;\n"
"int dist_center_y = dist_y - 4 * (1 - 2 * cell_y);\n"
"int dist_center_x = dist_x - 4 * (1 - 2 * cell_x);\n"
"float gaussian = exp(-(dist_center_y * dist_center_y + dist_center_x * dist_center_x) * scale);\n"
"float interp_weight = (8.f - fabs(dist_y + 0.5f)) * (8.f - fabs(dist_x + 0.5f)) / 64.f;\n"
"hist[bin.x * 48] += gaussian * interp_weight * vote.x;\n"
"hist[bin.y * 48] += gaussian * interp_weight * vote.y;\n"
"}\n"
"volatile __local float* hist_ = hist;\n"
"for (int bin_id = 0; bin_id < cnbins; ++bin_id, hist_ += 48)\n"
"{\n"
"if (cell_thread_x < 6) hist_[0] += hist_[6];\n"
"if (cell_thread_x < 3) hist_[0] += hist_[3];\n"
"if (cell_thread_x == 0)\n"
"final_hist[(cell_x * 2 + cell_y) * cnbins + bin_id] = hist_[0] + hist_[1] + hist_[2];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"__global float* block_hist = block_hists + (gidY * img_block_width + gidX) * cblock_hist_size;\n"
"int tid = (cell_y * CELLS_PER_BLOCK_Y + cell_x) * 16 + cell_thread_x;\n"
"if (tid < cblock_hist_size)\n"
"block_hist[tid] = final_hist[tid];\n"
"}\n"
"float reduce_smem(volatile __local float* smem, int size)\n"
"{\n"
"unsigned int tid = get_local_id(0);\n"
"float sum = smem[tid];\n"
"if (size >= 512) { if (tid < 256) smem[tid] = sum = sum + smem[tid + 256]; barrier(CLK_LOCAL_MEM_FENCE); }\n"
"if (size >= 256) { if (tid < 128) smem[tid] = sum = sum + smem[tid + 128]; barrier(CLK_LOCAL_MEM_FENCE); }\n"
"if (size >= 128) { if (tid < 64) smem[tid] = sum = sum + smem[tid + 64]; barrier(CLK_LOCAL_MEM_FENCE); }\n"
"if (tid < 32)\n"
"{\n"
"if (size >= 64) smem[tid] = sum = sum + smem[tid + 32];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"if (size >= 32) smem[tid] = sum = sum + smem[tid + 16];\n"
"if (size >= 16) smem[tid] = sum = sum + smem[tid + 8];\n"
"if (size >= 8) smem[tid] = sum = sum + smem[tid + 4];\n"
"if (size >= 4) smem[tid] = sum = sum + smem[tid + 2];\n"
"if (size >= 2) smem[tid] = sum = sum + smem[tid + 1];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = smem[0];\n"
"return sum;\n"
"}\n"
"__kernel void normalize_hists_kernel(const int nthreads, const int block_hist_size, const int img_block_width,\n"
"__global float* block_hists, const float threshold, __local float *squares)\n"
"{\n"
"const int tid = get_local_id(0);\n"
"const int gidX = get_group_id(0);\n"
"const int gidY = get_group_id(1);\n"
"__global float* hist = block_hists + (gidY * img_block_width + gidX) * block_hist_size + tid;\n"
"float elem = 0.f;\n"
"if (tid < block_hist_size)\n"
"elem = hist[0];\n"
"squares[tid] = elem * elem;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float sum = reduce_smem(squares, nthreads);\n"
"float scale = 1.0f / (sqrt(sum) + 0.1f * block_hist_size);\n"
"elem = min(elem * scale, threshold);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"squares[tid] = elem * elem;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = reduce_smem(squares, nthreads);\n"
"scale = 1.0f / (sqrt(sum) + 1e-3f);\n"
"if (tid < block_hist_size)\n"
"hist[0] = elem * scale;\n"
"}\n"
"__kernel void classify_hists_kernel(const int cblock_hist_size, const int cdescr_size, const int cdescr_width,\n"
"const int img_win_width, const int img_block_width,\n"
"const int win_block_stride_x, const int win_block_stride_y,\n"
"__global const float * block_hists, __global const float* coefs,\n"
"float free_coef, float threshold, __global uchar* labels)\n"
"{\n"
"const int tid = get_local_id(0);\n"
"const int gidX = get_group_id(0);\n"
"const int gidY = get_group_id(1);\n"
"__global const float* hist = block_hists + (gidY * win_block_stride_y * img_block_width + gidX * win_block_stride_x) * cblock_hist_size;\n"
"float product = 0.f;\n"
"for (int i = tid; i < cdescr_size; i += NTHREADS)\n"
"{\n"
"int offset_y = i / cdescr_width;\n"
"int offset_x = i - offset_y * cdescr_width;\n"
"product += coefs[i] * hist[offset_y * img_block_width * cblock_hist_size + offset_x];\n"
"}\n"
"__local float products[NTHREADS];\n"
"products[tid] = product;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 128) products[tid] = product = product + products[tid + 128];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 64) products[tid] = product = product + products[tid + 64];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 32)\n"
"{\n"
"volatile __local float* smem = products;\n"
"smem[tid] = product = product + smem[tid + 32];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"volatile __local float* smem = products;\n"
"smem[tid] = product = product + smem[tid + 16];\n"
"smem[tid] = product = product + smem[tid + 8];\n"
"smem[tid] = product = product + smem[tid + 4];\n"
"smem[tid] = product = product + smem[tid + 2];\n"
"smem[tid] = product = product + smem[tid + 1];\n"
"}\n"
"if (tid == 0)\n"
"labels[gidY * img_win_width + gidX] = (product + free_coef >= threshold);\n"
"}\n"
"__kernel void extract_descrs_by_rows_kernel(const int cblock_hist_size, const int descriptors_quadstep, const int cdescr_size, const int cdescr_width,\n"
"const int img_block_width, const int win_block_stride_x, const int win_block_stride_y,\n"
"__global const float* block_hists, __global float* descriptors)\n"
"{\n"
"int tid = get_local_id(0);\n"
"int gidX = get_group_id(0);\n"
"int gidY = get_group_id(1);\n"
"__global const float* hist = block_hists + (gidY * win_block_stride_y * img_block_width + gidX * win_block_stride_x) * cblock_hist_size;\n"
"__global float* descriptor = descriptors + (gidY * get_num_groups(0) + gidX) * descriptors_quadstep;\n"
"for (int i = tid; i < cdescr_size; i += NTHREADS)\n"
"{\n"
"int offset_y = i / cdescr_width;\n"
"int offset_x = i - offset_y * cdescr_width;\n"
"descriptor[i] = hist[offset_y * img_block_width * cblock_hist_size + offset_x];\n"
"}\n"
"}\n"
"__kernel void extract_descrs_by_cols_kernel(const int cblock_hist_size, const int descriptors_quadstep, const int cdescr_size,\n"
"const int cnblocks_win_x, const int cnblocks_win_y, const int img_block_width, const int win_block_stride_x,\n"
"const int win_block_stride_y, __global const float* block_hists, __global float* descriptors)\n"
"{\n"
"int tid = get_local_id(0);\n"
"int gidX = get_group_id(0);\n"
"int gidY = get_group_id(1);\n"
"__global const float* hist = block_hists + (gidY * win_block_stride_y * img_block_width + gidX * win_block_stride_x) * cblock_hist_size;\n"
"__global float* descriptor = descriptors + (gidY * get_num_groups(0) + gidX) * descriptors_quadstep;\n"
"for (int i = tid; i < cdescr_size; i += NTHREADS)\n"
"{\n"
"int block_idx = i / cblock_hist_size;\n"
"int idx_in_block = i - block_idx * cblock_hist_size;\n"
"int y = block_idx / cnblocks_win_x;\n"
"int x = block_idx - y * cnblocks_win_x;\n"
"descriptor[(x * cnblocks_win_y + y) * cblock_hist_size + idx_in_block] = hist[(y * img_block_width  + x) * cblock_hist_size + idx_in_block];\n"
"}\n"
"}\n"
"__kernel void compute_gradients_8UC4_kernel(const int height, const int width, const int img_step, const int grad_quadstep, const int qangle_step,\n"
"const __global uchar4 * img, __global float * grad, __global uchar * qangle,\n"
"const float angle_scale, const char correct_gamma, const int cnbins)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int tid = get_local_id(0);\n"
"const int gSizeX = get_local_size(0);\n"
"const int gidX = get_group_id(0);\n"
"const int gidY = get_group_id(1);\n"
"__global const uchar4* row = img + gidY * img_step;\n"
"__local float sh_row[(NTHREADS + 2) * 3];\n"
"uchar4 val;\n"
"if (x < width)\n"
"val = row[x];\n"
"else\n"
"val = row[width - 2];\n"
"sh_row[tid + 1] = val.x;\n"
"sh_row[tid + 1 + (NTHREADS + 2)] = val.y;\n"
"sh_row[tid + 1 + 2 * (NTHREADS + 2)] = val.z;\n"
"if (tid == 0)\n"
"{\n"
"val = row[max(x - 1, 1)];\n"
"sh_row[0] = val.x;\n"
"sh_row[(NTHREADS + 2)] = val.y;\n"
"sh_row[2 * (NTHREADS + 2)] = val.z;\n"
"}\n"
"if (tid == gSizeX - 1)\n"
"{\n"
"val = row[min(x + 1, width - 2)];\n"
"sh_row[gSizeX + 1] = val.x;\n"
"sh_row[gSizeX + 1 + (NTHREADS + 2)] = val.y;\n"
"sh_row[gSizeX + 1 + 2 * (NTHREADS + 2)] = val.z;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (x < width)\n"
"{\n"
"float3 a = (float3) (sh_row[tid], sh_row[tid + (NTHREADS + 2)], sh_row[tid + 2 * (NTHREADS + 2)]);\n"
"float3 b = (float3) (sh_row[tid + 2], sh_row[tid + 2 + (NTHREADS + 2)], sh_row[tid + 2 + 2 * (NTHREADS + 2)]);\n"
"float3 dx;\n"
"if (correct_gamma == 1)\n"
"dx = sqrt(b) - sqrt(a);\n"
"else\n"
"dx = b - a;\n"
"float3 dy = (float3) 0.f;\n"
"if (gidY > 0 && gidY < height - 1)\n"
"{\n"
"a = convert_float3(img[(gidY - 1) * img_step + x].xyz);\n"
"b = convert_float3(img[(gidY + 1) * img_step + x].xyz);\n"
"if (correct_gamma == 1)\n"
"dy = sqrt(b) - sqrt(a);\n"
"else\n"
"dy = b - a;\n"
"}\n"
"float best_dx = dx.x;\n"
"float best_dy = dy.x;\n"
"float mag0 = dx.x * dx.x + dy.x * dy.x;\n"
"float mag1 = dx.y * dx.y + dy.y * dy.y;\n"
"if (mag0 < mag1)\n"
"{\n"
"best_dx = dx.y;\n"
"best_dy = dy.y;\n"
"mag0 = mag1;\n"
"}\n"
"mag1 = dx.z * dx.z + dy.z * dy.z;\n"
"if (mag0 < mag1)\n"
"{\n"
"best_dx = dx.z;\n"
"best_dy = dy.z;\n"
"mag0 = mag1;\n"
"}\n"
"mag0 = sqrt(mag0);\n"
"float ang = (atan2(best_dy, best_dx) + CV_PI_F) * angle_scale - 0.5f;\n"
"int hidx = (int)floor(ang);\n"
"ang -= hidx;\n"
"hidx = (hidx + cnbins) % cnbins;\n"
"qangle[(gidY * qangle_step + x) << 1] = hidx;\n"
"qangle[((gidY * qangle_step + x) << 1) + 1] = (hidx + 1) % cnbins;\n"
"grad[(gidY * grad_quadstep + x) << 1] = mag0 * (1.f - ang);\n"
"grad[((gidY * grad_quadstep + x) << 1) + 1] = mag0 * ang;\n"
"}\n"
"}\n"
"__kernel void compute_gradients_8UC1_kernel(const int height, const int width, const int img_step, const int grad_quadstep, const int qangle_step,\n"
"__global const uchar * img, __global float * grad, __global uchar * qangle,\n"
"const float angle_scale, const char correct_gamma, const int cnbins)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int tid = get_local_id(0);\n"
"const int gSizeX = get_local_size(0);\n"
"const int gidX = get_group_id(0);\n"
"const int gidY = get_group_id(1);\n"
"__global const uchar* row = img + gidY * img_step;\n"
"__local float sh_row[NTHREADS + 2];\n"
"if (x < width)\n"
"sh_row[tid + 1] = row[x];\n"
"else\n"
"sh_row[tid + 1] = row[width - 2];\n"
"if (tid == 0)\n"
"sh_row[0] = row[max(x - 1, 1)];\n"
"if (tid == gSizeX - 1)\n"
"sh_row[gSizeX + 1] = row[min(x + 1, width - 2)];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (x < width)\n"
"{\n"
"float dx;\n"
"if (correct_gamma == 1)\n"
"dx = sqrt(sh_row[tid + 2]) - sqrt(sh_row[tid]);\n"
"else\n"
"dx = sh_row[tid + 2] - sh_row[tid];\n"
"float dy = 0.f;\n"
"if (gidY > 0 && gidY < height - 1)\n"
"{\n"
"float a = (float) img[ (gidY + 1) * img_step + x ];\n"
"float b = (float) img[ (gidY - 1) * img_step + x ];\n"
"if (correct_gamma == 1)\n"
"dy = sqrt(a) - sqrt(b);\n"
"else\n"
"dy = a - b;\n"
"}\n"
"float mag = sqrt(dx * dx + dy * dy);\n"
"float ang = (atan2(dy, dx) + CV_PI_F) * angle_scale - 0.5f;\n"
"int hidx = (int)floor(ang);\n"
"ang -= hidx;\n"
"hidx = (hidx + cnbins) % cnbins;\n"
"qangle[ (gidY * qangle_step + x) << 1 ]     = hidx;\n"
"qangle[ ((gidY * qangle_step + x) << 1) + 1 ] = (hidx + 1) % cnbins;\n"
"grad[ (gidY * grad_quadstep + x) << 1 ]       = mag * (1.f - ang);\n"
"grad[ ((gidY * grad_quadstep + x) << 1) + 1 ]   = mag * ang;\n"
"}\n"
"}\n"
"__kernel void resize_8UC4_kernel(__global uchar4 * dst, __global const uchar4 * src,\n"
"int dst_offset, int src_offset, int dst_step, int src_step,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"int sx = (int)floor(dx*ifx+0.5f);\n"
"int sy = (int)floor(dy*ify+0.5f);\n"
"sx = min(sx, src_cols-1);\n"
"sy = min(sy, src_rows-1);\n"
"int dpos = (dst_offset>>2) + dy * (dst_step>>2) + dx;\n"
"int spos = (src_offset>>2) + sy * (src_step>>2) + sx;\n"
"if(dx<dst_cols && dy<dst_rows)\n"
"dst[dpos] = src[spos];\n"
"}\n"
"__kernel void resize_8UC1_kernel(__global uchar * dst, __global const uchar * src,\n"
"int dst_offset, int src_offset, int dst_step, int src_step,\n"
"int src_cols, int src_rows, int dst_cols, int dst_rows, float ifx, float ify )\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"int sx = (int)floor(dx*ifx+0.5f);\n"
"int sy = (int)floor(dy*ify+0.5f);\n"
"sx = min(sx, src_cols-1);\n"
"sy = min(sy, src_rows-1);\n"
"int dpos = dst_offset + dy * dst_step + dx;\n"
"int spos = src_offset + sy * src_step + sx;\n"
"if(dx<dst_cols && dy<dst_rows)\n"
"dst[dpos] = src[spos];\n"
"}\n"
;
const char* operator_convertTo="#define F float\n"
"#define F2 float2\n"
"#define F4 float4\n"
"__kernel void convert_to_S4_C1_D0(\n"
"__global const int* restrict srcMat,\n"
"__global uchar* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0)<<2;\n"
"int y=get_global_id(1);\n"
"int off_src = (dstoffset_in_pixel & 3);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel - off_src);\n"
"int dst_addr_start = mad24(y,dstStep_in_pixel,dstoffset_in_pixel);\n"
"int dst_addr_end = mad24(y,dstStep_in_pixel,cols+dstoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel & (int)0xfffffffc);\n"
"if(x+3<cols && y<rows && off_src==0)\n"
"{\n"
"float4 temp_src = convert_float4(vload4(0,srcMat+srcidx));\n"
"*(__global uchar4*)(dstMat+dstidx) = convert_uchar4_sat(temp_src*(F4)alpha+(F4)beta);\n"
"}\n"
"else\n"
"{\n"
"if(x+3<cols && y<rows)\n"
"{\n"
"float4 temp_src = convert_float4(vload4(0,srcMat+srcidx));\n"
"uchar4 temp_dst = convert_uchar4_sat(temp_src*(F4)alpha+(F4)beta);\n"
"dstMat[dstidx] = temp_dst.x;\n"
"dstMat[dstidx+1] = temp_dst.y;\n"
"dstMat[dstidx+2] = temp_dst.z;\n"
"dstMat[dstidx+3] = temp_dst.w;\n"
"}\n"
"else if(x+2<cols && y<rows)\n"
"{\n"
"float4 temp_src = convert_float4(vload4(0,srcMat+srcidx));\n"
"uchar4 temp_dst = convert_uchar4_sat(temp_src*(F4)alpha+(F4)beta);\n"
"dstMat[dstidx] = temp_dst.x;\n"
"dstMat[dstidx+1] = temp_dst.y;\n"
"dstMat[dstidx+2] = temp_dst.z;\n"
"}\n"
"else if(x+1<cols && y<rows)\n"
"{\n"
"float2 temp_src = convert_float2(vload2(0,srcMat+srcidx));\n"
"uchar2 temp_dst = convert_uchar2_sat(temp_src*(F2)alpha+(F2)beta);\n"
"dstMat[dstidx] = temp_dst.x;\n"
"dstMat[dstidx+1] = temp_dst.y;\n"
"}\n"
"else if(x<cols && y<rows)\n"
"{\n"
"dstMat[dstidx] = convert_uchar_sat(convert_float(srcMat[srcidx])*alpha+beta);;\n"
"}\n"
"}\n"
"}\n"
"__kernel void convert_to_S4_C4_D0(\n"
"__global const int4* restrict srcMat,\n"
"__global uchar4* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float4 temp_src = convert_float4(srcMat[srcidx]);\n"
"dstMat[dstidx] = convert_uchar4_sat(temp_src*alpha+beta);\n"
"}\n"
"}\n"
"__kernel void convert_to_S5_C1_D0(\n"
"__global const float* restrict srcMat,\n"
"__global uchar* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0)<<2;\n"
"int y=get_global_id(1);\n"
"int off_src = (dstoffset_in_pixel & 3);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel - off_src);\n"
"int dst_addr_start = mad24(y,dstStep_in_pixel,dstoffset_in_pixel);\n"
"int dst_addr_end = mad24(y,dstStep_in_pixel,cols+dstoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel & (int)0xfffffffc);\n"
"if(x+3<cols && y<rows && off_src==0)\n"
"{\n"
"float4 temp_src = vload4(0,srcMat+srcidx);\n"
"*(__global uchar4*)(dstMat+dstidx) = convert_uchar4_sat(temp_src*(F4)alpha+(F4)beta);\n"
"}\n"
"else\n"
"{\n"
"if(x+3<cols && y<rows)\n"
"{\n"
"float4 temp_src = vload4(0,srcMat+srcidx);\n"
"uchar4 temp_dst = convert_uchar4_sat(temp_src*(F4)alpha+(F4)beta);\n"
"dstMat[dstidx] = temp_dst.x;\n"
"dstMat[dstidx+1] = temp_dst.y;\n"
"dstMat[dstidx+2] = temp_dst.z;\n"
"dstMat[dstidx+3] = temp_dst.w;\n"
"}\n"
"else if(x+2<cols && y<rows)\n"
"{\n"
"float4 temp_src = vload4(0,srcMat+srcidx);\n"
"uchar4 temp_dst = convert_uchar4_sat(temp_src*(F4)alpha+(F4)beta);\n"
"dstMat[dstidx] = temp_dst.x;\n"
"dstMat[dstidx+1] = temp_dst.y;\n"
"dstMat[dstidx+2] = temp_dst.z;\n"
"}\n"
"else if(x+1<cols && y<rows)\n"
"{\n"
"float2 temp_src = vload2(0,srcMat+srcidx);\n"
"uchar2 temp_dst = convert_uchar2_sat(temp_src*(F2)alpha+(F2)beta);\n"
"dstMat[dstidx] = temp_dst.x;\n"
"dstMat[dstidx+1] = temp_dst.y;\n"
"}\n"
"else if(x<cols && y<rows)\n"
"{\n"
"dstMat[dstidx] = convert_uchar_sat(srcMat[srcidx]*alpha+beta);;\n"
"}\n"
"}\n"
"}\n"
"__kernel void convert_to_S5_C4_D0(\n"
"__global const float4* restrict srcMat,\n"
"__global uchar4* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float4 temp_src = srcMat[srcidx];\n"
"dstMat[dstidx] = convert_uchar4_sat(temp_src*alpha+beta);\n"
"}\n"
"}\n"
"__kernel void convert_to_S0_C1_D4(\n"
"__global const uchar* restrict srcMat,\n"
"__global int* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float temp_src = convert_float(srcMat[srcidx]);\n"
"dstMat[dstidx] = convert_int_sat(temp_src*alpha+beta);\n"
"}\n"
"}\n"
"__kernel void convert_to_S5_C1_D4(\n"
"__global const float* restrict srcMat,\n"
"__global int* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float temp_src = srcMat[srcidx];\n"
"dstMat[dstidx] = convert_int_sat(temp_src*alpha+beta);\n"
"}\n"
"}\n"
"__kernel void convert_to_S0_C4_D4(\n"
"__global const uchar4* restrict srcMat,\n"
"__global int4* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float4 temp_src = convert_float4(srcMat[srcidx]);\n"
"dstMat[dstidx] = convert_int4_sat(temp_src*alpha+beta);\n"
"}\n"
"}\n"
"__kernel void convert_to_S5_C4_D4(\n"
"__global const float4* restrict srcMat,\n"
"__global int4* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float4 temp_src = srcMat[srcidx];\n"
"dstMat[dstidx] = convert_int4_sat(temp_src*alpha+beta);\n"
"}\n"
"}\n"
"__kernel void convert_to_S0_C1_D5(\n"
"__global const uchar* restrict srcMat,\n"
"__global float* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float temp_src = convert_float(srcMat[srcidx]);\n"
"dstMat[dstidx] = temp_src*alpha+beta;\n"
"}\n"
"}\n"
"__kernel void convert_to_S4_C1_D5(\n"
"__global const int* restrict srcMat,\n"
"__global float* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float temp_src = convert_float(srcMat[srcidx]);\n"
"dstMat[dstidx] = temp_src*alpha+beta;\n"
"}\n"
"}\n"
"__kernel void convert_to_S0_C4_D5(\n"
"__global const uchar4* restrict srcMat,\n"
"__global float4* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float4 temp_src = convert_float4(srcMat[srcidx]);\n"
"dstMat[dstidx] = temp_src*alpha+beta;\n"
"}\n"
"}\n"
"__kernel void convert_to_S4_C4_D5(\n"
"__global const int4* restrict srcMat,\n"
"__global float4* dstMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"F alpha,\n"
"F beta)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"if ( (x < cols) & (y < rows) )\n"
"{\n"
"float4 temp_src = convert_float4(srcMat[srcidx]);\n"
"dstMat[dstidx] = temp_src*alpha+beta;\n"
"}\n"
"}\n"
;
const char* operator_copyToM="__kernel void copy_to_with_mask(\n"
"__global const GENTYPE* restrict srcMat,\n"
"__global GENTYPE* dstMat,\n"
"__global const uchar* restrict maskMat,\n"
"int cols,\n"
"int rows,\n"
"int srcStep_in_pixel,\n"
"int srcoffset_in_pixel,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"int maskStep,\n"
"int maskoffset)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"x = x< cols ? x: cols-1;\n"
"y = y< rows ? y: rows-1;\n"
"int srcidx = mad24(y,srcStep_in_pixel,x+ srcoffset_in_pixel);\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"int maskidx = mad24(y,maskStep,x+ maskoffset);\n"
"uchar mask = maskMat[maskidx];\n"
"if (mask)\n"
"{\n"
"dstMat[dstidx] = srcMat[srcidx];\n"
"}\n"
"}\n"
;
const char* operator_setTo="__kernel void set_to_without_mask_C1_D0(uchar scalar,__global uchar * dstMat,\n"
"int cols,int rows,int dstStep_in_pixel,int offset_in_pixel)\n"
"{\n"
"int x=get_global_id(0)<<2;\n"
"int y=get_global_id(1);\n"
"int idx = mad24(y,dstStep_in_pixel,x+ offset_in_pixel);\n"
"uchar4 out;\n"
"out.x = out.y = out.z = out.w = scalar;\n"
"if ( (x+3 < cols) && (y < rows)&& ((offset_in_pixel&3) == 0))\n"
"{\n"
"*(__global uchar4*)(dstMat+idx) = out;\n"
"}\n"
"else\n"
"{\n"
"if((x+3 < cols) && (y < rows))\n"
"{\n"
"dstMat[idx] = out.x;\n"
"dstMat[idx+1] = out.y;\n"
"dstMat[idx+2] = out.z;\n"
"dstMat[idx+3] = out.w;\n"
"}\n"
"if((x+2 < cols) && (y < rows))\n"
"{\n"
"dstMat[idx] = out.x;\n"
"dstMat[idx+1] = out.y;\n"
"dstMat[idx+2] = out.z;\n"
"}\n"
"else if((x+1 < cols) && (y < rows))\n"
"{\n"
"dstMat[idx] = out.x;\n"
"dstMat[idx+1] = out.y;\n"
"}\n"
"else if((x < cols) && (y < rows))\n"
"{\n"
"dstMat[idx] = out.x;\n"
"}\n"
"}\n"
"}\n"
"__kernel void set_to_without_mask(GENTYPE scalar,__global GENTYPE * dstMat,\n"
"int cols,int rows,int dstStep_in_pixel,int offset_in_pixel)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"if ( (x < cols) & (y < rows))\n"
"{\n"
"int idx = mad24(y,dstStep_in_pixel,x+ offset_in_pixel);\n"
"dstMat[idx] = scalar;\n"
"}\n"
"}\n"
;
const char* operator_setToM="__kernel void set_to_with_mask(\n"
"GENTYPE scalar,\n"
"__global GENTYPE * dstMat,\n"
"int cols,\n"
"int rows,\n"
"int dstStep_in_pixel,\n"
"int dstoffset_in_pixel,\n"
"__global const uchar * restrict maskMat,\n"
"int maskStep,\n"
"int maskoffset)\n"
"{\n"
"int x=get_global_id(0);\n"
"int y=get_global_id(1);\n"
"x = x< cols ? x: cols-1;\n"
"y = y< rows ? y: rows-1;\n"
"int dstidx = mad24(y,dstStep_in_pixel,x+ dstoffset_in_pixel);\n"
"int maskidx = mad24(y,maskStep,x+ maskoffset);\n"
"uchar mask = maskMat[maskidx];\n"
"if (mask)\n"
"{\n"
"dstMat[dstidx] = scalar;\n"
"}\n"
"}\n"
;
const char* pyr_down="uchar round_uchar_int(int v)\n"
"{\n"
"return (uchar)((uint)v <= 255 ? v : v > 0 ? 255 : 0);\n"
"}\n"
"uchar round_uchar_float(float v)\n"
"{\n"
"return round_uchar_int(convert_int_sat_rte(v));\n"
"}\n"
"uchar4 round_uchar4_int4(int4 v)\n"
"{\n"
"uchar4 result;\n"
"result.x = (uchar)(v.x <= 255 ? v.x : v.x > 0 ? 255 : 0);\n"
"result.y = (uchar)(v.y <= 255 ? v.y : v.y > 0 ? 255 : 0);\n"
"result.z = (uchar)(v.z <= 255 ? v.z : v.z > 0 ? 255 : 0);\n"
"result.w = (uchar)(v.w <= 255 ? v.w : v.w > 0 ? 255 : 0);\n"
"return result;\n"
"}\n"
"uchar4 round_uchar4_float4(float4 v)\n"
"{\n"
"return round_uchar4_int4(convert_int4_sat_rte(v));\n"
"}\n"
"int idx_row_low(int y, int last_row)\n"
"{\n"
"return abs(y) % (last_row + 1);\n"
"}\n"
"int idx_row_high(int y, int last_row)\n"
"{\n"
"return abs(last_row - (int)abs(last_row - y)) % (last_row + 1);\n"
"}\n"
"int idx_row(int y, int last_row)\n"
"{\n"
"return idx_row_low(idx_row_high(y, last_row), last_row);\n"
"}\n"
"int idx_col_low(int x, int last_col)\n"
"{\n"
"return abs(x) % (last_col + 1);\n"
"}\n"
"int idx_col_high(int x, int last_col)\n"
"{\n"
"return abs(last_col - (int)abs(last_col - x)) % (last_col + 1);\n"
"}\n"
"int idx_col(int x, int last_col)\n"
"{\n"
"return idx_col_low(idx_col_high(x, last_col), last_col);\n"
"}\n"
"__kernel void pyrDown_C1_D0(__global uchar * srcData, int srcStep, int srcRows, int srcCols, __global uchar *dst, int dstStep, int dstCols)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_group_id(1);\n"
"__local float smem[256 + 4];\n"
"float sum;\n"
"const int src_y = 2*y;\n"
"const int last_row = srcRows - 1;\n"
"const int last_col = srcCols - 1;\n"
"if (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n"
"{\n"
"sum =       0.0625f * (((srcData + (src_y - 2) * srcStep))[x]);\n"
"sum = sum + 0.25f   * (((srcData + (src_y - 1) * srcStep))[x]);\n"
"sum = sum + 0.375f  * (((srcData + (src_y    ) * srcStep))[x]);\n"
"sum = sum + 0.25f   * (((srcData + (src_y + 1) * srcStep))[x]);\n"
"sum = sum + 0.0625f * (((srcData + (src_y + 2) * srcStep))[x]);\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"sum =       0.0625f * (((srcData + (src_y - 2) * srcStep))[left_x]);\n"
"sum = sum + 0.25f   * (((srcData + (src_y - 1) * srcStep))[left_x]);\n"
"sum = sum + 0.375f  * (((srcData + (src_y    ) * srcStep))[left_x]);\n"
"sum = sum + 0.25f   * (((srcData + (src_y + 1) * srcStep))[left_x]);\n"
"sum = sum + 0.0625f * (((srcData + (src_y + 2) * srcStep))[left_x]);\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"sum =       0.0625f * (((srcData + (src_y - 2) * srcStep))[right_x]);\n"
"sum = sum + 0.25f   * (((srcData + (src_y - 1) * srcStep))[right_x]);\n"
"sum = sum + 0.375f  * (((srcData + (src_y    ) * srcStep))[right_x]);\n"
"sum = sum + 0.25f   * (((srcData + (src_y + 1) * srcStep))[right_x]);\n"
"sum = sum + 0.0625f * (((srcData + (src_y + 2) * srcStep))[right_x]);\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"else\n"
"{\n"
"int col = idx_col(x, last_col);\n"
"sum =       0.0625f * (((srcData + idx_row(src_y - 2, last_row) * srcStep))[col]);\n"
"sum = sum + 0.25f   * (((srcData + idx_row(src_y - 1, last_row) * srcStep))[col]);\n"
"sum = sum + 0.375f  * (((srcData + idx_row(src_y    , last_row) * srcStep))[col]);\n"
"sum = sum + 0.25f   * (((srcData + idx_row(src_y + 1, last_row) * srcStep))[col]);\n"
"sum = sum + 0.0625f * (((srcData + idx_row(src_y + 2, last_row) * srcStep))[col]);\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"col = idx_col(left_x, last_col);\n"
"sum =       0.0625f * (((srcData + idx_row(src_y - 2, last_row) * srcStep))[col]);\n"
"sum = sum + 0.25f   * (((srcData + idx_row(src_y - 1, last_row) * srcStep))[col]);\n"
"sum = sum + 0.375f  * (((srcData + idx_row(src_y    , last_row) * srcStep))[col]);\n"
"sum = sum + 0.25f   * (((srcData + idx_row(src_y + 1, last_row) * srcStep))[col]);\n"
"sum = sum + 0.0625f * (((srcData + idx_row(src_y + 2, last_row) * srcStep))[col]);\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"col = idx_col(right_x, last_col);\n"
"sum =       0.0625f * (((srcData + idx_row(src_y - 2, last_row) * srcStep))[col]);\n"
"sum = sum + 0.25f   * (((srcData + idx_row(src_y - 1, last_row) * srcStep))[col]);\n"
"sum = sum + 0.375f  * (((srcData + idx_row(src_y    , last_row) * srcStep))[col]);\n"
"sum = sum + 0.25f   * (((srcData + idx_row(src_y + 1, last_row) * srcStep))[col]);\n"
"sum = sum + 0.0625f * (((srcData + idx_row(src_y + 2, last_row) * srcStep))[col]);\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(0) < 128)\n"
"{\n"
"const int tid2 = get_local_id(0) * 2;\n"
"sum =       0.0625f * smem[2 + tid2 - 2];\n"
"sum = sum + 0.25f   * smem[2 + tid2 - 1];\n"
"sum = sum + 0.375f  * smem[2 + tid2    ];\n"
"sum = sum + 0.25f   * smem[2 + tid2 + 1];\n"
"sum = sum + 0.0625f * smem[2 + tid2 + 2];\n"
"const int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\n"
"if (dst_x < dstCols)\n"
"dst[y * dstStep + dst_x] = round_uchar_float(sum);\n"
"}\n"
"}\n"
"__kernel void pyrDown_C4_D0(__global uchar4 * srcData, int srcStep, int srcRows, int srcCols, __global uchar4 *dst, int dstStep, int dstCols)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_group_id(1);\n"
"__local float4 smem[256 + 4];\n"
"float4 sum;\n"
"const int src_y = 2*y;\n"
"const int last_row = srcRows - 1;\n"
"const int last_col = srcCols - 1;\n"
"float4 co1 = 0.375f;\n"
"float4 co2 = 0.25f;\n"
"float4 co3 = 0.0625f;\n"
"if (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n"
"{\n"
"sum =       co3 * convert_float4((((srcData + (src_y - 2) * srcStep / 4))[x]));\n"
"sum = sum + co2   * convert_float4((((srcData + (src_y - 1) * srcStep / 4))[x]));\n"
"sum = sum + co1  * convert_float4((((srcData + (src_y    ) * srcStep / 4))[x]));\n"
"sum = sum + co2   * convert_float4((((srcData + (src_y + 1) * srcStep / 4))[x]));\n"
"sum = sum + co3 * convert_float4((((srcData + (src_y + 2) * srcStep / 4))[x]));\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"sum =       co3 * convert_float4((((srcData + (src_y - 2) * srcStep / 4))[left_x]));\n"
"sum = sum + co2   * convert_float4((((srcData + (src_y - 1) * srcStep / 4))[left_x]));\n"
"sum = sum + co1  * convert_float4((((srcData + (src_y    ) * srcStep / 4))[left_x]));\n"
"sum = sum + co2   * convert_float4((((srcData + (src_y + 1) * srcStep / 4))[left_x]));\n"
"sum = sum + co3 * convert_float4((((srcData + (src_y + 2) * srcStep / 4))[left_x]));\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"sum =       co3 * convert_float4((((srcData + (src_y - 2) * srcStep / 4))[right_x]));\n"
"sum = sum + co2   * convert_float4((((srcData + (src_y - 1) * srcStep / 4))[right_x]));\n"
"sum = sum + co1  * convert_float4((((srcData + (src_y    ) * srcStep / 4))[right_x]));\n"
"sum = sum + co2   * convert_float4((((srcData + (src_y + 1) * srcStep / 4))[right_x]));\n"
"sum = sum + co3 * convert_float4((((srcData + (src_y + 2) * srcStep / 4))[right_x]));\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"else\n"
"{\n"
"int col = idx_col(x, last_col);\n"
"sum =       co3 * convert_float4((((srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]));\n"
"sum = sum + co2   * convert_float4((((srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]));\n"
"sum = sum + co1  * convert_float4((((srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]));\n"
"sum = sum + co2   * convert_float4((((srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]));\n"
"sum = sum + co3 * convert_float4((((srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]));\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"col = idx_col(left_x, last_col);\n"
"sum =       co3 * convert_float4((((srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]));\n"
"sum = sum + co2   * convert_float4((((srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]));\n"
"sum = sum + co1  * convert_float4((((srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]));\n"
"sum = sum + co2   * convert_float4((((srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]));\n"
"sum = sum + co3 * convert_float4((((srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]));\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"col = idx_col(right_x, last_col);\n"
"sum =       co3 * convert_float4((((srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col]));\n"
"sum = sum + co2   * convert_float4((((srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col]));\n"
"sum = sum + co1  * convert_float4((((srcData + idx_row(src_y    , last_row) * srcStep / 4))[col]));\n"
"sum = sum + co2   * convert_float4((((srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col]));\n"
"sum = sum + co3 * convert_float4((((srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col]));\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(0) < 128)\n"
"{\n"
"const int tid2 = get_local_id(0) * 2;\n"
"sum =       co3 * smem[2 + tid2 - 2];\n"
"sum = sum + co2   * smem[2 + tid2 - 1];\n"
"sum = sum + co1  * smem[2 + tid2    ];\n"
"sum = sum + co2   * smem[2 + tid2 + 1];\n"
"sum = sum + co3 * smem[2 + tid2 + 2];\n"
"const int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\n"
"if (dst_x < dstCols)\n"
"dst[y * dstStep / 4 + dst_x] = round_uchar4_float4(sum);\n"
"}\n"
"}\n"
"__kernel void pyrDown_C1_D5(__global float * srcData, int srcStep, int srcRows, int srcCols, __global float *dst, int dstStep, int dstCols)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_group_id(1);\n"
"__local float smem[256 + 4];\n"
"float sum;\n"
"const int src_y = 2*y;\n"
"const int last_row = srcRows - 1;\n"
"const int last_col = srcCols - 1;\n"
"if (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n"
"{\n"
"sum =       0.0625f * ((__global float*)((__global char*)srcData + (src_y - 2) * srcStep))[x];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y - 1) * srcStep))[x];\n"
"sum = sum + 0.375f  * ((__global float*)((__global char*)srcData + (src_y    ) * srcStep))[x];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y + 1) * srcStep))[x];\n"
"sum = sum + 0.0625f * ((__global float*)((__global char*)srcData + (src_y + 2) * srcStep))[x];\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"sum =       0.0625f * ((__global float*)((__global char*)srcData + (src_y - 2) * srcStep))[left_x];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y - 1) * srcStep))[left_x];\n"
"sum = sum + 0.375f  * ((__global float*)((__global char*)srcData + (src_y    ) * srcStep))[left_x];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y + 1) * srcStep))[left_x];\n"
"sum = sum + 0.0625f * ((__global float*)((__global char*)srcData + (src_y + 2) * srcStep))[left_x];\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"sum =       0.0625f * ((__global float*)((__global char*)srcData + (src_y - 2) * srcStep))[right_x];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y - 1) * srcStep))[right_x];\n"
"sum = sum + 0.375f  * ((__global float*)((__global char*)srcData + (src_y    ) * srcStep))[right_x];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + (src_y + 1) * srcStep))[right_x];\n"
"sum = sum + 0.0625f * ((__global float*)((__global char*)srcData + (src_y + 2) * srcStep))[right_x];\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"else\n"
"{\n"
"int col = idx_col(x, last_col);\n"
"sum =       0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\n"
"sum = sum + 0.375f  * ((__global float*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\n"
"sum = sum + 0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"col = idx_col(left_x, last_col);\n"
"sum =       0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\n"
"sum = sum + 0.375f  * ((__global float*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\n"
"sum = sum + 0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"col = idx_col(right_x, last_col);\n"
"sum =       0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y - 2, last_row) * srcStep))[col];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y - 1, last_row) * srcStep))[col];\n"
"sum = sum + 0.375f  * ((__global float*)((__global char*)srcData + idx_row(src_y    , last_row) * srcStep))[col];\n"
"sum = sum + 0.25f   * ((__global float*)((__global char*)srcData + idx_row(src_y + 1, last_row) * srcStep))[col];\n"
"sum = sum + 0.0625f * ((__global float*)((__global char*)srcData + idx_row(src_y + 2, last_row) * srcStep))[col];\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(0) < 128)\n"
"{\n"
"const int tid2 = get_local_id(0) * 2;\n"
"sum =       0.0625f * smem[2 + tid2 - 2];\n"
"sum = sum + 0.25f   * smem[2 + tid2 - 1];\n"
"sum = sum + 0.375f  * smem[2 + tid2    ];\n"
"sum = sum + 0.25f   * smem[2 + tid2 + 1];\n"
"sum = sum + 0.0625f * smem[2 + tid2 + 2];\n"
"const int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\n"
"if (dst_x < dstCols)\n"
"dst[y * dstStep / 4 + dst_x] = sum;\n"
"}\n"
"}\n"
"__kernel void pyrDown_C4_D5(__global float4 * srcData, int srcStep, int srcRows, int srcCols, __global float4 *dst, int dstStep, int dstCols)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_group_id(1);\n"
"__local float4 smem[256 + 4];\n"
"float4 sum;\n"
"const int src_y = 2*y;\n"
"const int last_row = srcRows - 1;\n"
"const int last_col = srcCols - 1;\n"
"float4 co1 = 0.375f;\n"
"float4 co2 = 0.25f;\n"
"float4 co3 = 0.0625f;\n"
"if (src_y >= 2 && src_y < srcRows - 2 && x >= 2 && x < srcCols - 2)\n"
"{\n"
"sum =       co3 * ((__global float4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[x];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[x];\n"
"sum = sum + co1  * ((__global float4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[x];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[x];\n"
"sum = sum + co3 * ((__global float4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[x];\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"sum =       co3 * ((__global float4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[left_x];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[left_x];\n"
"sum = sum + co1  * ((__global float4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[left_x];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[left_x];\n"
"sum = sum + co3 * ((__global float4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[left_x];\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"sum =       co3 * ((__global float4*)((__global char4*)srcData + (src_y - 2) * srcStep / 4))[right_x];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + (src_y - 1) * srcStep / 4))[right_x];\n"
"sum = sum + co1  * ((__global float4*)((__global char4*)srcData + (src_y    ) * srcStep / 4))[right_x];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + (src_y + 1) * srcStep / 4))[right_x];\n"
"sum = sum + co3 * ((__global float4*)((__global char4*)srcData + (src_y + 2) * srcStep / 4))[right_x];\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"else\n"
"{\n"
"int col = idx_col(x, last_col);\n"
"sum =       co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col];\n"
"sum = sum + co1  * ((__global float4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col];\n"
"sum = sum + co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col];\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"col = idx_col(left_x, last_col);\n"
"sum =       co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col];\n"
"sum = sum + co1  * ((__global float4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col];\n"
"sum = sum + co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col];\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"col = idx_col(right_x, last_col);\n"
"sum =       co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 2, last_row) * srcStep / 4))[col];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + idx_row(src_y - 1, last_row) * srcStep / 4))[col];\n"
"sum = sum + co1  * ((__global float4*)((__global char4*)srcData + idx_row(src_y    , last_row) * srcStep / 4))[col];\n"
"sum = sum + co2   * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 1, last_row) * srcStep / 4))[col];\n"
"sum = sum + co3 * ((__global float4*)((__global char4*)srcData + idx_row(src_y + 2, last_row) * srcStep / 4))[col];\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(0) < 128)\n"
"{\n"
"const int tid2 = get_local_id(0) * 2;\n"
"sum =       co3 * smem[2 + tid2 - 2];\n"
"sum = sum + co2   * smem[2 + tid2 - 1];\n"
"sum = sum + co1  * smem[2 + tid2    ];\n"
"sum = sum + co2   * smem[2 + tid2 + 1];\n"
"sum = sum + co3 * smem[2 + tid2 + 2];\n"
"const int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\n"
"if (dst_x < dstCols)\n"
"dst[y * dstStep / 16 + dst_x] = sum;\n"
"}\n"
"}\n"
;
const char* pyr_up="uchar get_valid_uchar(uchar data)\n"
"{\n"
"return (uchar)(data <= 255 ? data : data > 0 ? 255 : 0);\n"
"}\n"
"__kernel void pyrUp_C1_D0(__global uchar* src,__global uchar* dst,\n"
"int srcRows,int dstRows,int srcCols,int dstCols,\n"
"int srcOffset,int dstOffset,int srcStep,int dstStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"__local float s_srcPatch[10][10];\n"
"__local float s_dstPatch[20][16];\n"
"const int tidx = get_local_id(0);\n"
"const int tidy = get_local_id(1);\n"
"const int lsizex = get_local_size(0);\n"
"const int lsizey = get_local_size(1);\n"
"if( tidx < 10 && tidy < 10 )\n"
"{\n"
"int srcx = mad24((int)get_group_id(0), (lsizex>>1), tidx) - 1;\n"
"int srcy = mad24((int)get_group_id(1), (lsizey>>1), tidy) - 1;\n"
"srcx = abs(srcx);\n"
"srcx = min(srcCols - 1,srcx);\n"
"srcy = abs(srcy);\n"
"srcy = min(srcRows -1 ,srcy);\n"
"s_srcPatch[tidy][tidx] = (float)(src[srcx + srcy * srcStep]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float sum = 0;\n"
"const int evenFlag = (int)((tidx & 1) == 0);\n"
"const int oddFlag = (int)((tidx & 1) != 0);\n"
"const bool  eveny = ((tidy & 1) == 0);\n"
"if(eveny)\n"
"{\n"
"sum = (evenFlag * 0.0625f) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.375f ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[2 + get_local_id(1)][get_local_id(0)] = sum;\n"
"if (get_local_id(1) < 2)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = (evenFlag * 0.0625f) * s_srcPatch[lsizey - 16][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[lsizey - 16][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.375f ) * s_srcPatch[lsizey - 16][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[lsizey - 16][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[lsizey - 16][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[get_local_id(1)][get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(1) > 13)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = (evenFlag * 0.0625f) * s_srcPatch[lsizey - 7][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[lsizey - 7][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.375f ) * s_srcPatch[lsizey - 7][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[lsizey - 7][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[9][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[4 + tidy][tidx] = sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = 0;\n"
"sum = 0.0625f * s_dstPatch[2 + tidy - 2][tidx];\n"
"sum = sum + 0.25f   * s_dstPatch[2 + tidy - 1][tidx];\n"
"sum = sum + 0.375f  * s_dstPatch[2 + tidy    ][tidx];\n"
"sum = sum + 0.25f   * s_dstPatch[2 + tidy + 1][tidx];\n"
"sum = sum + 0.0625f * s_dstPatch[2 + tidy + 2][tidx];\n"
"if ((x < dstCols) && (y < dstRows))\n"
"dst[x + y * dstStep] = (float)(4.0f * sum);\n"
"}\n"
"__kernel void pyrUp_C1_D2(__global ushort* src,__global ushort* dst,\n"
"int srcRows,int dstRows,int srcCols,int dstCols,\n"
"int srcOffset,int dstOffset,int srcStep,int dstStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"__local float s_srcPatch[10][10];\n"
"__local float s_dstPatch[20][16];\n"
"srcStep = srcStep >> 1;\n"
"dstStep = dstStep >> 1;\n"
"srcOffset = srcOffset >> 1;\n"
"dstOffset = dstOffset >> 1;\n"
"if( get_local_id(0) < 10 && get_local_id(1) < 10 )\n"
"{\n"
"int srcx = (int)(get_group_id(0) * get_local_size(0) / 2 + get_local_id(0)) - 1;\n"
"int srcy = (int)(get_group_id(1) * get_local_size(1) / 2 + get_local_id(1)) - 1;\n"
"srcx = abs(srcx);\n"
"srcx = min(srcCols - 1,srcx);\n"
"srcy = abs(srcy);\n"
"srcy = min(srcRows -1 ,srcy);\n"
"s_srcPatch[get_local_id(1)][get_local_id(0)] = (float)(src[srcx + srcy * srcStep]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float sum = 0;\n"
"const int evenFlag = (int)((get_local_id(0) & 1) == 0);\n"
"const int oddFlag = (int)((get_local_id(0) & 1) != 0);\n"
"const bool  eveny = ((get_local_id(1) & 1) == 0);\n"
"const int tidx = get_local_id(0);\n"
"if(eveny)\n"
"{\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.375f ) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[2 + get_local_id(1)][get_local_id(0)] = sum;\n"
"if (get_local_id(1) < 2)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[0][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[0][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.375f ) * s_srcPatch[0][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[0][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[0][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[get_local_id(1)][get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(1) > 13)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[9][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[9][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.375f ) * s_srcPatch[9][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[9][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[9][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[4 + get_local_id(1)][get_local_id(0)] = sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = 0;\n"
"const int tidy = get_local_id(1);\n"
"sum = sum + 0.0625f * s_dstPatch[2 + tidy - 2][get_local_id(0)];\n"
"sum = sum + 0.25f   * s_dstPatch[2 + tidy - 1][get_local_id(0)];\n"
"sum = sum + 0.375f  * s_dstPatch[2 + tidy    ][get_local_id(0)];\n"
"sum = sum + 0.25f   * s_dstPatch[2 + tidy + 1][get_local_id(0)];\n"
"sum = sum + 0.0625f * s_dstPatch[2 + tidy + 2][get_local_id(0)];\n"
"if ((x < dstCols) && (y < dstRows))\n"
"dst[x + y * dstStep] = (float)(4.0f * sum);\n"
"}\n"
"__kernel void pyrUp_C1_D5(__global float* src,__global float* dst,\n"
"int srcRows,int dstRows,int srcCols,int dstCols,\n"
"int srcOffset,int dstOffset,int srcStep,int dstStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"const int tidx = get_local_id(0);\n"
"const int tidy = get_local_id(1);\n"
"const int lsizex = get_local_size(0);\n"
"const int lsizey = get_local_size(1);\n"
"__local float s_srcPatch[10][10];\n"
"__local float s_dstPatch[20][16];\n"
"srcOffset = srcOffset >> 2;\n"
"dstOffset = dstOffset >> 2;\n"
"srcStep = srcStep >> 2;\n"
"dstStep = dstStep >> 2;\n"
"if( tidx < 10 && tidy < 10 )\n"
"{\n"
"int srcx = mad24((int)get_group_id(0), lsizex>>1, tidx) - 1;\n"
"int srcy = mad24((int)get_group_id(1), lsizey>>1, tidy) - 1;\n"
"srcx = abs(srcx);\n"
"srcx = min(srcCols - 1,srcx);\n"
"srcy = abs(srcy);\n"
"srcy = min(srcRows -1 ,srcy);\n"
"s_srcPatch[tidy][tidx] = (float)(src[srcx + srcy * srcStep]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float sum = 0;\n"
"const int evenFlag = (int)((tidx & 1) == 0);\n"
"const int oddFlag = (int)((tidx & 1) != 0);\n"
"const bool  eveny = ((tidy & 1) == 0);\n"
"if(eveny)\n"
"{\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.375f ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[2 + tidy][tidx] = sum;\n"
"if (tidy < 2)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[lsizey - 16][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[lsizey - 16][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.375f ) * s_srcPatch[lsizey - 16][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[lsizey - 16][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[lsizey - 16][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[tidy][tidx] = sum;\n"
"}\n"
"if (tidy > 13)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[lsizey - 7][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[lsizey - 7][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.375f ) * s_srcPatch[lsizey - 7][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * 0.25f  ) * s_srcPatch[lsizey - 7][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * 0.0625f) * s_srcPatch[lsizey - 7][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[4 + tidy][tidx] = sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = 0.0625f * s_dstPatch[2 + tidy - 2][tidx];\n"
"sum = sum + 0.25f   * s_dstPatch[2 + tidy - 1][tidx];\n"
"sum = sum + 0.375f  * s_dstPatch[2 + tidy    ][tidx];\n"
"sum = sum + 0.25f   * s_dstPatch[2 + tidy + 1][tidx];\n"
"sum = sum + 0.0625f * s_dstPatch[2 + tidy + 2][tidx];\n"
"if ((x < dstCols) && (y < dstRows))\n"
"dst[x + y * dstStep] = (float)(4.0f * sum);\n"
"}\n"
"float4 covert_uchar4_to_float4(uchar4 data)\n"
"{\n"
"float4 f4Data = {0,0,0,0};\n"
"f4Data.x = (float)data.x;\n"
"f4Data.y = (float)data.y;\n"
"f4Data.z = (float)data.z;\n"
"f4Data.w = (float)data.w;\n"
"return f4Data;\n"
"}\n"
"uchar4 convert_float4_to_uchar4(float4 data)\n"
"{\n"
"uchar4 u4Data;\n"
"u4Data.x = get_valid_uchar(data.x);\n"
"u4Data.y = get_valid_uchar(data.y);\n"
"u4Data.z = get_valid_uchar(data.z);\n"
"u4Data.w = get_valid_uchar(data.w);\n"
"return u4Data;\n"
"}\n"
"__kernel void pyrUp_C4_D0(__global uchar4* src,__global uchar4* dst,\n"
"int srcRows,int dstRows,int srcCols,int dstCols,\n"
"int srcOffset,int dstOffset,int srcStep,int dstStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"const int tidx = get_local_id(0);\n"
"const int tidy = get_local_id(1);\n"
"const int lsizex = get_local_size(0);\n"
"const int lsizey = get_local_size(1);\n"
"__local float4 s_srcPatch[10][10];\n"
"__local float4 s_dstPatch[20][16];\n"
"srcOffset >>= 2;\n"
"dstOffset >>= 2;\n"
"srcStep >>= 2;\n"
"dstStep >>= 2;\n"
"if( tidx < 10 && tidy < 10 )\n"
"{\n"
"int srcx = mad24((int)get_group_id(0), lsizex>>1, tidx) - 1;\n"
"int srcy = mad24((int)get_group_id(1), lsizey>>1, tidy) - 1;\n"
"srcx = abs(srcx);\n"
"srcx = min(srcCols - 1,srcx);\n"
"srcy = abs(srcy);\n"
"srcy = min(srcRows -1 ,srcy);\n"
"s_srcPatch[tidy][tidx] = covert_uchar4_to_float4(src[srcx + srcy * srcStep]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float4 sum = (float4)(0,0,0,0);\n"
"const int evenFlag = (int)((tidx & 1) == 0);\n"
"const int oddFlag = (int)((tidx & 1) != 0);\n"
"const bool  eveny = ((tidy & 1) == 0);\n"
"float4 co1 = (float4)(0.375f, 0.375f, 0.375f, 0.375f);\n"
"float4 co2 = (float4)(0.25f, 0.25f, 0.25f, 0.25f);\n"
"float4 co3 = (float4)(0.0625f, 0.0625f, 0.0625f, 0.0625f);\n"
"if(eveny)\n"
"{\n"
"sum = sum + ( evenFlag * co3) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + ( evenFlag * co1) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + ( evenFlag * co3) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[2 + tidy][tidx] = sum;\n"
"if (tidy < 2)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-16][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-16][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1) * s_srcPatch[lsizey-16][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-16][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-16][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[tidy][tidx] = sum;\n"
"}\n"
"if (tidy > 13)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1) * s_srcPatch[lsizey-7][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[4 + tidy][tidx] = sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = co3 * s_dstPatch[2 + tidy - 2][tidx];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy - 1][tidx];\n"
"sum = sum + co1 * s_dstPatch[2 + tidy    ][tidx];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy + 1][tidx];\n"
"sum = sum + co3 * s_dstPatch[2 + tidy + 2][tidx];\n"
"if ((x < dstCols) && (y < dstRows))\n"
"{\n"
"dst[x + y * dstStep] = convert_float4_to_uchar4(4.0f * sum);\n"
"}\n"
"}\n"
"float4 covert_ushort4_to_float4(ushort4 data)\n"
"{\n"
"float4 f4Data = {0,0,0,0};\n"
"f4Data.x = (float)data.x;\n"
"f4Data.y = (float)data.y;\n"
"f4Data.z = (float)data.z;\n"
"f4Data.w = (float)data.w;\n"
"return f4Data;\n"
"}\n"
"ushort4 convert_float4_to_ushort4(float4 data)\n"
"{\n"
"ushort4 u4Data;\n"
"u4Data.x = (float)data.x;\n"
"u4Data.y = (float)data.y;\n"
"u4Data.z = (float)data.z;\n"
"u4Data.w = (float)data.w;\n"
"return u4Data;\n"
"}\n"
"__kernel void pyrUp_C4_D2(__global ushort4* src,__global ushort4* dst,\n"
"int srcRows,int dstRows,int srcCols,int dstCols,\n"
"int srcOffset,int dstOffset,int srcStep,int dstStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"__local float4 s_srcPatch[10][10];\n"
"__local float4 s_dstPatch[20][16];\n"
"srcOffset >>= 3;\n"
"dstOffset >>= 3;\n"
"srcStep >>= 3;\n"
"dstStep >>= 3;\n"
"if( get_local_id(0) < 10 && get_local_id(1) < 10 )\n"
"{\n"
"int srcx = (int)(get_group_id(0) * get_local_size(0) / 2 + get_local_id(0)) - 1;\n"
"int srcy = (int)(get_group_id(1) * get_local_size(1) / 2 + get_local_id(1)) - 1;\n"
"srcx = abs(srcx);\n"
"srcx = min(srcCols - 1,srcx);\n"
"srcy = abs(srcy);\n"
"srcy = min(srcRows -1 ,srcy);\n"
"s_srcPatch[get_local_id(1)][get_local_id(0)] = covert_ushort4_to_float4(src[srcx + srcy * srcStep]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float4 sum = (float4)(0,0,0,0);\n"
"const int evenFlag = (int)((get_local_id(0) & 1) == 0);\n"
"const int oddFlag = (int)((get_local_id(0) & 1) != 0);\n"
"const bool  eveny = ((get_local_id(1) & 1) == 0);\n"
"const int tidx = get_local_id(0);\n"
"float4 co1 = (float4)(0.375f, 0.375f, 0.375f, 0.375f);\n"
"float4 co2 = (float4)(0.25f, 0.25f, 0.25f, 0.25f);\n"
"float4 co3 = (float4)(0.0625f, 0.0625f, 0.0625f, 0.0625f);\n"
"if(eveny)\n"
"{\n"
"sum = sum + ( evenFlag* co3 ) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + ( evenFlag* co1 ) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + ( evenFlag* co3 ) * s_srcPatch[1 + (get_local_id(1) >> 1)][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[2 + get_local_id(1)][get_local_id(0)] = sum;\n"
"if (get_local_id(1) < 2)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[0][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2  ) * s_srcPatch[0][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1 ) * s_srcPatch[0][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2  ) * s_srcPatch[0][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[0][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[get_local_id(1)][get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(1) > 13)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[9][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[9][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1) * s_srcPatch[9][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[9][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[9][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[4 + get_local_id(1)][get_local_id(0)] = sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = 0;\n"
"const int tidy = get_local_id(1);\n"
"sum = sum + co3 * s_dstPatch[2 + tidy - 2][get_local_id(0)];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy - 1][get_local_id(0)];\n"
"sum = sum + co1 * s_dstPatch[2 + tidy    ][get_local_id(0)];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy + 1][get_local_id(0)];\n"
"sum = sum + co3 * s_dstPatch[2 + tidy + 2][get_local_id(0)];\n"
"if ((x < dstCols) && (y < dstRows))\n"
"{\n"
"dst[x + y * dstStep] = convert_float4_to_ushort4(4.0f * sum);\n"
"}\n"
"}\n"
"__kernel void pyrUp_C4_D5(__global float4* src,__global float4* dst,\n"
"int srcRows,int dstRows,int srcCols,int dstCols,\n"
"int srcOffset,int dstOffset,int srcStep,int dstStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"const int tidx = get_local_id(0);\n"
"const int tidy = get_local_id(1);\n"
"const int lsizex = get_local_size(0);\n"
"const int lsizey = get_local_size(1);\n"
"__local float4 s_srcPatch[10][10];\n"
"__local float4 s_dstPatch[20][16];\n"
"srcOffset >>= 4;\n"
"dstOffset >>= 4;\n"
"srcStep >>= 4;\n"
"dstStep >>= 4;\n"
"if( tidx < 10 && tidy < 10 )\n"
"{\n"
"int srcx = (int)(get_group_id(0) * get_local_size(0) / 2 + tidx) - 1;\n"
"int srcy = (int)(get_group_id(1) * get_local_size(1) / 2 + tidy) - 1;\n"
"srcx = abs(srcx);\n"
"srcx = min(srcCols - 1,srcx);\n"
"srcy = abs(srcy);\n"
"srcy = min(srcRows -1 ,srcy);\n"
"s_srcPatch[tidy][tidx] = (float4)(src[srcx + srcy * srcStep]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float4 sum = (float4)(0,0,0,0);\n"
"const int evenFlag = (int)((tidx & 1) == 0);\n"
"const int oddFlag = (int)((tidx & 1) != 0);\n"
"const bool  eveny = ((tidy & 1) == 0);\n"
"float4 co1 = (float4)(0.375f, 0.375f, 0.375f, 0.375f);\n"
"float4 co2 = (float4)(0.25f, 0.25f, 0.25f, 0.25f);\n"
"float4 co3 = (float4)(0.0625f, 0.0625f, 0.0625f, 0.0625f);\n"
"if(eveny)\n"
"{\n"
"sum = sum + ( evenFlag* co3 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + ( evenFlag* co1 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + ( evenFlag* co3 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[2 + tidy][tidx] = sum;\n"
"if (tidy < 2)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-16][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2  ) * s_srcPatch[lsizey-16][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1 ) * s_srcPatch[lsizey-16][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2  ) * s_srcPatch[lsizey-16][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-16][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[tidy][tidx] = sum;\n"
"}\n"
"if (tidy > 13)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1) * s_srcPatch[lsizey-7][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[4 + tidy][tidx] = sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = co3 * s_dstPatch[2 + tidy - 2][tidx];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy - 1][tidx];\n"
"sum = sum + co1 * s_dstPatch[2 + tidy    ][tidx];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy + 1][tidx];\n"
"sum = sum + co3 * s_dstPatch[2 + tidy + 2][tidx];\n"
"if ((x < dstCols) && (y < dstRows))\n"
"{\n"
"dst[x + y * dstStep] = 4.0f * sum;\n"
"}\n"
"}\n"
;
const char* pyrlk="__kernel void calcSharrDeriv_vertical_C1_D0(__global const uchar* src, int srcStep, int rows, int cols, int cn, __global short* dx_buf, int dx_bufStep, __global short* dy_buf, int dy_bufStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (y < rows && x < cols * cn)\n"
"{\n"
"const uchar src_val0 = (src + (y > 0 ? y-1 : rows > 1 ? 1 : 0) * srcStep)[x];\n"
"const uchar src_val1 = (src + y * srcStep)[x];\n"
"const uchar src_val2 = (src + (y < rows-1 ? y+1 : rows > 1 ? rows-2 : 0) * srcStep)[x];\n"
"((__global short*)((__global char*)dx_buf + y * dx_bufStep / 2))[x] = (src_val0 + src_val2) * 3 + src_val1 * 10;\n"
"((__global short*)((__global char*)dy_buf + y * dy_bufStep / 2))[x] = src_val2 - src_val0;\n"
"}\n"
"}\n"
"__kernel void calcSharrDeriv_vertical_C4_D0(__global const uchar* src, int srcStep, int rows, int cols, int cn, __global short* dx_buf, int dx_bufStep, __global short* dy_buf, int dy_bufStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (y < rows && x < cols * cn)\n"
"{\n"
"const uchar src_val0 = (src + (y > 0 ? y - 1 : 1) * srcStep)[x];\n"
"const uchar src_val1 = (src + y * srcStep)[x];\n"
"const uchar src_val2 = (src + (y < rows - 1 ? y + 1 : rows - 2) * srcStep)[x];\n"
"((__global short*)((__global char*)dx_buf + y * dx_bufStep / 2))[x] = (src_val0 + src_val2) * 3 + src_val1 * 10;\n"
"((__global short*)((__global char*)dy_buf + y * dy_bufStep / 2))[x] = src_val2 - src_val0;\n"
"}\n"
"}\n"
"__kernel void calcSharrDeriv_horizontal_C1_D0(int rows, int cols, int cn, __global const short* dx_buf, int dx_bufStep, __global const short* dy_buf, int dy_bufStep, __global short* dIdx, int dIdxStep, __global short* dIdy, int dIdyStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"const int colsn = cols * cn;\n"
"if (y < rows && x < colsn)\n"
"{\n"
"__global const short* dx_buf_row = dx_buf + y * dx_bufStep;\n"
"__global const short* dy_buf_row = dy_buf + y * dy_bufStep;\n"
"const int xr = x + cn < colsn ? x + cn : (cols - 2) * cn + x + cn - colsn;\n"
"const int xl = x - cn >= 0 ? x - cn : cn + x;\n"
"((__global short*)((__global char*)dIdx + y * dIdxStep / 2))[x] = dx_buf_row[xr] - dx_buf_row[xl];\n"
"((__global short*)((__global char*)dIdy + y * dIdyStep / 2))[x] = (dy_buf_row[xr] + dy_buf_row[xl]) * 3 + dy_buf_row[x] * 10;\n"
"}\n"
"}\n"
"__kernel void calcSharrDeriv_horizontal_C4_D0(int rows, int cols, int cn, __global const short* dx_buf, int dx_bufStep, __global const short* dy_buf, int dy_bufStep, __global short* dIdx, int dIdxStep, __global short* dIdy, int dIdyStep)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"const int colsn = cols * cn;\n"
"if (y < rows && x < colsn)\n"
"{\n"
"__global const short* dx_buf_row = dx_buf + y * dx_bufStep;\n"
"__global const short* dy_buf_row = dy_buf + y * dy_bufStep;\n"
"const int xr = x + cn < colsn ? x + cn : (cols - 2) * cn + x + cn - colsn;\n"
"const int xl = x - cn >= 0 ? x - cn : cn + x;\n"
"((__global short*)((__global char*)dIdx + y * dIdxStep / 2))[x] = dx_buf_row[xr] - dx_buf_row[xl];\n"
"((__global short*)((__global char*)dIdy + y * dIdyStep / 2))[x] = (dy_buf_row[xr] + dy_buf_row[xl]) * 3 + dy_buf_row[x] * 10;\n"
"}\n"
"}\n"
"#define W_BITS 14\n"
"#define W_BITS1 14\n"
"#define  CV_DESCALE(x, n)     (((x) + (1 << ((n)-1))) >> (n))\n"
"int linearFilter_uchar(__global const uchar* src, int srcStep, int cn, float2 pt, int x, int y)\n"
"{\n"
"int2 ipt;\n"
"ipt.x = convert_int_sat_rtn(pt.x);\n"
"ipt.y = convert_int_sat_rtn(pt.y);\n"
"float a = pt.x - ipt.x;\n"
"float b = pt.y - ipt.y;\n"
"int iw00 = convert_int_sat_rte((1.0f - a) * (1.0f - b) * (1 << W_BITS));\n"
"int iw01 = convert_int_sat_rte(a * (1.0f - b) * (1 << W_BITS));\n"
"int iw10 = convert_int_sat_rte((1.0f - a) * b * (1 << W_BITS));\n"
"int iw11 = (1 << W_BITS) - iw00 - iw01 - iw10;\n"
"__global const uchar* src_row = src + (ipt.y + y) * srcStep + ipt.x * cn;\n"
"__global const uchar* src_row1 = src + (ipt.y + y + 1) * srcStep + ipt.x * cn;\n"
"return CV_DESCALE(src_row[x] * iw00 + src_row[x + cn] * iw01 + src_row1[x] * iw10 + src_row1[x + cn] * iw11, W_BITS1 - 5);\n"
"}\n"
"int linearFilter_short(__global const short* src, int srcStep, int cn, float2 pt, int x, int y)\n"
"{\n"
"int2 ipt;\n"
"ipt.x = convert_int_sat_rtn(pt.x);\n"
"ipt.y = convert_int_sat_rtn(pt.y);\n"
"float a = pt.x - ipt.x;\n"
"float b = pt.y - ipt.y;\n"
"int iw00 = convert_int_sat_rte((1.0f - a) * (1.0f - b) * (1 << W_BITS));\n"
"int iw01 = convert_int_sat_rte(a * (1.0f - b) * (1 << W_BITS));\n"
"int iw10 = convert_int_sat_rte((1.0f - a) * b * (1 << W_BITS));\n"
"int iw11 = (1 << W_BITS) - iw00 - iw01 - iw10;\n"
"__global const short* src_row = src + (ipt.y + y) * srcStep + ipt.x * cn;\n"
"__global const short* src_row1 = src + (ipt.y + y + 1) * srcStep + ipt.x * cn;\n"
"return CV_DESCALE(src_row[x] * iw00 + src_row[x + cn] * iw01 + src_row1[x] * iw10 + src_row1[x + cn] * iw11, W_BITS1);\n"
"}\n"
"float linearFilter_float(__global const float* src, int srcStep, int cn, float2 pt, float x, float y)\n"
"{\n"
"int2 ipt;\n"
"ipt.x = convert_int_sat_rtn(pt.x);\n"
"ipt.y = convert_int_sat_rtn(pt.y);\n"
"float a = pt.x - ipt.x;\n"
"float b = pt.y - ipt.y;\n"
"float iw00 = ((1.0f - a) * (1.0f - b) * (1 << W_BITS));\n"
"float iw01 = (a * (1.0f - b) * (1 << W_BITS));\n"
"float iw10 = ((1.0f - a) * b * (1 << W_BITS));\n"
"float iw11 = (1 << W_BITS) - iw00 - iw01 - iw10;\n"
"__global const float* src_row = src + (int)(ipt.y + y) * srcStep / 4 + ipt.x * cn;\n"
"__global const float* src_row1 = src + (int)(ipt.y + y + 1) * srcStep / 4 + ipt.x * cn;\n"
"return src_row[(int)x] * iw00 + src_row[(int)x + cn] * iw01 + src_row1[(int)x] * iw10 + src_row1[(int)x + cn] * iw11, W_BITS1 - 5;\n"
"}\n"
"#define  BUFFER  64\n"
"void reduce3(float val1, float val2, float val3, __local float* smem1, __local float* smem2, __local float* smem3, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"smem2[tid] = val2;\n"
"smem3[tid] = val3;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#if  BUFFER > 128\n"
"if (tid < 128)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 128];\n"
"smem2[tid] = val2 += smem2[tid + 128];\n"
"smem3[tid] = val3 += smem3[tid + 128];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"#if  BUFFER > 64\n"
"if (tid < 64)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 64];\n"
"smem2[tid] = val2 += smem2[tid + 64];\n"
"smem3[tid] = val3 += smem3[tid + 64];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"if (tid < 32)\n"
"{\n"
"volatile __local float* vmem1 = smem1;\n"
"volatile __local float* vmem2 = smem2;\n"
"volatile __local float* vmem3 = smem3;\n"
"vmem1[tid] = val1 += vmem1[tid + 32];\n"
"vmem2[tid] = val2 += vmem2[tid + 32];\n"
"vmem3[tid] = val3 += vmem3[tid + 32];\n"
"vmem1[tid] = val1 += vmem1[tid + 16];\n"
"vmem2[tid] = val2 += vmem2[tid + 16];\n"
"vmem3[tid] = val3 += vmem3[tid + 16];\n"
"vmem1[tid] = val1 += vmem1[tid + 8];\n"
"vmem2[tid] = val2 += vmem2[tid + 8];\n"
"vmem3[tid] = val3 += vmem3[tid + 8];\n"
"vmem1[tid] = val1 += vmem1[tid + 4];\n"
"vmem2[tid] = val2 += vmem2[tid + 4];\n"
"vmem3[tid] = val3 += vmem3[tid + 4];\n"
"vmem1[tid] = val1 += vmem1[tid + 2];\n"
"vmem2[tid] = val2 += vmem2[tid + 2];\n"
"vmem3[tid] = val3 += vmem3[tid + 2];\n"
"vmem1[tid] = val1 += vmem1[tid + 1];\n"
"vmem2[tid] = val2 += vmem2[tid + 1];\n"
"vmem3[tid] = val3 += vmem3[tid + 1];\n"
"}\n"
"}\n"
"void reduce2(float val1, float val2, __local float* smem1, __local float* smem2, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"smem2[tid] = val2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#if  BUFFER > 128\n"
"if (tid < 128)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 128];\n"
"smem2[tid] = val2 += smem2[tid + 128];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"#if  BUFFER > 64\n"
"if (tid < 64)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 64];\n"
"smem2[tid] = val2 += smem2[tid + 64];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"if (tid < 32)\n"
"{\n"
"volatile __local float* vmem1 = smem1;\n"
"volatile __local float* vmem2 = smem2;\n"
"vmem1[tid] = val1 += vmem1[tid + 32];\n"
"vmem2[tid] = val2 += vmem2[tid + 32];\n"
"vmem1[tid] = val1 += vmem1[tid + 16];\n"
"vmem2[tid] = val2 += vmem2[tid + 16];\n"
"vmem1[tid] = val1 += vmem1[tid + 8];\n"
"vmem2[tid] = val2 += vmem2[tid + 8];\n"
"vmem1[tid] = val1 += vmem1[tid + 4];\n"
"vmem2[tid] = val2 += vmem2[tid + 4];\n"
"vmem1[tid] = val1 += vmem1[tid + 2];\n"
"vmem2[tid] = val2 += vmem2[tid + 2];\n"
"vmem1[tid] = val1 += vmem1[tid + 1];\n"
"vmem2[tid] = val2 += vmem2[tid + 1];\n"
"}\n"
"}\n"
"void reduce1(float val1, __local float* smem1, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#if  BUFFER > 128\n"
"if (tid < 128)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 128];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"#if  BUFFER > 64\n"
"if (tid < 64)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 64];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"if (tid < 32)\n"
"{\n"
"volatile __local float* vmem1 = smem1;\n"
"vmem1[tid] = val1 += vmem1[tid + 32];\n"
"vmem1[tid] = val1 += vmem1[tid + 16];\n"
"vmem1[tid] = val1 += vmem1[tid + 8];\n"
"vmem1[tid] = val1 += vmem1[tid + 4];\n"
"vmem1[tid] = val1 += vmem1[tid + 2];\n"
"vmem1[tid] = val1 += vmem1[tid + 1];\n"
"}\n"
"}\n"
"#define SCALE (1.0f / (1 << 20))\n"
"#define  THRESHOLD  0.01f\n"
"#define  DIMENSION  21\n"
"__constant sampler_t sampler    = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\n"
"void SetPatch(image2d_t I, float x, float y,\n"
"float* Pch, float* Dx, float* Dy,\n"
"float* A11, float* A12, float* A22)\n"
"{\n"
"*Pch = read_imagef(I, sampler, (float2)(x, y)).x;\n"
"float dIdx = 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x + 1, y)).x + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)).x -\n"
"(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x - 1, y)).x + 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)).x);\n"
"float dIdy = 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x, y + 1)).x + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)).x -\n"
"(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)).x + 10.0f * read_imagef(I, sampler, (float2)(x, y - 1)).x + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)).x);\n"
"*Dx = dIdx;\n"
"*Dy = dIdy;\n"
"*A11 += dIdx * dIdx;\n"
"*A12 += dIdx * dIdy;\n"
"*A22 += dIdy * dIdy;\n"
"}\n"
"void GetPatch(image2d_t J, float x, float y,\n"
"float* Pch, float* Dx, float* Dy,\n"
"float* b1, float* b2)\n"
"{\n"
"float J_val = read_imagef(J, sampler, (float2)(x, y)).x;\n"
"float diff = (J_val - *Pch) * 32.0f;\n"
"*b1 += diff**Dx;\n"
"*b2 += diff**Dy;\n"
"}\n"
"void GetError(image2d_t J, const float x, const float y, const float* Pch, float* errval)\n"
"{\n"
"float diff = read_imagef(J, sampler, (float2)(x,y)).x-*Pch;\n"
"*errval += fabs(diff);\n"
"}\n"
"void SetPatch4(image2d_t I, const float x, const float y,\n"
"float4* Pch, float4* Dx, float4* Dy,\n"
"float* A11, float* A12, float* A22)\n"
"{\n"
"*Pch = read_imagef(I, sampler, (float2)(x, y));\n"
"float4 dIdx = 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)) + 10.0f * read_imagef(I, sampler, (float2)(x + 1, y)) + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)) -\n"
"(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)) + 10.0f * read_imagef(I, sampler, (float2)(x - 1, y)) + 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)));\n"
"float4 dIdy = 3.0f * read_imagef(I, sampler, (float2)(x - 1, y + 1)) + 10.0f * read_imagef(I, sampler, (float2)(x, y + 1)) + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y + 1)) -\n"
"(3.0f * read_imagef(I, sampler, (float2)(x - 1, y - 1)) + 10.0f * read_imagef(I, sampler, (float2)(x, y - 1)) + 3.0f * read_imagef(I, sampler, (float2)(x + 1, y - 1)));\n"
"*Dx = dIdx;\n"
"*Dy = dIdy;\n"
"float4 sqIdx = dIdx * dIdx;\n"
"*A11 += sqIdx.x + sqIdx.y + sqIdx.z;\n"
"sqIdx = dIdx * dIdy;\n"
"*A12 += sqIdx.x + sqIdx.y + sqIdx.z;\n"
"sqIdx = dIdy * dIdy;\n"
"*A22 += sqIdx.x + sqIdx.y + sqIdx.z;\n"
"}\n"
"void GetPatch4(image2d_t J, const float x, const float y,\n"
"const float4* Pch, const float4* Dx, const float4* Dy,\n"
"float* b1, float* b2)\n"
"{\n"
"float4 J_val = read_imagef(J, sampler, (float2)(x, y));\n"
"float4 diff = (J_val - *Pch) * 32.0f;\n"
"float4 xdiff = diff* *Dx;\n"
"*b1 += xdiff.x + xdiff.y + xdiff.z;\n"
"xdiff = diff* *Dy;\n"
"*b2 += xdiff.x + xdiff.y + xdiff.z;\n"
"}\n"
"void GetError4(image2d_t J, const float x, const float y, const float4* Pch, float* errval)\n"
"{\n"
"float4 diff = read_imagef(J, sampler, (float2)(x,y))-*Pch;\n"
"*errval += fabs(diff.x) + fabs(diff.y) + fabs(diff.z);\n"
"}\n"
"__kernel void lkSparse_C1_D5(image2d_t I, image2d_t J,\n"
"__global const float2* prevPts, int prevPtsStep, __global float2* nextPts, int nextPtsStep, __global uchar* status, __global float* err,\n"
"const int level, const int rows, const int cols, int PATCH_X, int PATCH_Y, int cn, int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n"
"{\n"
"__local float smem1[BUFFER];\n"
"__local float smem2[BUFFER];\n"
"__local float smem3[BUFFER];\n"
"unsigned int xid=get_local_id(0);\n"
"unsigned int yid=get_local_id(1);\n"
"unsigned int gid=get_group_id(0);\n"
"unsigned int xsize=get_local_size(0);\n"
"unsigned int ysize=get_local_size(1);\n"
"int xBase, yBase, i, j, k;\n"
"float2 c_halfWin = (float2)((c_winSize_x - 1)>>1, (c_winSize_y - 1)>>1);\n"
"const int tid = mad24(yid, xsize, xid);\n"
"float2 prevPt = prevPts[gid] / (1 << level);\n"
"if (prevPt.x < 0 || prevPt.x >= cols || prevPt.y < 0 || prevPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"{\n"
"status[gid] = 0;\n"
"}\n"
"return;\n"
"}\n"
"prevPt -= c_halfWin;\n"
"float A11 = 0;\n"
"float A12 = 0;\n"
"float A22 = 0;\n"
"float I_patch[3][3];\n"
"float dIdx_patch[3][3];\n"
"float dIdy_patch[3][3];\n"
"yBase=yid;\n"
"{\n"
"xBase=xid;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][0], &dIdx_patch[0][0], &dIdy_patch[0][0],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][1], &dIdx_patch[0][1], &dIdy_patch[0][1],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][2], &dIdx_patch[0][2], &dIdy_patch[0][2],\n"
"&A11, &A12, &A22);\n"
"}\n"
"yBase+=ysize;\n"
"{\n"
"xBase=xid;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][0], &dIdx_patch[1][0], &dIdy_patch[1][0],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][1], &dIdx_patch[1][1], &dIdy_patch[1][1],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][2], &dIdx_patch[1][2], &dIdy_patch[1][2],\n"
"&A11, &A12, &A22);\n"
"}\n"
"yBase+=ysize;\n"
"if(yBase<c_winSize_y)\n"
"{\n"
"xBase=xid;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][0], &dIdx_patch[2][0], &dIdy_patch[2][0],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][1], &dIdx_patch[2][1], &dIdy_patch[2][1],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"SetPatch(I, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][2], &dIdx_patch[2][2], &dIdy_patch[2][2],\n"
"&A11, &A12, &A22);\n"
"}\n"
"reduce3(A11, A12, A22, smem1, smem2, smem3, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"A11 = smem1[0];\n"
"A12 = smem2[0];\n"
"A22 = smem3[0];\n"
"float D = A11 * A22 - A12 * A12;\n"
"if (D < 1.192092896e-07f)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"status[gid] = 0;\n"
"return;\n"
"}\n"
"A11 /= D;\n"
"A12 /= D;\n"
"A22 /= D;\n"
"prevPt = nextPts[gid] * 2.0f - c_halfWin;\n"
"for (k = 0; k < c_iters; ++k)\n"
"{\n"
"if (prevPt.x < -c_halfWin.x || prevPt.x >= cols || prevPt.y < -c_halfWin.y || prevPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"status[gid] = 0;\n"
"return;\n"
"}\n"
"float b1 = 0;\n"
"float b2 = 0;\n"
"yBase=yid;\n"
"{\n"
"xBase=xid;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][0], &dIdx_patch[0][0], &dIdy_patch[0][0],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][1], &dIdx_patch[0][1], &dIdy_patch[0][1],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][2], &dIdx_patch[0][2], &dIdy_patch[0][2],\n"
"&b1, &b2);\n"
"}\n"
"yBase+=ysize;\n"
"{\n"
"xBase=xid;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][0], &dIdx_patch[1][0], &dIdy_patch[1][0],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][1], &dIdx_patch[1][1], &dIdy_patch[1][1],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][2], &dIdx_patch[1][2], &dIdy_patch[1][2],\n"
"&b1, &b2);\n"
"}\n"
"yBase+=ysize;\n"
"if(yBase<c_winSize_y)\n"
"{\n"
"xBase=xid;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][0], &dIdx_patch[2][0], &dIdy_patch[2][0],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][1], &dIdx_patch[2][1], &dIdy_patch[2][1],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetPatch(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][2], &dIdx_patch[2][2], &dIdy_patch[2][2],\n"
"&b1, &b2);\n"
"}\n"
"reduce2(b1, b2, smem1, smem2, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"b1 = smem1[0];\n"
"b2 = smem2[0];\n"
"float2 delta;\n"
"delta.x = A12 * b2 - A22 * b1;\n"
"delta.y = A12 * b1 - A11 * b2;\n"
"prevPt += delta;\n"
"if (fabs(delta.x) < THRESHOLD && fabs(delta.y) < THRESHOLD)\n"
"break;\n"
"}\n"
"D = 0.0f;\n"
"if (calcErr)\n"
"{\n"
"yBase=yid;\n"
"{\n"
"xBase=xid;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][0], &D);\n"
"xBase+=xsize;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][1], &D);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[0][2], &D);\n"
"}\n"
"yBase+=ysize;\n"
"{\n"
"xBase=xid;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][0], &D);\n"
"xBase+=xsize;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][1], &D);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[1][2], &D);\n"
"}\n"
"yBase+=ysize;\n"
"if(yBase<c_winSize_y)\n"
"{\n"
"xBase=xid;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][0], &D);\n"
"xBase+=xsize;\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][1], &D);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetError(J, prevPt.x + xBase + 0.5f, prevPt.y + yBase + 0.5f,\n"
"&I_patch[2][2], &D);\n"
"}\n"
"reduce1(D, smem1, tid);\n"
"}\n"
"if (tid == 0)\n"
"{\n"
"prevPt += c_halfWin;\n"
"nextPts[gid] = prevPt;\n"
"if (calcErr)\n"
"err[gid] = smem1[0] / (c_winSize_x * c_winSize_y);\n"
"}\n"
"}\n"
"__kernel void lkSparse_C4_D5(image2d_t I, image2d_t J,\n"
"__global const float2* prevPts, int prevPtsStep, __global float2* nextPts, int nextPtsStep, __global uchar* status, __global float* err,\n"
"const int level, const int rows, const int cols, int PATCH_X, int PATCH_Y, int cn, int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n"
"{\n"
"__local float smem1[BUFFER];\n"
"__local float smem2[BUFFER];\n"
"__local float smem3[BUFFER];\n"
"unsigned int xid=get_local_id(0);\n"
"unsigned int yid=get_local_id(1);\n"
"unsigned int gid=get_group_id(0);\n"
"unsigned int xsize=get_local_size(0);\n"
"unsigned int ysize=get_local_size(1);\n"
"int xBase, yBase, i, j, k;\n"
"float2 c_halfWin = (float2)((c_winSize_x - 1)>>1, (c_winSize_y - 1)>>1);\n"
"const int tid = mad24(yid, xsize, xid);\n"
"float2 nextPt = prevPts[gid]/(1<<level);\n"
"if (nextPt.x < 0 || nextPt.x >= cols || nextPt.y < 0 || nextPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"{\n"
"status[gid] = 0;\n"
"}\n"
"return;\n"
"}\n"
"nextPt -= c_halfWin;\n"
"float A11 = 0;\n"
"float A12 = 0;\n"
"float A22 = 0;\n"
"float4 I_patch[8];\n"
"float4 dIdx_patch[8];\n"
"float4 dIdy_patch[8];\n"
"float4 I_add,Dx_add,Dy_add;\n"
"yBase=yid;\n"
"{\n"
"xBase=xid;\n"
"SetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[0], &dIdx_patch[0], &dIdy_patch[0],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"SetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[1], &dIdx_patch[1], &dIdy_patch[1],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"SetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[2], &dIdx_patch[2], &dIdy_patch[2],\n"
"&A11, &A12, &A22);\n"
"}\n"
"yBase+=ysize;\n"
"{\n"
"xBase=xid;\n"
"SetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[3], &dIdx_patch[3], &dIdy_patch[3],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"SetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[4], &dIdx_patch[4], &dIdy_patch[4],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"SetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[5], &dIdx_patch[5], &dIdy_patch[5],\n"
"&A11, &A12, &A22);\n"
"}\n"
"yBase+=ysize;\n"
"if(yBase<c_winSize_y)\n"
"{\n"
"xBase=xid;\n"
"SetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[6], &dIdx_patch[6], &dIdy_patch[6],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"SetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[7], &dIdx_patch[7], &dIdy_patch[7],\n"
"&A11, &A12, &A22);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"SetPatch4(I, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_add, &Dx_add, &Dy_add,\n"
"&A11, &A12, &A22);\n"
"}\n"
"reduce3(A11, A12, A22, smem1, smem2, smem3, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"A11 = smem1[0];\n"
"A12 = smem2[0];\n"
"A22 = smem3[0];\n"
"float D = A11 * A22 - A12 * A12;\n"
"if (D < 1.192092896e-07f)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"status[gid] = 0;\n"
"return;\n"
"}\n"
"A11 /= D;\n"
"A12 /= D;\n"
"A22 /= D;\n"
"nextPt = nextPts[gid] * 2.0f - c_halfWin;\n"
"for (k = 0; k < c_iters; ++k)\n"
"{\n"
"if (nextPt.x < -c_halfWin.x || nextPt.x >= cols || nextPt.y < -c_halfWin.y || nextPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"status[gid] = 0;\n"
"return;\n"
"}\n"
"float b1 = 0;\n"
"float b2 = 0;\n"
"yBase=yid;\n"
"{\n"
"xBase=xid;\n"
"GetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[0], &dIdx_patch[0], &dIdy_patch[0],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"GetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[1], &dIdx_patch[1], &dIdy_patch[1],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[2], &dIdx_patch[2], &dIdy_patch[2],\n"
"&b1, &b2);\n"
"}\n"
"yBase+=ysize;\n"
"{\n"
"xBase=xid;\n"
"GetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[3], &dIdx_patch[3], &dIdy_patch[3],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"GetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[4], &dIdx_patch[4], &dIdy_patch[4],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[5], &dIdx_patch[5], &dIdy_patch[5],\n"
"&b1, &b2);\n"
"}\n"
"yBase+=ysize;\n"
"if(yBase<c_winSize_y)\n"
"{\n"
"xBase=xid;\n"
"GetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[6], &dIdx_patch[6], &dIdy_patch[6],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"GetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[7], &dIdx_patch[7], &dIdy_patch[7],\n"
"&b1, &b2);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetPatch4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_add, &Dx_add, &Dy_add,\n"
"&b1, &b2);\n"
"}\n"
"reduce2(b1, b2, smem1, smem2, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"b1 = smem1[0];\n"
"b2 = smem2[0];\n"
"float2 delta;\n"
"delta.x = A12 * b2 - A22 * b1;\n"
"delta.y = A12 * b1 - A11 * b2;\n"
"nextPt +=delta;\n"
"if (fabs(delta.x) < THRESHOLD && fabs(delta.y) < THRESHOLD)\n"
"break;\n"
"}\n"
"D = 0.0f;\n"
"if (calcErr)\n"
"{\n"
"yBase=yid;\n"
"{\n"
"xBase=xid;\n"
"GetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[0], &D);\n"
"xBase+=xsize;\n"
"GetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[1], &D);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[2], &D);\n"
"}\n"
"yBase+=ysize;\n"
"{\n"
"xBase=xid;\n"
"GetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[3], &D);\n"
"xBase+=xsize;\n"
"GetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[4], &D);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[5], &D);\n"
"}\n"
"yBase+=ysize;\n"
"if(yBase<c_winSize_y)\n"
"{\n"
"xBase=xid;\n"
"GetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[6], &D);\n"
"xBase+=xsize;\n"
"GetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_patch[7], &D);\n"
"xBase+=xsize;\n"
"if(xBase<c_winSize_x)\n"
"GetError4(J, nextPt.x + xBase + 0.5f, nextPt.y + yBase + 0.5f,\n"
"&I_add, &D);\n"
"}\n"
"reduce1(D, smem1, tid);\n"
"}\n"
"if (tid == 0)\n"
"{\n"
"nextPt += c_halfWin;\n"
"nextPts[gid] = nextPt;\n"
"if (calcErr)\n"
"err[gid] = smem1[0] / (3 * c_winSize_x * c_winSize_y);\n"
"}\n"
"}\n"
"__kernel void lkDense_C1_D0(image2d_t I, image2d_t J, __global float* u, int uStep, __global float* v, int vStep, __global const float* prevU, int prevUStep, __global const float* prevV, int prevVStep,\n"
"const int rows, const int cols,  int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n"
"{\n"
"int c_halfWin_x = (c_winSize_x - 1) / 2;\n"
"int c_halfWin_y = (c_winSize_y - 1) / 2;\n"
"const int patchWidth  = get_local_size(0) + 2 * c_halfWin_x;\n"
"const int patchHeight = get_local_size(1) + 2 * c_halfWin_y;\n"
"__local int smem[8192];\n"
"__local int* I_patch = smem;\n"
"__local int* dIdx_patch = I_patch + patchWidth * patchHeight;\n"
"__local int* dIdy_patch = dIdx_patch + patchWidth * patchHeight;\n"
"const int xBase = get_group_id(0) * get_local_size(0);\n"
"const int yBase = get_group_id(1) * get_local_size(1);\n"
"sampler_t sampleri    = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\n"
"for (int i = get_local_id(1); i < patchHeight; i += get_local_size(1))\n"
"{\n"
"for (int j = get_local_id(0); j < patchWidth; j += get_local_size(0))\n"
"{\n"
"float x = xBase - c_halfWin_x + j + 0.5f;\n"
"float y = yBase - c_halfWin_y + i + 0.5f;\n"
"I_patch[i * patchWidth + j] = read_imagei(I, sampleri, (float2)(x, y)).x;\n"
"dIdx_patch[i * patchWidth + j] = 3 * read_imagei(I, sampleri, (float2)(x+1, y-1)).x + 10 * read_imagei(I, sampleri, (float2)(x+1, y)).x + 3 * read_imagei(I, sampleri, (float2)(x+1, y+1)).x -\n"
"(3 * read_imagei(I, sampleri, (float2)(x-1, y-1)).x + 10 * read_imagei(I, sampleri, (float2)(x-1, y)).x + 3 * read_imagei(I, sampleri, (float2)(x-1, y+1)).x);\n"
"dIdy_patch[i * patchWidth + j] = 3 * read_imagei(I, sampleri, (float2)(x-1, y+1)).x + 10 * read_imagei(I, sampleri, (float2)(x, y+1)).x + 3 * read_imagei(I, sampleri, (float2)(x+1, y+1)).x -\n"
"(3 * read_imagei(I, sampleri, (float2)(x-1, y-1)).x + 10 * read_imagei(I, sampleri, (float2)(x, y-1)).x + 3 * read_imagei(I, sampleri, (float2)(x+1, y-1)).x);\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (x >= cols || y >= rows)\n"
"return;\n"
"int A11i = 0;\n"
"int A12i = 0;\n"
"int A22i = 0;\n"
"for (int i = 0; i < c_winSize_y; ++i)\n"
"{\n"
"for (int j = 0; j < c_winSize_x; ++j)\n"
"{\n"
"int dIdx = dIdx_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\n"
"int dIdy = dIdy_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\n"
"A11i += dIdx * dIdx;\n"
"A12i += dIdx * dIdy;\n"
"A22i += dIdy * dIdy;\n"
"}\n"
"}\n"
"float A11 = A11i;\n"
"float A12 = A12i;\n"
"float A22 = A22i;\n"
"float D = A11 * A22 - A12 * A12;\n"
"if (D < 1.192092896e-07f)\n"
"{\n"
"return;\n"
"}\n"
"D = 1.f / D;\n"
"A11 *= D;\n"
"A12 *= D;\n"
"A22 *= D;\n"
"float2 nextPt;\n"
"nextPt.x = x + prevU[y/2 * prevUStep / 4 + x/2] * 2.0f;\n"
"nextPt.y = y + prevV[y/2 * prevVStep / 4 + x/2] * 2.0f;\n"
"for (int k = 0; k < c_iters; ++k)\n"
"{\n"
"if (nextPt.x < 0 || nextPt.x >= cols || nextPt.y < 0 || nextPt.y >= rows)\n"
"{\n"
"return;\n"
"}\n"
"int b1 = 0;\n"
"int b2 = 0;\n"
"for (int i = 0; i < c_winSize_y; ++i)\n"
"{\n"
"for (int j = 0; j < c_winSize_x; ++j)\n"
"{\n"
"int iI = I_patch[(get_local_id(1) + i) * patchWidth + get_local_id(0) + j];\n"
"int iJ = read_imagei(J, sampler, (float2)(nextPt.x - c_halfWin_x + j + 0.5f, nextPt.y - c_halfWin_y + i + 0.5f)).x;\n"
"int diff = (iJ - iI) * 32;\n"
"int dIdx = dIdx_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\n"
"int dIdy = dIdy_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\n"
"b1 += diff * dIdx;\n"
"b2 += diff * dIdy;\n"
"}\n"
"}\n"
"float2 delta;\n"
"delta.x = A12 * b2 - A22 * b1;\n"
"delta.y = A12 * b1 - A11 * b2;\n"
"nextPt.x += delta.x;\n"
"nextPt.y += delta.y;\n"
"if (fabs(delta.x) < 0.01f && fabs(delta.y) < 0.01f)\n"
"break;\n"
"}\n"
"u[y * uStep / 4 + x] = nextPt.x - x;\n"
"v[y * vStep / 4 + x] = nextPt.y - y;\n"
"if (calcErr)\n"
"{\n"
"int errval = 0;\n"
"for (int i = 0; i < c_winSize_y; ++i)\n"
"{\n"
"for (int j = 0; j < c_winSize_x; ++j)\n"
"{\n"
"int iI = I_patch[(get_local_id(1) + i) * patchWidth + get_local_id(0) + j];\n"
"int iJ = read_imagei(J, sampler, (float2)(nextPt.x - c_halfWin_x + j + 0.5f, nextPt.y - c_halfWin_y + i + 0.5f)).x;\n"
"errval += abs(iJ - iI);\n"
"}\n"
"}\n"
"}\n"
"}\n"
;
const char* pyrlk_no_image="#define  BUFFER  256\n"
"void reduce3(float val1, float val2, float val3, __local float *smem1, __local float *smem2, __local float *smem3, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"smem2[tid] = val2;\n"
"smem3[tid] = val3;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#if  BUFFER > 128\n"
"if (tid < 128)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 128];\n"
"smem2[tid] = val2 += smem2[tid + 128];\n"
"smem3[tid] = val3 += smem3[tid + 128];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"#if  BUFFER > 64\n"
"if (tid < 64)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 64];\n"
"smem2[tid] = val2 += smem2[tid + 64];\n"
"smem3[tid] = val3 += smem3[tid + 64];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"if (tid < 32)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 32];\n"
"smem2[tid] = val2 += smem2[tid + 32];\n"
"smem3[tid] = val3 += smem3[tid + 32];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 16];\n"
"smem2[tid] = val2 += smem2[tid + 16];\n"
"smem3[tid] = val3 += smem3[tid + 16];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"volatile __local float *vmem1 = smem1;\n"
"volatile __local float *vmem2 = smem2;\n"
"volatile __local float *vmem3 = smem3;\n"
"vmem1[tid] = val1 += vmem1[tid + 8];\n"
"vmem2[tid] = val2 += vmem2[tid + 8];\n"
"vmem3[tid] = val3 += vmem3[tid + 8];\n"
"vmem1[tid] = val1 += vmem1[tid + 4];\n"
"vmem2[tid] = val2 += vmem2[tid + 4];\n"
"vmem3[tid] = val3 += vmem3[tid + 4];\n"
"vmem1[tid] = val1 += vmem1[tid + 2];\n"
"vmem2[tid] = val2 += vmem2[tid + 2];\n"
"vmem3[tid] = val3 += vmem3[tid + 2];\n"
"vmem1[tid] = val1 += vmem1[tid + 1];\n"
"vmem2[tid] = val2 += vmem2[tid + 1];\n"
"vmem3[tid] = val3 += vmem3[tid + 1];\n"
"}\n"
"}\n"
"void reduce2(float val1, float val2, __local float *smem1, __local float *smem2, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"smem2[tid] = val2;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#if  BUFFER > 128\n"
"if (tid < 128)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 128];\n"
"smem2[tid] = val2 += smem2[tid + 128];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"#if  BUFFER > 64\n"
"if (tid < 64)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 64];\n"
"smem2[tid] = val2 += smem2[tid + 64];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"if (tid < 32)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 32];\n"
"smem2[tid] = val2 += smem2[tid + 32];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 16];\n"
"smem2[tid] = val2 += smem2[tid + 16];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"volatile __local float *vmem1 = smem1;\n"
"volatile __local float *vmem2 = smem2;\n"
"vmem1[tid] = val1 += vmem1[tid + 8];\n"
"vmem2[tid] = val2 += vmem2[tid + 8];\n"
"vmem1[tid] = val1 += vmem1[tid + 4];\n"
"vmem2[tid] = val2 += vmem2[tid + 4];\n"
"vmem1[tid] = val1 += vmem1[tid + 2];\n"
"vmem2[tid] = val2 += vmem2[tid + 2];\n"
"vmem1[tid] = val1 += vmem1[tid + 1];\n"
"vmem2[tid] = val2 += vmem2[tid + 1];\n"
"}\n"
"}\n"
"void reduce1(float val1, __local float *smem1, int tid)\n"
"{\n"
"smem1[tid] = val1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#if  BUFFER > 128\n"
"if (tid < 128)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 128];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"#if  BUFFER > 64\n"
"if (tid < 64)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 64];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#endif\n"
"if (tid < 32)\n"
"{\n"
"smem1[tid] = val1 += smem1[tid + 32];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"volatile __local float *vmem1 = smem1;\n"
"vmem1[tid] = val1 += vmem1[tid + 16];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"volatile __local float *vmem1 = smem1;\n"
"vmem1[tid] = val1 += vmem1[tid + 8];\n"
"vmem1[tid] = val1 += vmem1[tid + 4];\n"
"vmem1[tid] = val1 += vmem1[tid + 2];\n"
"vmem1[tid] = val1 += vmem1[tid + 1];\n"
"}\n"
"}\n"
"#define SCALE (1.0f / (1 << 20))\n"
"#define  THRESHOLD  0.01f\n"
"#define  DIMENSION  21\n"
"float readImage2Df_C1(__global const float *image,  const float x,  const float y,  const int rows,  const int cols, const int elemCntPerRow)\n"
"{\n"
"float2 coor = (float2)(x, y);\n"
"int i0 = clamp((int)floor(coor.x), 0, cols - 1);\n"
"int j0 = clamp((int)floor(coor.y), 0, rows - 1);\n"
"int i1 = clamp((int)floor(coor.x) + 1, 0, cols - 1);\n"
"int j1 = clamp((int)floor(coor.y) + 1, 0, rows - 1);\n"
"float a = coor.x - floor(coor.x);\n"
"float b = coor.y - floor(coor.y);\n"
"return (1 - a) * (1 - b) * image[mad24(j0, elemCntPerRow, i0)]\n"
"+ a * (1 - b) * image[mad24(j0, elemCntPerRow, i1)]\n"
"+ (1 - a) * b * image[mad24(j1, elemCntPerRow, i0)]\n"
"+ a * b * image[mad24(j1, elemCntPerRow, i1)];\n"
"}\n"
"__kernel void lkSparse_C1_D5(__global const float *I, __global const float *J,\n"
"__global const float2 *prevPts, int prevPtsStep, __global float2 *nextPts, int nextPtsStep, __global uchar *status, __global float *err,\n"
"const int level, const int rows, const int cols, const int elemCntPerRow,\n"
"int PATCH_X, int PATCH_Y, int cn, int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n"
"{\n"
"__local float smem1[BUFFER];\n"
"__local float smem2[BUFFER];\n"
"__local float smem3[BUFFER];\n"
"float2 c_halfWin = (float2)((c_winSize_x - 1) >> 1, (c_winSize_y - 1) >> 1);\n"
"const int tid = mad24(get_local_id(1), get_local_size(0), get_local_id(0));\n"
"float2 prevPt = prevPts[get_group_id(0)] * (1.0f / (1 << level));\n"
"if (prevPt.x < 0 || prevPt.x >= cols || prevPt.y < 0 || prevPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"{\n"
"status[get_group_id(0)] = 0;\n"
"}\n"
"return;\n"
"}\n"
"prevPt -= c_halfWin;\n"
"float A11 = 0;\n"
"float A12 = 0;\n"
"float A22 = 0;\n"
"float I_patch[1][3];\n"
"float dIdx_patch[1][3];\n"
"float dIdy_patch[1][3];\n"
"for (int yBase = get_local_id(1), i = 0; yBase < c_winSize_y; yBase += get_local_size(1), ++i)\n"
"{\n"
"for (int xBase = get_local_id(0), j = 0; xBase < c_winSize_x; xBase += get_local_size(0), ++j)\n"
"{\n"
"float x = (prevPt.x + xBase);\n"
"float y = (prevPt.y + yBase);\n"
"I_patch[i][j] = readImage2Df_C1(I, x, y, rows, cols, elemCntPerRow);\n"
"float dIdx = 3.0f * readImage2Df_C1(I, x + 1, y - 1, rows, cols, elemCntPerRow) + 10.0f * readImage2Df_C1(I, x + 1, y, rows, cols, elemCntPerRow) + 3.0f * readImage2Df_C1(I, x + 1, y + 1, rows, cols, elemCntPerRow) -\n"
"(3.0f * readImage2Df_C1(I, x - 1, y - 1, rows, cols, elemCntPerRow) + 10.0f * readImage2Df_C1(I, x - 1, y, rows, cols, elemCntPerRow) + 3.0f * readImage2Df_C1(I, x - 1, y + 1, rows, cols, elemCntPerRow));\n"
"float dIdy = 3.0f * readImage2Df_C1(I, x - 1, y + 1, rows, cols, elemCntPerRow) + 10.0f * readImage2Df_C1(I, x, y + 1, rows, cols, elemCntPerRow) + 3.0f * readImage2Df_C1(I, x + 1, y + 1, rows, cols, elemCntPerRow) -\n"
"(3.0f * readImage2Df_C1(I, x - 1, y - 1, rows, cols, elemCntPerRow) + 10.0f * readImage2Df_C1(I, x, y - 1, rows, cols, elemCntPerRow) + 3.0f * readImage2Df_C1(I, x + 1, y - 1, rows, cols, elemCntPerRow));\n"
"dIdx_patch[i][j] = dIdx;\n"
"dIdy_patch[i][j] = dIdy;\n"
"A11 += dIdx * dIdx;\n"
"A12 += dIdx * dIdy;\n"
"A22 += dIdy * dIdy;\n"
"}\n"
"}\n"
"reduce3(A11, A12, A22, smem1, smem2, smem3, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"A11 = smem1[0];\n"
"A12 = smem2[0];\n"
"A22 = smem3[0];\n"
"float D = A11 * A22 - A12 * A12;\n"
"if (D < 1.192092896e-07f)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"{\n"
"status[get_group_id(0)] = 0;\n"
"}\n"
"return;\n"
"}\n"
"D = 1.f / D;\n"
"A11 *= D;\n"
"A12 *= D;\n"
"A22 *= D;\n"
"float2 nextPt = nextPts[get_group_id(0)];\n"
"nextPt = nextPt * 2.0f - c_halfWin;\n"
"for (int k = 0; k < c_iters; ++k)\n"
"{\n"
"if (nextPt.x < -c_halfWin.x || nextPt.x >= cols || nextPt.y < -c_halfWin.y || nextPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"{\n"
"status[get_group_id(0)] = 0;\n"
"}\n"
"return;\n"
"}\n"
"float b1 = 0;\n"
"float b2 = 0;\n"
"for (int y = get_local_id(1), i = 0; y < c_winSize_y; y += get_local_size(1), ++i)\n"
"{\n"
"for (int x = get_local_id(0), j = 0; x < c_winSize_x; x += get_local_size(0), ++j)\n"
"{\n"
"float diff = (readImage2Df_C1(J, nextPt.x + x, nextPt.y + y, rows, cols, elemCntPerRow) - I_patch[i][j]) * 32.0f;\n"
"b1 += diff * dIdx_patch[i][j];\n"
"b2 += diff * dIdy_patch[i][j];\n"
"}\n"
"}\n"
"reduce2(b1, b2, smem1, smem2, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"b1 = smem1[0];\n"
"b2 = smem2[0];\n"
"float2 delta;\n"
"delta.x = A12 * b2 - A22 * b1;\n"
"delta.y = A12 * b1 - A11 * b2;\n"
"nextPt += delta;\n"
"}\n"
"float errval = 0.0f;\n"
"if (calcErr)\n"
"{\n"
"for (int y = get_local_id(1), i = 0; y < c_winSize_y; y += get_local_size(1), ++i)\n"
"{\n"
"for (int x = get_local_id(0), j = 0; x < c_winSize_x; x += get_local_size(0), ++j)\n"
"{\n"
"float diff = readImage2Df_C1(J, nextPt.x + x, nextPt.y + y, rows, cols, elemCntPerRow) - I_patch[i][j];\n"
"errval += fabs(diff);\n"
"}\n"
"}\n"
"reduce1(errval, smem1, tid);\n"
"}\n"
"if (tid == 0)\n"
"{\n"
"nextPt += c_halfWin;\n"
"nextPts[get_group_id(0)] = nextPt;\n"
"if (calcErr)\n"
"{\n"
"err[get_group_id(0)] = smem1[0] / (c_winSize_x * c_winSize_y);\n"
"}\n"
"}\n"
"}\n"
"float4 readImage2Df_C4(__global const float4 *image,  const float x,  const float y,  const int rows,  const int cols, const int elemCntPerRow)\n"
"{\n"
"float2 coor = (float2)(x, y);\n"
"int i0 = clamp((int)floor(coor.x), 0, cols - 1);\n"
"int j0 = clamp((int)floor(coor.y), 0, rows - 1);\n"
"int i1 = clamp((int)floor(coor.x) + 1, 0, cols - 1);\n"
"int j1 = clamp((int)floor(coor.y) + 1, 0, rows - 1);\n"
"float a = coor.x - floor(coor.x);\n"
"float b = coor.y - floor(coor.y);\n"
"return (1 - a) * (1 - b) * image[mad24(j0, elemCntPerRow, i0)]\n"
"+ a * (1 - b) * image[mad24(j0, elemCntPerRow, i1)]\n"
"+ (1 - a) * b * image[mad24(j1, elemCntPerRow, i0)]\n"
"+ a * b * image[mad24(j1, elemCntPerRow, i1)];\n"
"}\n"
"__kernel void lkSparse_C4_D5(__global const float *I, __global const float *J,\n"
"__global const float2 *prevPts, int prevPtsStep, __global float2 *nextPts, int nextPtsStep, __global uchar *status, __global float *err,\n"
"const int level, const int rows, const int cols, const int elemCntPerRow,\n"
"int PATCH_X, int PATCH_Y, int cn, int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n"
"{\n"
"__local float smem1[BUFFER];\n"
"__local float smem2[BUFFER];\n"
"__local float smem3[BUFFER];\n"
"float2 c_halfWin = (float2)((c_winSize_x - 1) >> 1, (c_winSize_y - 1) >> 1);\n"
"const int tid = mad24(get_local_id(1), get_local_size(0), get_local_id(0));\n"
"float2 prevPt = prevPts[get_group_id(0)] * (1.0f / (1 << level));\n"
"if (prevPt.x < 0 || prevPt.x >= cols || prevPt.y < 0 || prevPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"{\n"
"status[get_group_id(0)] = 0;\n"
"}\n"
"return;\n"
"}\n"
"prevPt -= c_halfWin;\n"
"float A11 = 0;\n"
"float A12 = 0;\n"
"float A22 = 0;\n"
"float4 I_patch[1][3];\n"
"float4 dIdx_patch[1][3];\n"
"float4 dIdy_patch[1][3];\n"
"__global float4 *ptrI = (__global float4 *)I;\n"
"for (int yBase = get_local_id(1), i = 0; yBase < c_winSize_y; yBase += get_local_size(1), ++i)\n"
"{\n"
"for (int xBase = get_local_id(0), j = 0; xBase < c_winSize_x; xBase += get_local_size(0), ++j)\n"
"{\n"
"float x = (prevPt.x + xBase);\n"
"float y = (prevPt.y + yBase);\n"
"I_patch[i][j] = readImage2Df_C4(ptrI, x, y, rows, cols, elemCntPerRow);\n"
"float4 dIdx = 3.0f * readImage2Df_C4(ptrI, x + 1, y - 1, rows, cols, elemCntPerRow) + 10.0f * readImage2Df_C4(ptrI, x + 1, y, rows, cols, elemCntPerRow) + 3.0f * readImage2Df_C4(ptrI, x + 1, y + 1, rows, cols, elemCntPerRow) -\n"
"(3.0f * readImage2Df_C4(ptrI, x - 1, y - 1, rows, cols, elemCntPerRow) + 10.0f * readImage2Df_C4(ptrI, x - 1, y, rows, cols, elemCntPerRow) + 3.0f * readImage2Df_C4(ptrI, x - 1, y + 1, rows, cols, elemCntPerRow));\n"
"float4 dIdy = 3.0f * readImage2Df_C4(ptrI, x - 1, y + 1, rows, cols, elemCntPerRow) + 10.0f * readImage2Df_C4(ptrI, x, y + 1, rows, cols, elemCntPerRow) + 3.0f * readImage2Df_C4(ptrI, x + 1, y + 1, rows, cols, elemCntPerRow) -\n"
"(3.0f * readImage2Df_C4(ptrI, x - 1, y - 1, rows, cols, elemCntPerRow) + 10.0f * readImage2Df_C4(ptrI, x, y - 1, rows, cols, elemCntPerRow) + 3.0f * readImage2Df_C4(ptrI, x + 1, y - 1, rows, cols, elemCntPerRow));\n"
"dIdx_patch[i][j] = dIdx;\n"
"dIdy_patch[i][j] = dIdy;\n"
"A11 += (dIdx * dIdx).x + (dIdx * dIdx).y + (dIdx * dIdx).z;\n"
"A12 += (dIdx * dIdy).x + (dIdx * dIdy).y + (dIdx * dIdy).z;\n"
"A22 += (dIdy * dIdy).x + (dIdy * dIdy).y + (dIdy * dIdy).z;\n"
"}\n"
"}\n"
"reduce3(A11, A12, A22, smem1, smem2, smem3, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"A11 = smem1[0];\n"
"A12 = smem2[0];\n"
"A22 = smem3[0];\n"
"float D = A11 * A22 - A12 * A12;\n"
"if (D < 1.192092896e-07f)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"{\n"
"status[get_group_id(0)] = 0;\n"
"}\n"
"return;\n"
"}\n"
"D = 1.f / D;\n"
"A11 *= D;\n"
"A12 *= D;\n"
"A22 *= D;\n"
"float2 nextPt = nextPts[get_group_id(0)];\n"
"nextPt = nextPt * 2.0f - c_halfWin;\n"
"__global float4 *ptrJ = (__global float4 *)J;\n"
"for (int k = 0; k < c_iters; ++k)\n"
"{\n"
"if (nextPt.x < -c_halfWin.x || nextPt.x >= cols || nextPt.y < -c_halfWin.y || nextPt.y >= rows)\n"
"{\n"
"if (tid == 0 && level == 0)\n"
"{\n"
"status[get_group_id(0)] = 0;\n"
"}\n"
"return;\n"
"}\n"
"float b1 = 0;\n"
"float b2 = 0;\n"
"for (int y = get_local_id(1), i = 0; y < c_winSize_y; y += get_local_size(1), ++i)\n"
"{\n"
"for (int x = get_local_id(0), j = 0; x < c_winSize_x; x += get_local_size(0), ++j)\n"
"{\n"
"float4 diff = (readImage2Df_C4(ptrJ, nextPt.x + x, nextPt.y + y, rows, cols, elemCntPerRow) - I_patch[i][j]) * 32.0f;\n"
"b1 += (diff * dIdx_patch[i][j]).x + (diff * dIdx_patch[i][j]).y + (diff * dIdx_patch[i][j]).z;\n"
"b2 += (diff * dIdy_patch[i][j]).x + (diff * dIdy_patch[i][j]).y + (diff * dIdy_patch[i][j]).z;\n"
"}\n"
"}\n"
"reduce2(b1, b2, smem1, smem2, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"b1 = smem1[0];\n"
"b2 = smem2[0];\n"
"float2 delta;\n"
"delta.x = A12 * b2 - A22 * b1;\n"
"delta.y = A12 * b1 - A11 * b2;\n"
"nextPt += delta;\n"
"}\n"
"float errval = 0.0f;\n"
"if (calcErr)\n"
"{\n"
"for (int y = get_local_id(1), i = 0; y < c_winSize_y; y += get_local_size(1), ++i)\n"
"{\n"
"for (int x = get_local_id(0), j = 0; x < c_winSize_x; x += get_local_size(0), ++j)\n"
"{\n"
"float4 diff = readImage2Df_C4(ptrJ, nextPt.x + x, nextPt.y + y, rows, cols, elemCntPerRow) - I_patch[i][j];\n"
"errval += fabs(diff.x) + fabs(diff.y) + fabs(diff.z);\n"
"}\n"
"}\n"
"reduce1(errval, smem1, tid);\n"
"}\n"
"if (tid == 0)\n"
"{\n"
"nextPt += c_halfWin;\n"
"nextPts[get_group_id(0)] = nextPt;\n"
"if (calcErr)\n"
"{\n"
"err[get_group_id(0)] = smem1[0] / (3 * c_winSize_x * c_winSize_y);\n"
"}\n"
"}\n"
"}\n"
"int readImage2Di_C1(__global const int *image, float2 coor,  int2 size, const int elemCntPerRow)\n"
"{\n"
"int i = clamp((int)floor(coor.x), 0, size.x - 1);\n"
"int j = clamp((int)floor(coor.y), 0, size.y - 1);\n"
"return image[mad24(j, elemCntPerRow, i)];\n"
"}\n"
"__kernel void lkDense_C1_D0(__global const int *I, __global const int *J, __global float *u, int uStep, __global float *v, int vStep, __global const float *prevU, int prevUStep, __global const float *prevV, int prevVStep,\n"
"const int rows, const int cols, \n"
"const int elemCntPerRow, int c_winSize_x, int c_winSize_y, int c_iters, char calcErr)\n"
"{\n"
"int c_halfWin_x = (c_winSize_x - 1) / 2;\n"
"int c_halfWin_y = (c_winSize_y - 1) / 2;\n"
"const int patchWidth  = get_local_size(0) + 2 * c_halfWin_x;\n"
"const int patchHeight = get_local_size(1) + 2 * c_halfWin_y;\n"
"__local int smem[8192];\n"
"__local int *I_patch = smem;\n"
"__local int *dIdx_patch = I_patch + patchWidth * patchHeight;\n"
"__local int *dIdy_patch = dIdx_patch + patchWidth * patchHeight;\n"
"const int xBase = get_group_id(0) * get_local_size(0);\n"
"const int yBase = get_group_id(1) * get_local_size(1);\n"
"int2 size = (int2)(cols, rows);\n"
"for (int i = get_local_id(1); i < patchHeight; i += get_local_size(1))\n"
"{\n"
"for (int j = get_local_id(0); j < patchWidth; j += get_local_size(0))\n"
"{\n"
"float x = xBase - c_halfWin_x + j + 0.5f;\n"
"float y = yBase - c_halfWin_y + i + 0.5f;\n"
"I_patch[i * patchWidth + j] = readImage2Di_C1(I, (float2)(x, y), size, elemCntPerRow);\n"
"dIdx_patch[i * patchWidth + j] = 3 * readImage2Di_C1(I, (float2)(x + 1, y - 1), size, elemCntPerRow) + 10 * readImage2Di_C1(I, (float2)(x + 1, y), size, elemCntPerRow) + 3 * readImage2Di_C1(I, (float2)(x + 1, y + 1), size, elemCntPerRow) -\n"
"(3 * readImage2Di_C1(I, (float2)(x - 1, y - 1), size, elemCntPerRow) + 10 * readImage2Di_C1(I, (float2)(x - 1, y), size, elemCntPerRow) + 3 * readImage2Di_C1(I, (float2)(x - 1, y + 1), size, elemCntPerRow));\n"
"dIdy_patch[i * patchWidth + j] = 3 * readImage2Di_C1(I, (float2)(x - 1, y + 1), size, elemCntPerRow) + 10 * readImage2Di_C1(I, (float2)(x, y + 1), size, elemCntPerRow) + 3 * readImage2Di_C1(I, (float2)(x + 1, y + 1), size, elemCntPerRow) -\n"
"(3 * readImage2Di_C1(I, (float2)(x - 1, y - 1), size, elemCntPerRow) + 10 * readImage2Di_C1(I, (float2)(x, y - 1), size, elemCntPerRow) + 3 * readImage2Di_C1(I, (float2)(x + 1, y - 1), size, elemCntPerRow));\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (x >= cols || y >= rows)\n"
"{\n"
"return;\n"
"}\n"
"int A11i = 0;\n"
"int A12i = 0;\n"
"int A22i = 0;\n"
"for (int i = 0; i < c_winSize_y; ++i)\n"
"{\n"
"for (int j = 0; j < c_winSize_x; ++j)\n"
"{\n"
"int dIdx = dIdx_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\n"
"int dIdy = dIdy_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\n"
"A11i += dIdx * dIdx;\n"
"A12i += dIdx * dIdy;\n"
"A22i += dIdy * dIdy;\n"
"}\n"
"}\n"
"float A11 = A11i;\n"
"float A12 = A12i;\n"
"float A22 = A22i;\n"
"float D = A11 * A22 - A12 * A12;\n"
"if (D < 1.192092896e-07f)\n"
"{\n"
"return;\n"
"}\n"
"D = 1.f / D;\n"
"A11 *= D;\n"
"A12 *= D;\n"
"A22 *= D;\n"
"float2 nextPt;\n"
"nextPt.x = x + prevU[y / 2 * prevUStep / 4 + x / 2] * 2.0f;\n"
"nextPt.y = y + prevV[y / 2 * prevVStep / 4 + x / 2] * 2.0f;\n"
"for (int k = 0; k < c_iters; ++k)\n"
"{\n"
"if (nextPt.x < 0 || nextPt.x >= cols || nextPt.y < 0 || nextPt.y >= rows)\n"
"{\n"
"return;\n"
"}\n"
"int b1 = 0;\n"
"int b2 = 0;\n"
"for (int i = 0; i < c_winSize_y; ++i)\n"
"{\n"
"for (int j = 0; j < c_winSize_x; ++j)\n"
"{\n"
"int iI = I_patch[(get_local_id(1) + i) * patchWidth + get_local_id(0) + j];\n"
"int iJ = readImage2Di_C1(J, (float2)(nextPt.x - c_halfWin_x + j + 0.5f, nextPt.y - c_halfWin_y + i + 0.5f), size, elemCntPerRow);\n"
"int diff = (iJ - iI) * 32;\n"
"int dIdx = dIdx_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\n"
"int dIdy = dIdy_patch[(get_local_id(1) + i) * patchWidth + (get_local_id(0) + j)];\n"
"b1 += diff * dIdx;\n"
"b2 += diff * dIdy;\n"
"}\n"
"}\n"
"float2 delta;\n"
"delta.x = A12 * b2 - A22 * b1;\n"
"delta.y = A12 * b1 - A11 * b2;\n"
"nextPt.x += delta.x;\n"
"nextPt.y += delta.y;\n"
"if (fabs(delta.x) < 0.01f && fabs(delta.y) < 0.01f)\n"
"{\n"
"break;\n"
"}\n"
"}\n"
"u[y * uStep / 4 + x] = nextPt.x - x;\n"
"v[y * vStep / 4 + x] = nextPt.y - y;\n"
"if (calcErr)\n"
"{\n"
"int errval = 0;\n"
"for (int i = 0; i < c_winSize_y; ++i)\n"
"{\n"
"for (int j = 0; j < c_winSize_x; ++j)\n"
"{\n"
"int iI = I_patch[(get_local_id(1) + i) * patchWidth + get_local_id(0) + j];\n"
"int iJ = readImage2Di_C1(J, (float2)(nextPt.x - c_halfWin_x + j + 0.5f, nextPt.y - c_halfWin_y + i + 0.5f), size, elemCntPerRow);\n"
"errval += abs(iJ - iI);\n"
"}\n"
"}\n"
"}\n"
"}\n"
;
const char* split_mat="#if defined (DOUBLE_SUPPORT)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"__kernel void split_vector_C4_D0 (__global uchar *mat_src,  int src_step,  int src_offset,\n"
"__global uchar *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global uchar *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global uchar *mat_dst2, int dst2_step, int dst2_offset,\n"
"__global uchar *mat_dst3, int dst3_step, int dst3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 2;\n"
"int src_idx  = mad24(y, src_step, src_offset + (x << 2));\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + x) & (int)0xfffffffc;\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + x) & (int)0xfffffffc;\n"
"int dst2_start = mad24(y, dst2_step, dst2_offset);\n"
"int dst2_end   = mad24(y, dst2_step, dst2_offset + dst_step1);\n"
"int dst2_idx   = mad24(y, dst2_step, dst2_offset + x) & (int)0xfffffffc;\n"
"int dst3_start = mad24(y, dst3_step, dst3_offset);\n"
"int dst3_end   = mad24(y, dst3_step, dst3_offset + dst_step1);\n"
"int dst3_idx   = mad24(y, dst3_step, dst3_offset + x) & (int)0xfffffffc;\n"
"uchar4 data_0 = *((global uchar4 *)(mat_src + (src_idx - 12 >= 0 ? src_idx - 12 : src_idx)));\n"
"uchar4 data_1 = *((global uchar4 *)(mat_src + (src_idx - 8  >= 0 ? src_idx - 8  : src_idx)));\n"
"uchar4 data_2 = *((global uchar4 *)(mat_src + (src_idx - 4  >= 0 ? src_idx - 4  : src_idx)));\n"
"uchar4 data_3 = *((global uchar4 *)(mat_src + src_idx + 0 ));\n"
"int total_bytes = src_offset + rows * src_step;\n"
"uchar4 data_4 = *((global uchar4 *)(mat_src + (src_idx + 4  < total_bytes ? src_idx + 4  : src_idx)));\n"
"uchar4 data_5 = *((global uchar4 *)(mat_src + (src_idx + 8  < total_bytes ? src_idx + 8  : src_idx)));\n"
"uchar4 data_6 = *((global uchar4 *)(mat_src + (src_idx + 12 < total_bytes ? src_idx + 12 : src_idx)));\n"
"uchar4 tmp_data0=1, tmp_data1=2, tmp_data2, tmp_data3;\n"
"if((dst0_offset & 3) == 3)\n"
"tmp_data0 = (uchar4)(data_0.x, data_1.x, data_2.x, data_3.x);\n"
"if((dst0_offset & 3) == 2)\n"
"tmp_data0 = (uchar4)(data_1.x, data_2.x, data_3.x, data_4.x);\n"
"if((dst0_offset & 3) == 1)\n"
"tmp_data0 = (uchar4)(data_2.x, data_3.x, data_4.x, data_5.x);\n"
"if((dst0_offset & 3) == 0)\n"
"tmp_data0 = (uchar4)(data_3.x, data_4.x, data_5.x, data_6.x);\n"
"if((dst1_offset & 3) == 3)\n"
"tmp_data1 = (uchar4)(data_0.y, data_1.y, data_2.y, data_3.y);\n"
"if((dst1_offset & 3) == 2)\n"
"tmp_data1 = (uchar4)(data_1.y, data_2.y, data_3.y, data_4.y);\n"
"if((dst1_offset & 3) == 1)\n"
"tmp_data1 = (uchar4)(data_2.y, data_3.y, data_4.y, data_5.y);\n"
"if((dst1_offset & 3) == 0)\n"
"tmp_data1 = (uchar4)(data_3.y, data_4.y, data_5.y, data_6.y);\n"
"if((dst2_offset & 3) == 3)\n"
"tmp_data2 = (uchar4)(data_0.z, data_1.z, data_2.z, data_3.z);\n"
"if((dst2_offset & 3) == 2)\n"
"tmp_data2 = (uchar4)(data_1.z, data_2.z, data_3.z, data_4.z);\n"
"if((dst2_offset & 3) == 1)\n"
"tmp_data2 = (uchar4)(data_2.z, data_3.z, data_4.z, data_5.z);\n"
"if((dst2_offset & 3) == 0)\n"
"tmp_data2 = (uchar4)(data_3.z, data_4.z, data_5.z, data_6.z);\n"
"if((dst3_offset & 3) == 3)\n"
"tmp_data3 = (uchar4)(data_0.w, data_1.w, data_2.w, data_3.w);\n"
"if((dst3_offset & 3) == 2)\n"
"tmp_data3 = (uchar4)(data_1.w, data_2.w, data_3.w, data_4.w);\n"
"if((dst3_offset & 3) == 1)\n"
"tmp_data3 = (uchar4)(data_2.w, data_3.w, data_4.w, data_5.w);\n"
"if((dst3_offset & 3) == 0)\n"
"tmp_data3 = (uchar4)(data_3.w, data_4.w, data_5.w, data_6.w);\n"
"uchar4 dst0_data  = *((__global uchar4 *)(mat_dst0 + dst0_idx));\n"
"uchar4 dst1_data  = *((__global uchar4 *)(mat_dst1 + dst1_idx));\n"
"uchar4 dst2_data  = *((__global uchar4 *)(mat_dst2 + dst2_idx));\n"
"uchar4 dst3_data  = *((__global uchar4 *)(mat_dst3 + dst3_idx));\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? tmp_data0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 1 >= dst0_start) && (dst0_idx + 1 < dst0_end)) ? tmp_data0.y : dst0_data.y;\n"
"tmp_data0.z = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? tmp_data0.z : dst0_data.z;\n"
"tmp_data0.w = ((dst0_idx + 3 >= dst0_start) && (dst0_idx + 3 < dst0_end)) ? tmp_data0.w : dst0_data.w;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? tmp_data1.x : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 1 >= dst1_start) && (dst1_idx + 1 < dst1_end)) ? tmp_data1.y : dst1_data.y;\n"
"tmp_data1.z = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? tmp_data1.z : dst1_data.z;\n"
"tmp_data1.w = ((dst1_idx + 3 >= dst1_start) && (dst1_idx + 3 < dst1_end)) ? tmp_data1.w : dst1_data.w;\n"
"tmp_data2.x = ((dst2_idx + 0 >= dst2_start) && (dst2_idx + 0 < dst2_end)) ? tmp_data2.x : dst2_data.x;\n"
"tmp_data2.y = ((dst2_idx + 1 >= dst2_start) && (dst2_idx + 1 < dst2_end)) ? tmp_data2.y : dst2_data.y;\n"
"tmp_data2.z = ((dst2_idx + 2 >= dst2_start) && (dst2_idx + 2 < dst2_end)) ? tmp_data2.z : dst2_data.z;\n"
"tmp_data2.w = ((dst2_idx + 3 >= dst2_start) && (dst2_idx + 3 < dst2_end)) ? tmp_data2.w : dst2_data.w;\n"
"tmp_data3.x = ((dst3_idx + 0 >= dst3_start) && (dst3_idx + 0 < dst3_end)) ? tmp_data3.x : dst3_data.x;\n"
"tmp_data3.y = ((dst3_idx + 1 >= dst3_start) && (dst3_idx + 1 < dst3_end)) ? tmp_data3.y : dst3_data.y;\n"
"tmp_data3.z = ((dst3_idx + 2 >= dst3_start) && (dst3_idx + 2 < dst3_end)) ? tmp_data3.z : dst3_data.z;\n"
"tmp_data3.w = ((dst3_idx + 3 >= dst3_start) && (dst3_idx + 3 < dst3_end)) ? tmp_data3.w : dst3_data.w;\n"
"*((__global uchar4 *)(mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((__global uchar4 *)(mat_dst1 + dst1_idx)) = tmp_data1;\n"
"*((__global uchar4 *)(mat_dst2 + dst2_idx)) = tmp_data2;\n"
"*((__global uchar4 *)(mat_dst3 + dst3_idx)) = tmp_data3;\n"
"}\n"
"}\n"
"__kernel void split_vector_C3_D0 (__global uchar *mat_src,  int src_step,  int src_offset,\n"
"__global uchar *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global uchar *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global uchar *mat_dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 2;\n"
"int src_idx  = mad24(y, src_step, src_offset);\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + x & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + x  & (int)0xfffffffc);\n"
"int dst2_start = mad24(y, dst2_step, dst2_offset);\n"
"int dst2_end   = mad24(y, dst2_step, dst2_offset + dst_step1);\n"
"int dst2_idx   = mad24(y, dst2_step, dst2_offset + x & (int)0xfffffffc);\n"
"uchar4 dst0_data  = *((__global uchar4 *)(mat_dst0 + dst0_idx));\n"
"uchar4 dst1_data  = *((__global uchar4 *)(mat_dst1 + dst1_idx));\n"
"uchar4 dst2_data  = *((__global uchar4 *)(mat_dst2 + dst2_idx));\n"
"uchar4 tmp_data0, tmp_data1, tmp_data2;\n"
"uchar src_data_0  =  *(mat_src + src_idx + 3 * x - 9);\n"
"uchar src_data_1  =  *(mat_src + src_idx + 3 * x - 8);\n"
"uchar src_data_2  =  *(mat_src + src_idx + 3 * x - 7);\n"
"uchar src_data_3  =  *(mat_src + src_idx + 3 * x - 6);\n"
"uchar src_data_4  =  *(mat_src + src_idx + 3 * x - 5);\n"
"uchar src_data_5  =  *(mat_src + src_idx + 3 * x - 4);\n"
"uchar src_data_6  =  *(mat_src + src_idx + 3 * x - 3);\n"
"uchar src_data_7  =  *(mat_src + src_idx + 3 * x - 2);\n"
"uchar src_data_8  =  *(mat_src + src_idx + 3 * x - 1);\n"
"uchar src_data_9  =  *(mat_src + src_idx + 3 * x + 0);\n"
"uchar src_data_10 =  *(mat_src + src_idx + 3 * x + 1);\n"
"uchar src_data_11 =  *(mat_src + src_idx + 3 * x + 2);\n"
"uchar src_data_12 =  *(mat_src + src_idx + 3 * x + 3);\n"
"uchar src_data_13 =  *(mat_src + src_idx + 3 * x + 4);\n"
"uchar src_data_14 =  *(mat_src + src_idx + 3 * x + 5);\n"
"uchar src_data_15 =  *(mat_src + src_idx + 3 * x + 6);\n"
"uchar src_data_16 =  *(mat_src + src_idx + 3 * x + 7);\n"
"uchar src_data_17 =  *(mat_src + src_idx + 3 * x + 8);\n"
"uchar src_data_18 =  *(mat_src + src_idx + 3 * x + 9);\n"
"uchar src_data_19 =  *(mat_src + src_idx + 3 * x + 10);\n"
"uchar src_data_20 =  *(mat_src + src_idx + 3 * x + 11);\n"
"uchar data[7] = {src_data_0, src_data_3, src_data_6, src_data_9, src_data_12, src_data_15, src_data_18};\n"
"int index = 3 - dst0_offset & 3;\n"
"tmp_data0 = (uchar4)(data[index], data[index + 1], data[index + 2], data[index + 3]);\n"
"uchar4 data0, data1, data2;\n"
"data0     = (uchar4)(src_data_1, src_data_4, src_data_7, src_data_10);\n"
"data1     = (dst1_offset & 3) == 2 ? (uchar4)(src_data_4, src_data_7, src_data_10, src_data_13)  : data0;\n"
"data2     = (dst1_offset & 3) == 1 ? (uchar4)(src_data_7, src_data_10, src_data_13, src_data_16) : data1;\n"
"tmp_data1 = (dst1_offset & 3) == 0 ? (uchar4)(src_data_10, src_data_13, src_data_16, src_data_19): data2;\n"
"data0     = (uchar4)(src_data_2, src_data_5, src_data_8, src_data_11);\n"
"data1     = (dst2_offset & 3) == 2 ? (uchar4)(src_data_5, src_data_8, src_data_11, src_data_14)   : data0;\n"
"data2     = (dst2_offset & 3) == 1 ? (uchar4)(src_data_8, src_data_11, src_data_14, src_data_17)  : data1;\n"
"tmp_data2 = (dst2_offset & 3) == 0 ? (uchar4)(src_data_11, src_data_14, src_data_17, src_data_20) : data2;\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? tmp_data0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 1 >= dst0_start) && (dst0_idx + 1 < dst0_end)) ? tmp_data0.y : dst0_data.y;\n"
"tmp_data0.z = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? tmp_data0.z : dst0_data.z;\n"
"tmp_data0.w = ((dst0_idx + 3 >= dst0_start) && (dst0_idx + 3 < dst0_end)) ? tmp_data0.w : dst0_data.w;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? tmp_data1.x : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 1 >= dst1_start) && (dst1_idx + 1 < dst1_end)) ? tmp_data1.y : dst1_data.y;\n"
"tmp_data1.z = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? tmp_data1.z : dst1_data.z;\n"
"tmp_data1.w = ((dst1_idx + 3 >= dst1_start) && (dst1_idx + 3 < dst1_end)) ? tmp_data1.w : dst1_data.w;\n"
"tmp_data2.x = ((dst2_idx + 0 >= dst2_start) && (dst2_idx + 0 < dst2_end)) ? tmp_data2.x : dst2_data.x;\n"
"tmp_data2.y = ((dst2_idx + 1 >= dst2_start) && (dst2_idx + 1 < dst2_end)) ? tmp_data2.y : dst2_data.y;\n"
"tmp_data2.z = ((dst2_idx + 2 >= dst2_start) && (dst2_idx + 2 < dst2_end)) ? tmp_data2.z : dst2_data.z;\n"
"tmp_data2.w = ((dst2_idx + 3 >= dst2_start) && (dst2_idx + 3 < dst2_end)) ? tmp_data2.w : dst2_data.w;\n"
"*((__global uchar4 *)(mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((__global uchar4 *)(mat_dst1 + dst1_idx)) = tmp_data1;\n"
"*((__global uchar4 *)(mat_dst2 + dst2_idx)) = tmp_data2;\n"
"}\n"
"}\n"
"__kernel void split_vector_C2_D0 (__global uchar *mat_src,  int src_step,  int src_offset,\n"
"__global uchar *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global uchar *mat_dst1, int dst1_step, int dst1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 2;\n"
"#define dst0_align ((dst0_offset & 3) << 1)\n"
"#define dst1_align ((dst1_offset & 3) << 1)\n"
"int src_idx_0  = mad24(y, src_step, src_offset - dst0_align + (x << 1));\n"
"int src_idx_1  = mad24(y, src_step, src_offset - dst1_align + (x << 1));\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + x & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src_idx_0 < 0 ? 0 : src_idx_0;\n"
"int src2_index_fix = src_idx_1 < 0 ? 0 : src_idx_1;\n"
"uchar8 src_data_0 = vload8(0, mat_src + src_idx_0);\n"
"uchar8 src_data_1 = vload8(0, mat_src + src_idx_1);\n"
"if(src_idx_0 == -6)\n"
"src_data_0.s01234567 = src_data_0.s67012345;\n"
"if(src_idx_0 == -4)\n"
"src_data_0.s01234567 = src_data_0.s45670123;\n"
"if(src_idx_0 == -2)\n"
"src_data_0.s01234567 = src_data_0.s23456701;\n"
"if(src_idx_1 == -6)\n"
"src_data_1.s01234567 = src_data_1.s67012345;\n"
"if(src_idx_1 == -4)\n"
"src_data_1.s01234567 = src_data_1.s45670123;\n"
"if(src_idx_1 == -2)\n"
"src_data_1.s01234567 = src_data_1.s23456701;\n"
"uchar4 dst0_data  = *((__global uchar4 *)(mat_dst0 + dst0_idx));\n"
"uchar4 dst1_data  = *((__global uchar4 *)(mat_dst1 + dst1_idx));\n"
"uchar4 tmp_data0, tmp_data1;\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? src_data_0.s0 : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 1 >= dst0_start) && (dst0_idx + 1 < dst0_end)) ? src_data_0.s2 : dst0_data.y;\n"
"tmp_data0.z = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? src_data_0.s4 : dst0_data.z;\n"
"tmp_data0.w = ((dst0_idx + 3 >= dst0_start) && (dst0_idx + 3 < dst0_end)) ? src_data_0.s6 : dst0_data.w;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? src_data_1.s1 : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 1 >= dst1_start) && (dst1_idx + 1 < dst1_end)) ? src_data_1.s3 : dst1_data.y;\n"
"tmp_data1.z = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? src_data_1.s5 : dst1_data.z;\n"
"tmp_data1.w = ((dst1_idx + 3 >= dst1_start) && (dst1_idx + 3 < dst1_end)) ? src_data_1.s7 : dst1_data.w;\n"
"*((__global uchar4 *)(mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((__global uchar4 *)(mat_dst1 + dst1_idx)) = tmp_data1;\n"
"}\n"
"}\n"
"__kernel void split_vector_C4_D1 (__global char *mat_src,  int src_step,  int src_offset,\n"
"__global char *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global char *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global char *mat_dst2, int dst2_step, int dst2_offset,\n"
"__global char *mat_dst3, int dst3_step, int dst3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 2;\n"
"int src_idx  = mad24(y, src_step, src_offset + (x << 2));\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + x & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + x & (int)0xfffffffc);\n"
"int dst2_start = mad24(y, dst2_step, dst2_offset);\n"
"int dst2_end   = mad24(y, dst2_step, dst2_offset + dst_step1);\n"
"int dst2_idx   = mad24(y, dst2_step, dst2_offset + x & (int)0xfffffffc);\n"
"int dst3_start = mad24(y, dst3_step, dst3_offset);\n"
"int dst3_end   = mad24(y, dst3_step, dst3_offset + dst_step1);\n"
"int dst3_idx   = mad24(y, dst3_step, dst3_offset + x & (int)0xfffffffc);\n"
"char4 data_0 = *((global char4 *)(mat_src + src_idx - 12));\n"
"char4 data_1 = *((global char4 *)(mat_src + src_idx - 8 ));\n"
"char4 data_2 = *((global char4 *)(mat_src + src_idx - 4 ));\n"
"char4 data_3 = *((global char4 *)(mat_src + src_idx + 0 ));\n"
"char4 data_4 = *((global char4 *)(mat_src + src_idx + 4 ));\n"
"char4 data_5 = *((global char4 *)(mat_src + src_idx + 8 ));\n"
"char4 data_6 = *((global char4 *)(mat_src + src_idx + 12));\n"
"char4 tmp_data0=1, tmp_data1=2, tmp_data2, tmp_data3;\n"
"if((dst0_offset & 3) == 3)\n"
"tmp_data0 = (char4)(data_0.x, data_1.x, data_2.x, data_3.x);\n"
"if((dst0_offset & 3) == 2)\n"
"tmp_data0 = (char4)(data_1.x, data_2.x, data_3.x, data_4.x);\n"
"if((dst0_offset & 3) == 1)\n"
"tmp_data0 = (char4)(data_2.x, data_3.x, data_4.x, data_5.x);\n"
"if((dst0_offset & 3) == 0)\n"
"tmp_data0 = (char4)(data_3.x, data_4.x, data_5.x, data_6.x);\n"
"if((dst1_offset & 3) == 3)\n"
"tmp_data1 = (char4)(data_0.y, data_1.y, data_2.y, data_3.y);\n"
"if((dst1_offset & 3) == 2)\n"
"tmp_data1 = (char4)(data_1.y, data_2.y, data_3.y, data_4.y);\n"
"if((dst1_offset & 3) == 1)\n"
"tmp_data1 = (char4)(data_2.y, data_3.y, data_4.y, data_5.y);\n"
"if((dst1_offset & 3) == 0)\n"
"tmp_data1 = (char4)(data_3.y, data_4.y, data_5.y, data_6.y);\n"
"if((dst2_offset & 3) == 3)\n"
"tmp_data2 = (char4)(data_0.z, data_1.z, data_2.z, data_3.z);\n"
"if((dst2_offset & 3) == 2)\n"
"tmp_data2 = (char4)(data_1.z, data_2.z, data_3.z, data_4.z);\n"
"if((dst2_offset & 3) == 1)\n"
"tmp_data2 = (char4)(data_2.z, data_3.z, data_4.z, data_5.z);\n"
"if((dst2_offset & 3) == 0)\n"
"tmp_data2 = (char4)(data_3.z, data_4.z, data_5.z, data_6.z);\n"
"if((dst3_offset & 3) == 3)\n"
"tmp_data3 = (char4)(data_0.w, data_1.w, data_2.w, data_3.w);\n"
"if((dst3_offset & 3) == 2)\n"
"tmp_data3 = (char4)(data_1.w, data_2.w, data_3.w, data_4.w);\n"
"if((dst3_offset & 3) == 1)\n"
"tmp_data3 = (char4)(data_2.w, data_3.w, data_4.w, data_5.w);\n"
"if((dst3_offset & 3) == 0)\n"
"tmp_data3 = (char4)(data_3.w, data_4.w, data_5.w, data_6.w);\n"
"char4 dst0_data  = *((__global char4 *)(mat_dst0 + dst0_idx));\n"
"char4 dst1_data  = *((__global char4 *)(mat_dst1 + dst1_idx));\n"
"char4 dst2_data  = *((__global char4 *)(mat_dst2 + dst2_idx));\n"
"char4 dst3_data  = *((__global char4 *)(mat_dst3 + dst3_idx));\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? tmp_data0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 1 >= dst0_start) && (dst0_idx + 1 < dst0_end)) ? tmp_data0.y : dst0_data.y;\n"
"tmp_data0.z = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? tmp_data0.z : dst0_data.z;\n"
"tmp_data0.w = ((dst0_idx + 3 >= dst0_start) && (dst0_idx + 3 < dst0_end)) ? tmp_data0.w : dst0_data.w;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? tmp_data1.x : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 1 >= dst1_start) && (dst1_idx + 1 < dst1_end)) ? tmp_data1.y : dst1_data.y;\n"
"tmp_data1.z = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? tmp_data1.z : dst1_data.z;\n"
"tmp_data1.w = ((dst1_idx + 3 >= dst1_start) && (dst1_idx + 3 < dst1_end)) ? tmp_data1.w : dst1_data.w;\n"
"tmp_data2.x = ((dst2_idx + 0 >= dst2_start) && (dst2_idx + 0 < dst2_end)) ? tmp_data2.x : dst2_data.x;\n"
"tmp_data2.y = ((dst2_idx + 1 >= dst2_start) && (dst2_idx + 1 < dst2_end)) ? tmp_data2.y : dst2_data.y;\n"
"tmp_data2.z = ((dst2_idx + 2 >= dst2_start) && (dst2_idx + 2 < dst2_end)) ? tmp_data2.z : dst2_data.z;\n"
"tmp_data2.w = ((dst2_idx + 3 >= dst2_start) && (dst2_idx + 3 < dst2_end)) ? tmp_data2.w : dst2_data.w;\n"
"tmp_data3.x = ((dst3_idx + 0 >= dst3_start) && (dst3_idx + 0 < dst3_end)) ? tmp_data3.x : dst3_data.x;\n"
"tmp_data3.y = ((dst3_idx + 1 >= dst3_start) && (dst3_idx + 1 < dst3_end)) ? tmp_data3.y : dst3_data.y;\n"
"tmp_data3.z = ((dst3_idx + 2 >= dst3_start) && (dst3_idx + 2 < dst3_end)) ? tmp_data3.z : dst3_data.z;\n"
"tmp_data3.w = ((dst3_idx + 3 >= dst3_start) && (dst3_idx + 3 < dst3_end)) ? tmp_data3.w : dst3_data.w;\n"
"*((__global char4 *)(mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((__global char4 *)(mat_dst1 + dst1_idx)) = tmp_data1;\n"
"*((__global char4 *)(mat_dst2 + dst2_idx)) = tmp_data2;\n"
"*((__global char4 *)(mat_dst3 + dst3_idx)) = tmp_data3;\n"
"}\n"
"}\n"
"__kernel void split_vector_C3_D1 (__global char *mat_src,  int src_step,  int src_offset,\n"
"__global char *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global char *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global char *mat_dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 2;\n"
"int src_idx  = mad24(y, src_step, src_offset);\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + x & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + x  & (int)0xfffffffc);\n"
"int dst2_start = mad24(y, dst2_step, dst2_offset);\n"
"int dst2_end   = mad24(y, dst2_step, dst2_offset + dst_step1);\n"
"int dst2_idx   = mad24(y, dst2_step, dst2_offset + x & (int)0xfffffffc);\n"
"char4 dst0_data  = *((__global char4 *)(mat_dst0 + dst0_idx));\n"
"char4 dst1_data  = *((__global char4 *)(mat_dst1 + dst1_idx));\n"
"char4 dst2_data  = *((__global char4 *)(mat_dst2 + dst2_idx));\n"
"char4 tmp_data0, tmp_data1, tmp_data2;\n"
"char src_data_0  =  *(mat_src + src_idx + 3 * x - 9);\n"
"char src_data_1  =  *(mat_src + src_idx + 3 * x - 8);\n"
"char src_data_2  =  *(mat_src + src_idx + 3 * x - 7);\n"
"char src_data_3  =  *(mat_src + src_idx + 3 * x - 6);\n"
"char src_data_4  =  *(mat_src + src_idx + 3 * x - 5);\n"
"char src_data_5  =  *(mat_src + src_idx + 3 * x - 4);\n"
"char src_data_6  =  *(mat_src + src_idx + 3 * x - 3);\n"
"char src_data_7  =  *(mat_src + src_idx + 3 * x - 2);\n"
"char src_data_8  =  *(mat_src + src_idx + 3 * x - 1);\n"
"char src_data_9  =  *(mat_src + src_idx + 3 * x + 0);\n"
"char src_data_10 =  *(mat_src + src_idx + 3 * x + 1);\n"
"char src_data_11 =  *(mat_src + src_idx + 3 * x + 2);\n"
"char src_data_12 =  *(mat_src + src_idx + 3 * x + 3);\n"
"char src_data_13 =  *(mat_src + src_idx + 3 * x + 4);\n"
"char src_data_14 =  *(mat_src + src_idx + 3 * x + 5);\n"
"char src_data_15 =  *(mat_src + src_idx + 3 * x + 6);\n"
"char src_data_16 =  *(mat_src + src_idx + 3 * x + 7);\n"
"char src_data_17 =  *(mat_src + src_idx + 3 * x + 8);\n"
"char src_data_18 =  *(mat_src + src_idx + 3 * x + 9);\n"
"char src_data_19 =  *(mat_src + src_idx + 3 * x + 10);\n"
"char src_data_20 =  *(mat_src + src_idx + 3 * x + 11);\n"
"char data[7] = {src_data_0, src_data_3, src_data_6, src_data_9, src_data_12, src_data_15, src_data_18};\n"
"int index = 3 - dst0_offset & 3;\n"
"tmp_data0 = (char4)(data[index], data[index + 1], data[index + 2], data[index + 3]);\n"
"char4 data0, data1, data2;\n"
"data0     = (char4)(src_data_1, src_data_4, src_data_7, src_data_10);\n"
"data1     = (dst1_offset & 3) == 2 ? (char4)(src_data_4, src_data_7, src_data_10, src_data_13)  : data0;\n"
"data2     = (dst1_offset & 3) == 1 ? (char4)(src_data_7, src_data_10, src_data_13, src_data_16) : data1;\n"
"tmp_data1 = (dst1_offset & 3) == 0 ? (char4)(src_data_10, src_data_13, src_data_16, src_data_19): data2;\n"
"data0     = (char4)(src_data_2, src_data_5, src_data_8, src_data_11);\n"
"data1     = (dst2_offset & 3) == 2 ? (char4)(src_data_5, src_data_8, src_data_11, src_data_14)   : data0;\n"
"data2     = (dst2_offset & 3) == 1 ? (char4)(src_data_8, src_data_11, src_data_14, src_data_17)  : data1;\n"
"tmp_data2 = (dst2_offset & 3) == 0 ? (char4)(src_data_11, src_data_14, src_data_17, src_data_20) : data2;\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? tmp_data0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 1 >= dst0_start) && (dst0_idx + 1 < dst0_end)) ? tmp_data0.y : dst0_data.y;\n"
"tmp_data0.z = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? tmp_data0.z : dst0_data.z;\n"
"tmp_data0.w = ((dst0_idx + 3 >= dst0_start) && (dst0_idx + 3 < dst0_end)) ? tmp_data0.w : dst0_data.w;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? tmp_data1.x : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 1 >= dst1_start) && (dst1_idx + 1 < dst1_end)) ? tmp_data1.y : dst1_data.y;\n"
"tmp_data1.z = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? tmp_data1.z : dst1_data.z;\n"
"tmp_data1.w = ((dst1_idx + 3 >= dst1_start) && (dst1_idx + 3 < dst1_end)) ? tmp_data1.w : dst1_data.w;\n"
"tmp_data2.x = ((dst2_idx + 0 >= dst2_start) && (dst2_idx + 0 < dst2_end)) ? tmp_data2.x : dst2_data.x;\n"
"tmp_data2.y = ((dst2_idx + 1 >= dst2_start) && (dst2_idx + 1 < dst2_end)) ? tmp_data2.y : dst2_data.y;\n"
"tmp_data2.z = ((dst2_idx + 2 >= dst2_start) && (dst2_idx + 2 < dst2_end)) ? tmp_data2.z : dst2_data.z;\n"
"tmp_data2.w = ((dst2_idx + 3 >= dst2_start) && (dst2_idx + 3 < dst2_end)) ? tmp_data2.w : dst2_data.w;\n"
"*((__global char4 *)(mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((__global char4 *)(mat_dst1 + dst1_idx)) = tmp_data1;\n"
"*((__global char4 *)(mat_dst2 + dst2_idx)) = tmp_data2;\n"
"}\n"
"}\n"
"__kernel void split_vector_C2_D1 (__global char *mat_src,  int src_step,  int src_offset,\n"
"__global char *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global char *mat_dst1, int dst1_step, int dst1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 2;\n"
"#define dst0_align ((dst0_offset & 3) << 1)\n"
"#define dst1_align ((dst1_offset & 3) << 1)\n"
"int src_idx_0  = mad24(y, src_step, src_offset - dst0_align + (x << 1));\n"
"int src_idx_1  = mad24(y, src_step, src_offset - dst1_align + (x << 1));\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + x & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + x & (int)0xfffffffc);\n"
"int src1_index_fix = src_idx_0 < 0 ? 0 : src_idx_0;\n"
"int src2_index_fix = src_idx_1 < 0 ? 0 : src_idx_1;\n"
"char8 src_data_0 = vload8(0, mat_src + src_idx_0);\n"
"char8 src_data_1 = vload8(0, mat_src + src_idx_1);\n"
"if(src_idx_0 == -6)\n"
"src_data_0.s01234567 = src_data_0.s67012345;\n"
"if(src_idx_0 == -4)\n"
"src_data_0.s01234567 = src_data_0.s45670123;\n"
"if(src_idx_0 == -2)\n"
"src_data_0.s01234567 = src_data_0.s23456701;\n"
"if(src_idx_1 == -6)\n"
"src_data_1.s01234567 = src_data_1.s67012345;\n"
"if(src_idx_1 == -4)\n"
"src_data_1.s01234567 = src_data_1.s45670123;\n"
"if(src_idx_1 == -2)\n"
"src_data_1.s01234567 = src_data_1.s23456701;\n"
"char4 dst0_data  = *((__global char4 *)(mat_dst0 + dst0_idx));\n"
"char4 dst1_data  = *((__global char4 *)(mat_dst1 + dst1_idx));\n"
"char4 tmp_data0, tmp_data1;\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? src_data_0.s0 : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 1 >= dst0_start) && (dst0_idx + 1 < dst0_end)) ? src_data_0.s2 : dst0_data.y;\n"
"tmp_data0.z = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? src_data_0.s4 : dst0_data.z;\n"
"tmp_data0.w = ((dst0_idx + 3 >= dst0_start) && (dst0_idx + 3 < dst0_end)) ? src_data_0.s6 : dst0_data.w;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? src_data_1.s1 : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 1 >= dst1_start) && (dst1_idx + 1 < dst1_end)) ? src_data_1.s3 : dst1_data.y;\n"
"tmp_data1.z = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? src_data_1.s5 : dst1_data.z;\n"
"tmp_data1.w = ((dst1_idx + 3 >= dst1_start) && (dst1_idx + 3 < dst1_end)) ? src_data_1.s7 : dst1_data.w;\n"
"*((__global char4 *)(mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((__global char4 *)(mat_dst1 + dst1_idx)) = tmp_data1;\n"
"}\n"
"}\n"
"__kernel void split_vector_C4_D2 (__global ushort *mat_src,  int src_step,  int src_offset,\n"
"__global ushort *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global ushort *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global ushort *mat_dst2, int dst2_step, int dst2_offset,\n"
"__global ushort *mat_dst3, int dst3_step, int dst3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"int src_idx_0  = mad24(y, src_step, src_offset + (x << 3) - 8);\n"
"int src_idx_1  = mad24(y, src_step, src_offset + (x << 3) + 8);\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst2_start = mad24(y, dst2_step, dst2_offset);\n"
"int dst2_end   = mad24(y, dst2_step, dst2_offset + dst_step1);\n"
"int dst2_idx   = mad24(y, dst2_step, dst2_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst3_start = mad24(y, dst3_step, dst3_offset);\n"
"int dst3_end   = mad24(y, dst3_step, dst3_offset + dst_step1);\n"
"int dst3_idx   = mad24(y, dst3_step, dst3_offset + (x << 1) & (int)0xfffffffc);\n"
"int src1_index_fix = src_idx_0 < 0 ? 0 : src_idx_0;\n"
"ushort8 src_data0 = vload8(0,(__global ushort *)((__global char *)mat_src + src_idx_0));\n"
"if(src_idx_0 == -6)\n"
"src_data0.s01234567 = src_data0.s67012345;\n"
"if(src_idx_0 == -4)\n"
"src_data0.s01234567 = src_data0.s45670123;\n"
"if(src_idx_0 == -2)\n"
"src_data0.s01234567 = src_data0.s23456701;\n"
"ushort4 src_data1 = *((__global ushort4 *)((__global char *)mat_src + src_idx_1));\n"
"ushort2 dst0_data  = *((__global ushort2 *)((__global char *)mat_dst0 + dst0_idx));\n"
"ushort2 dst1_data  = *((__global ushort2 *)((__global char *)mat_dst1 + dst1_idx));\n"
"ushort2 dst2_data  = *((__global ushort2 *)((__global char *)mat_dst2 + dst2_idx));\n"
"ushort2 dst3_data  = *((__global ushort2 *)((__global char *)mat_dst3 + dst3_idx));\n"
"ushort2 tmp_data0, tmp_data1, tmp_data2, tmp_data3;\n"
"tmp_data0 = (dst0_offset & 3) == 0 ? (ushort2)(src_data0.s4, src_data1.s0) : (ushort2)(src_data0.s0, src_data0.s4);\n"
"tmp_data1 = (dst1_offset & 3) == 0 ? (ushort2)(src_data0.s5, src_data1.s1) : (ushort2)(src_data0.s1, src_data0.s5);\n"
"tmp_data2 = (dst2_offset & 3) == 0 ? (ushort2)(src_data0.s6, src_data1.s2) : (ushort2)(src_data0.s2, src_data0.s6);\n"
"tmp_data3 = (dst3_offset & 3) == 0 ? (ushort2)(src_data0.s7, src_data1.s3) : (ushort2)(src_data0.s3, src_data0.s7);\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? tmp_data0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? tmp_data0.y : dst0_data.y;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? tmp_data1.x : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? tmp_data1.y : dst1_data.y;\n"
"tmp_data2.x = ((dst2_idx + 0 >= dst2_start) && (dst2_idx + 0 < dst2_end)) ? tmp_data2.x : dst2_data.x;\n"
"tmp_data2.y = ((dst2_idx + 2 >= dst2_start) && (dst2_idx + 2 < dst2_end)) ? tmp_data2.y : dst2_data.y;\n"
"tmp_data3.x = ((dst3_idx + 0 >= dst3_start) && (dst3_idx + 0 < dst3_end)) ? tmp_data3.x : dst3_data.x;\n"
"tmp_data3.y = ((dst3_idx + 2 >= dst3_start) && (dst3_idx + 2 < dst3_end)) ? tmp_data3.y : dst3_data.y;\n"
"*((global ushort2 *)((__global char *)mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((global ushort2 *)((__global char *)mat_dst1 + dst1_idx)) = tmp_data1;\n"
"*((global ushort2 *)((__global char *)mat_dst2 + dst2_idx)) = tmp_data2;\n"
"*((global ushort2 *)((__global char *)mat_dst3 + dst3_idx)) = tmp_data3;\n"
"}\n"
"}\n"
"__kernel void split_vector_C3_D2 (__global ushort *mat_src,  int src_step,  int src_offset,\n"
"__global ushort *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global ushort *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global ushort *mat_dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"int src_idx  = mad24(y, src_step, src_offset);\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst2_start = mad24(y, dst2_step, dst2_offset);\n"
"int dst2_end   = mad24(y, dst2_step, dst2_offset + dst_step1);\n"
"int dst2_idx   = mad24(y, dst2_step, dst2_offset + (x << 1) & (int)0xfffffffc);\n"
"ushort2 dst0_data  = *((__global ushort2 *)((__global char *)mat_dst0 + dst0_idx));\n"
"ushort2 dst1_data  = *((__global ushort2 *)((__global char *)mat_dst1 + dst1_idx));\n"
"ushort2 dst2_data  = *((__global ushort2 *)((__global char *)mat_dst2 + dst2_idx));\n"
"ushort2 tmp_data0, tmp_data1, tmp_data2;\n"
"ushort src_data_0 = ((__global ushort *)((__global char *)mat_src + src_idx))[3 * x - 3];\n"
"ushort src_data_1 = ((__global ushort *)((__global char *)mat_src + src_idx))[3 * x - 2];\n"
"ushort src_data_2 = ((__global ushort *)((__global char *)mat_src + src_idx))[3 * x - 1];\n"
"ushort src_data_3 = ((__global ushort *)((__global char *)mat_src + src_idx))[3 * x + 0];\n"
"ushort src_data_4 = ((__global ushort *)((__global char *)mat_src + src_idx))[3 * x + 1];\n"
"ushort src_data_5 = ((__global ushort *)((__global char *)mat_src + src_idx))[3 * x + 2];\n"
"ushort src_data_6 = ((__global ushort *)((__global char *)mat_src + src_idx))[3 * x + 3];\n"
"ushort src_data_7 = ((__global ushort *)((__global char *)mat_src + src_idx))[3 * x + 4];\n"
"ushort src_data_8 = ((__global ushort *)((__global char *)mat_src + src_idx))[3 * x + 5];\n"
"tmp_data0 = (dst0_offset & 3) == 0 ? (ushort2)(src_data_3, src_data_6) : (ushort2)(src_data_0, src_data_3);\n"
"tmp_data1 = (dst1_offset & 3) == 0 ? (ushort2)(src_data_4, src_data_7) : (ushort2)(src_data_1, src_data_4);\n"
"tmp_data2 = (dst2_offset & 3) == 0 ? (ushort2)(src_data_5, src_data_8) : (ushort2)(src_data_2, src_data_5);\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? tmp_data0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? tmp_data0.y : dst0_data.y;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? tmp_data1.x : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? tmp_data1.y : dst1_data.y;\n"
"tmp_data2.x = ((dst2_idx + 0 >= dst2_start) && (dst2_idx + 0 < dst2_end)) ? tmp_data2.x : dst2_data.x;\n"
"tmp_data2.y = ((dst2_idx + 2 >= dst2_start) && (dst2_idx + 2 < dst2_end)) ? tmp_data2.y : dst2_data.y;\n"
"*((__global ushort2 *)((__global char *)mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((__global ushort2 *)((__global char *)mat_dst1 + dst1_idx)) = tmp_data1;\n"
"*((__global ushort2 *)((__global char *)mat_dst2 + dst2_idx)) = tmp_data2;\n"
"}\n"
"}\n"
"__kernel void split_vector_C2_D2 (__global ushort *mat_src,  int src_step,  int src_offset,\n"
"__global ushort *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global ushort *mat_dst1, int dst1_step, int dst1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"#define dst0_align ((dst0_offset & 3) << 1)\n"
"#define dst1_align ((dst1_offset & 3) << 1)\n"
"int src_idx_0  = mad24(y, src_step, src_offset - dst0_align + (x << 2));\n"
"int src_idx_1  = mad24(y, src_step, src_offset - dst1_align + (x << 2));\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + (x << 1) & (int)0xfffffffc);\n"
"int src1_index_fix = src_idx_0 < 0 ? 0 : src_idx_0;\n"
"int src2_index_fix = src_idx_1 < 0 ? 0 : src_idx_1;\n"
"ushort4 src_data_0 = vload4(0, (__global ushort *)((__global char *)mat_src + src1_index_fix));\n"
"ushort4 src_data_1 = vload4(0, (__global ushort *)((__global char *)mat_src + src2_index_fix));\n"
"if(src_idx_0 < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src_idx_0 == -2) ? src_data_0.zwxy : src_data_0.yzwx;\n"
"src_data_0.xyzw = (src_idx_1 == -1) ? src_data_0.wxyz:tmp.xyzw;\n"
"}\n"
"if(src_idx_1 < 0)\n"
"{\n"
"ushort4 tmp;\n"
"tmp.xyzw = (src_idx_1 == -2) ? src_data_1.zwxy : src_data_1.yzwx;\n"
"src_data_1.xyzw = (src_idx_1 == -1) ? src_data_1.wxyz : tmp.xyzw;\n"
"}\n"
"ushort2 dst0_data  = *((__global ushort2 *)((__global char *)mat_dst0 + dst0_idx));\n"
"ushort2 dst1_data  = *((__global ushort2 *)((__global char *)mat_dst1 + dst1_idx));\n"
"ushort2 tmp_data0, tmp_data1;\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? src_data_0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? src_data_0.z : dst0_data.y;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? src_data_1.y : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? src_data_1.w : dst1_data.y;\n"
"*((global ushort2 *)((__global char *)mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((global ushort2 *)((__global char *)mat_dst1 + dst1_idx)) = tmp_data1;\n"
"}\n"
"}\n"
"__kernel void split_vector_C4_D3 (__global short *mat_src,  int src_step,  int src_offset,\n"
"__global short *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global short *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global short *mat_dst2, int dst2_step, int dst2_offset,\n"
"__global short *mat_dst3, int dst3_step, int dst3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"int src_idx_0  = mad24(y, src_step, src_offset + (x << 3) - 8);\n"
"int src_idx_1  = mad24(y, src_step, src_offset + (x << 3) + 8);\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst2_start = mad24(y, dst2_step, dst2_offset);\n"
"int dst2_end   = mad24(y, dst2_step, dst2_offset + dst_step1);\n"
"int dst2_idx   = mad24(y, dst2_step, dst2_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst3_start = mad24(y, dst3_step, dst3_offset);\n"
"int dst3_end   = mad24(y, dst3_step, dst3_offset + dst_step1);\n"
"int dst3_idx   = mad24(y, dst3_step, dst3_offset + (x << 1) & (int)0xfffffffc);\n"
"int src1_index_fix = src_idx_0 < 0 ? 0 : src_idx_0;\n"
"short8 src_data0 = vload8(0,(__global short *)((__global char *)mat_src + src_idx_0));\n"
"if(src_idx_0 == -6)\n"
"src_data0.s01234567 = src_data0.s67012345;\n"
"if(src_idx_0 == -4)\n"
"src_data0.s01234567 = src_data0.s45670123;\n"
"if(src_idx_0 == -2)\n"
"src_data0.s01234567 = src_data0.s23456701;\n"
"short4 src_data1 = *((__global short4 *)((__global char *)mat_src + src_idx_1));\n"
"short2 dst0_data  = *((__global short2 *)((__global char *)mat_dst0 + dst0_idx));\n"
"short2 dst1_data  = *((__global short2 *)((__global char *)mat_dst1 + dst1_idx));\n"
"short2 dst2_data  = *((__global short2 *)((__global char *)mat_dst2 + dst2_idx));\n"
"short2 dst3_data  = *((__global short2 *)((__global char *)mat_dst3 + dst3_idx));\n"
"short2 tmp_data0, tmp_data1, tmp_data2, tmp_data3;\n"
"tmp_data0 = (dst0_offset & 3) == 0 ? (short2)(src_data0.s4, src_data1.s0) : (short2)(src_data0.s0, src_data0.s4);\n"
"tmp_data1 = (dst1_offset & 3) == 0 ? (short2)(src_data0.s5, src_data1.s1) : (short2)(src_data0.s1, src_data0.s5);\n"
"tmp_data2 = (dst2_offset & 3) == 0 ? (short2)(src_data0.s6, src_data1.s2) : (short2)(src_data0.s2, src_data0.s6);\n"
"tmp_data3 = (dst3_offset & 3) == 0 ? (short2)(src_data0.s7, src_data1.s3) : (short2)(src_data0.s3, src_data0.s7);\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? tmp_data0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? tmp_data0.y : dst0_data.y;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? tmp_data1.x : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? tmp_data1.y : dst1_data.y;\n"
"tmp_data2.x = ((dst2_idx + 0 >= dst2_start) && (dst2_idx + 0 < dst2_end)) ? tmp_data2.x : dst2_data.x;\n"
"tmp_data2.y = ((dst2_idx + 2 >= dst2_start) && (dst2_idx + 2 < dst2_end)) ? tmp_data2.y : dst2_data.y;\n"
"tmp_data3.x = ((dst3_idx + 0 >= dst3_start) && (dst3_idx + 0 < dst3_end)) ? tmp_data3.x : dst3_data.x;\n"
"tmp_data3.y = ((dst3_idx + 2 >= dst3_start) && (dst3_idx + 2 < dst3_end)) ? tmp_data3.y : dst3_data.y;\n"
"*((global short2 *)((__global char *)mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((global short2 *)((__global char *)mat_dst1 + dst1_idx)) = tmp_data1;\n"
"*((global short2 *)((__global char *)mat_dst2 + dst2_idx)) = tmp_data2;\n"
"*((global short2 *)((__global char *)mat_dst3 + dst3_idx)) = tmp_data3;\n"
"}\n"
"}\n"
"__kernel void split_vector_C3_D3 (__global short *mat_src,  int src_step,  int src_offset,\n"
"__global short *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global short *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global short *mat_dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"int src_idx  = mad24(y, src_step, src_offset);\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst2_start = mad24(y, dst2_step, dst2_offset);\n"
"int dst2_end   = mad24(y, dst2_step, dst2_offset + dst_step1);\n"
"int dst2_idx   = mad24(y, dst2_step, dst2_offset + (x << 1) & (int)0xfffffffc);\n"
"short2 dst0_data  = *((__global short2 *)((__global char *)mat_dst0 + dst0_idx));\n"
"short2 dst1_data  = *((__global short2 *)((__global char *)mat_dst1 + dst1_idx));\n"
"short2 dst2_data  = *((__global short2 *)((__global char *)mat_dst2 + dst2_idx));\n"
"short2 tmp_data0, tmp_data1, tmp_data2;\n"
"short src_data_0 = ((__global short *)((__global char *)mat_src + src_idx))[3 * x - 3];\n"
"short src_data_1 = ((__global short *)((__global char *)mat_src + src_idx))[3 * x - 2];\n"
"short src_data_2 = ((__global short *)((__global char *)mat_src + src_idx))[3 * x - 1];\n"
"short src_data_3 = ((__global short *)((__global char *)mat_src + src_idx))[3 * x + 0];\n"
"short src_data_4 = ((__global short *)((__global char *)mat_src + src_idx))[3 * x + 1];\n"
"short src_data_5 = ((__global short *)((__global char *)mat_src + src_idx))[3 * x + 2];\n"
"short src_data_6 = ((__global short *)((__global char *)mat_src + src_idx))[3 * x + 3];\n"
"short src_data_7 = ((__global short *)((__global char *)mat_src + src_idx))[3 * x + 4];\n"
"short src_data_8 = ((__global short *)((__global char *)mat_src + src_idx))[3 * x + 5];\n"
"tmp_data0 = (dst0_offset & 3) == 0 ? (short2)(src_data_3, src_data_6) : (short2)(src_data_0, src_data_3);\n"
"tmp_data1 = (dst1_offset & 3) == 0 ? (short2)(src_data_4, src_data_7) : (short2)(src_data_1, src_data_4);\n"
"tmp_data2 = (dst2_offset & 3) == 0 ? (short2)(src_data_5, src_data_8) : (short2)(src_data_2, src_data_5);\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? tmp_data0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? tmp_data0.y : dst0_data.y;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? tmp_data1.x : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? tmp_data1.y : dst1_data.y;\n"
"tmp_data2.x = ((dst2_idx + 0 >= dst2_start) && (dst2_idx + 0 < dst2_end)) ? tmp_data2.x : dst2_data.x;\n"
"tmp_data2.y = ((dst2_idx + 2 >= dst2_start) && (dst2_idx + 2 < dst2_end)) ? tmp_data2.y : dst2_data.y;\n"
"*((__global short2 *)((__global char *)mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((__global short2 *)((__global char *)mat_dst1 + dst1_idx)) = tmp_data1;\n"
"*((__global short2 *)((__global char *)mat_dst2 + dst2_idx)) = tmp_data2;\n"
"}\n"
"}\n"
"__kernel void split_vector_C2_D3 (__global short *mat_src,  int src_step,  int src_offset,\n"
"__global short *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global short *mat_dst1, int dst1_step, int dst1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"x = x << 1;\n"
"#define dst0_align ((dst0_offset & 3) << 1)\n"
"#define dst1_align ((dst1_offset & 3) << 1)\n"
"int src_idx_0  = mad24(y, src_step, src_offset - dst0_align + (x << 2));\n"
"int src_idx_1  = mad24(y, src_step, src_offset - dst1_align + (x << 2));\n"
"int dst0_start = mad24(y, dst0_step, dst0_offset);\n"
"int dst0_end   = mad24(y, dst0_step, dst0_offset + dst_step1);\n"
"int dst0_idx   = mad24(y, dst0_step, dst0_offset + (x << 1) & (int)0xfffffffc);\n"
"int dst1_start = mad24(y, dst1_step, dst1_offset);\n"
"int dst1_end   = mad24(y, dst1_step, dst1_offset + dst_step1);\n"
"int dst1_idx   = mad24(y, dst1_step, dst1_offset + (x << 1) & (int)0xfffffffc);\n"
"int src1_index_fix = src_idx_0 < 0 ? 0 : src_idx_0;\n"
"int src2_index_fix = src_idx_1 < 0 ? 0 : src_idx_1;\n"
"short4 src_data_0 = vload4(0, (__global short *)((__global char *)mat_src + src_idx_0));\n"
"short4 src_data_1 = vload4(0, (__global short *)((__global char *)mat_src + src_idx_1));\n"
"if(src_idx_0 < 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = (src_idx_0 == -2) ? src_data_0.zwxy : src_data_0.yzwx;\n"
"src_data_0.xyzw = (src_idx_0 == -1) ? src_data_0.wxyz:tmp.xyzw;\n"
"}\n"
"if(src_idx_1< 0)\n"
"{\n"
"short4 tmp;\n"
"tmp.xyzw = ( src_idx_1== -2) ? src_data_1.zwxy : src_data_1.yzwx;\n"
"src_data_1.xyzw = ( src_idx_1== -1) ? src_data_1.wxyz : tmp.xyzw;\n"
"}\n"
"short2 dst0_data  = *((__global short2 *)((__global char *)mat_dst0 + dst0_idx));\n"
"short2 dst1_data  = *((__global short2 *)((__global char *)mat_dst1 + dst1_idx));\n"
"short2 tmp_data0, tmp_data1;\n"
"tmp_data0.x = ((dst0_idx + 0 >= dst0_start) && (dst0_idx + 0 < dst0_end)) ? src_data_0.x : dst0_data.x;\n"
"tmp_data0.y = ((dst0_idx + 2 >= dst0_start) && (dst0_idx + 2 < dst0_end)) ? src_data_0.z : dst0_data.y;\n"
"tmp_data1.x = ((dst1_idx + 0 >= dst1_start) && (dst1_idx + 0 < dst1_end)) ? src_data_1.y : dst1_data.x;\n"
"tmp_data1.y = ((dst1_idx + 2 >= dst1_start) && (dst1_idx + 2 < dst1_end)) ? src_data_1.w : dst1_data.y;\n"
"*((global short2 *)((__global char *)mat_dst0 + dst0_idx)) = tmp_data0;\n"
"*((global short2 *)((__global char *)mat_dst1 + dst1_idx)) = tmp_data1;\n"
"}\n"
"}\n"
"__kernel void split_vector_C4_D4 (__global int *mat_src,  int src_step,  int src_offset,\n"
"__global int *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global int *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global int *mat_dst2, int dst2_step, int dst2_offset,\n"
"__global int *mat_dst3, int dst3_step, int dst3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"int src_idx  = mad24(y, src_step,  src_offset);\n"
"int dst0_idx = mad24(y, dst0_step, dst0_offset);\n"
"int dst1_idx = mad24(y, dst1_step, dst1_offset);\n"
"int dst2_idx = mad24(y, dst2_step, dst2_offset);\n"
"int dst3_idx = mad24(y, dst3_step, dst3_offset);\n"
"int4 src_data = ((__global int4 *)((__global char *)mat_src + src_idx))[x];\n"
"((__global int *)((__global char *)mat_dst0 + dst0_idx))[x] = src_data.x;\n"
"((__global int *)((__global char *)mat_dst1 + dst1_idx))[x] = src_data.y;\n"
"((__global int *)((__global char *)mat_dst2 + dst2_idx))[x] = src_data.z;\n"
"((__global int *)((__global char *)mat_dst3 + dst3_idx))[x] = src_data.w;\n"
"}\n"
"}\n"
"__kernel void split_vector_C3_D4 (__global int *mat_src,  int src_step,  int src_offset,\n"
"__global int *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global int *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global int *mat_dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"int src_idx  = mad24(y, src_step,  src_offset);\n"
"int dst0_idx = mad24(y, dst0_step, dst0_offset);\n"
"int dst1_idx = mad24(y, dst1_step, dst1_offset);\n"
"int dst2_idx = mad24(y, dst2_step, dst2_offset);\n"
"int src_data_0 = ((__global int *)((__global char *)mat_src + src_idx))[3 * x + 0];\n"
"int src_data_1 = ((__global int *)((__global char *)mat_src + src_idx))[3 * x + 1];\n"
"int src_data_2 = ((__global int *)((__global char *)mat_src + src_idx))[3 * x + 2];\n"
"((__global int *)((__global char *)mat_dst0 + dst0_idx))[x] = src_data_0;\n"
"((__global int *)((__global char *)mat_dst1 + dst1_idx))[x] = src_data_1;\n"
"((__global int *)((__global char *)mat_dst2 + dst2_idx))[x] = src_data_2;\n"
"}\n"
"}\n"
"__kernel void split_vector_C2_D4 (__global int *mat_src,  int src_step,  int src_offset,\n"
"__global int *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global int *mat_dst1, int dst1_step, int dst1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"int src_idx  = mad24(y, src_step,  src_offset);\n"
"int dst0_idx = mad24(y, dst0_step, dst0_offset);\n"
"int dst1_idx = mad24(y, dst1_step, dst1_offset);\n"
"int2 src_data = ((__global int2 *)((__global char *)mat_src + src_idx))[x];\n"
"((__global int *)((__global char *)mat_dst0 + dst0_idx))[x] = src_data.x;\n"
"((__global int *)((__global char *)mat_dst1 + dst1_idx))[x] = src_data.y;\n"
"}\n"
"}\n"
"__kernel void split_vector_C4_D5 (__global float *mat_src,  int src_step,  int src_offset,\n"
"__global float *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global float *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global float *mat_dst2, int dst2_step, int dst2_offset,\n"
"__global float *mat_dst3, int dst3_step, int dst3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"int src_idx  = mad24(y, src_step,  src_offset);\n"
"int dst0_idx = mad24(y, dst0_step, dst0_offset);\n"
"int dst1_idx = mad24(y, dst1_step, dst1_offset);\n"
"int dst2_idx = mad24(y, dst2_step, dst2_offset);\n"
"int dst3_idx = mad24(y, dst3_step, dst3_offset);\n"
"float4 src_data = ((__global float4 *)((__global char *)mat_src + src_idx))[x];\n"
"((__global float *)((__global char *)mat_dst0 + dst0_idx))[x] = src_data.x;\n"
"((__global float *)((__global char *)mat_dst1 + dst1_idx))[x] = src_data.y;\n"
"((__global float *)((__global char *)mat_dst2 + dst2_idx))[x] = src_data.z;\n"
"((__global float *)((__global char *)mat_dst3 + dst3_idx))[x] = src_data.w;\n"
"}\n"
"}\n"
"__kernel void split_vector_C3_D5 (__global float *mat_src,  int src_step,  int src_offset,\n"
"__global float *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global float *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global float *mat_dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"int src_idx  = mad24(y, src_step,  src_offset);\n"
"int dst0_idx = mad24(y, dst0_step, dst0_offset);\n"
"int dst1_idx = mad24(y, dst1_step, dst1_offset);\n"
"int dst2_idx = mad24(y, dst2_step, dst2_offset);\n"
"float src_data_0 = ((__global float *)((__global char *)mat_src + src_idx))[3 * x + 0];\n"
"float src_data_1 = ((__global float *)((__global char *)mat_src + src_idx))[3 * x + 1];\n"
"float src_data_2 = ((__global float *)((__global char *)mat_src + src_idx))[3 * x + 2];\n"
"((__global float *)((__global char *)mat_dst0 + dst0_idx))[x] = src_data_0;\n"
"((__global float *)((__global char *)mat_dst1 + dst1_idx))[x] = src_data_1;\n"
"((__global float *)((__global char *)mat_dst2 + dst2_idx))[x] = src_data_2;\n"
"}\n"
"}\n"
"__kernel void split_vector_C2_D5 (__global float *mat_src,  int src_step,  int src_offset,\n"
"__global float *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global float *mat_dst1, int dst1_step, int dst1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"int src_idx  = mad24(y, src_step,  src_offset);\n"
"int dst0_idx = mad24(y, dst0_step, dst0_offset);\n"
"int dst1_idx = mad24(y, dst1_step, dst1_offset);\n"
"float2 src_data = ((__global float2 *)((__global char *)mat_src + src_idx))[x];\n"
"((__global float *)((__global char *)mat_dst0 + dst0_idx))[x] = src_data.x;\n"
"((__global float *)((__global char *)mat_dst1 + dst1_idx))[x] = src_data.y;\n"
"}\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"__kernel void split_vector_C4_D6 (__global double *mat_src,  int src_step,  int src_offset,\n"
"__global double *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global double *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global double *mat_dst2, int dst2_step, int dst2_offset,\n"
"__global double *mat_dst3, int dst3_step, int dst3_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"int src_idx  = mad24(y, src_step,  src_offset);\n"
"int dst0_idx = mad24(y, dst0_step, dst0_offset);\n"
"int dst1_idx = mad24(y, dst1_step, dst1_offset);\n"
"int dst2_idx = mad24(y, dst2_step, dst2_offset);\n"
"int dst3_idx = mad24(y, dst3_step, dst3_offset);\n"
"double4 src_data = ((__global double4 *)((__global char *)mat_src + src_idx))[x];\n"
"((__global double *)((__global char *)mat_dst0 + dst0_idx))[x] = src_data.x;\n"
"((__global double *)((__global char *)mat_dst1 + dst1_idx))[x] = src_data.y;\n"
"((__global double *)((__global char *)mat_dst2 + dst2_idx))[x] = src_data.z;\n"
"((__global double *)((__global char *)mat_dst3 + dst3_idx))[x] = src_data.w;\n"
"}\n"
"}\n"
"__kernel void split_vector_C3_D6 (__global double *mat_src,  int src_step,  int src_offset,\n"
"__global double *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global double *mat_dst1, int dst1_step, int dst1_offset,\n"
"__global double *mat_dst2, int dst2_step, int dst2_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"int src_idx  = mad24(y, src_step,  src_offset);\n"
"int dst0_idx = mad24(y, dst0_step, dst0_offset);\n"
"int dst1_idx = mad24(y, dst1_step, dst1_offset);\n"
"int dst2_idx = mad24(y, dst2_step, dst2_offset);\n"
"double src_data_0 = ((__global double *)((__global char *)mat_src + src_idx))[3 * x + 0];\n"
"double src_data_1 = ((__global double *)((__global char *)mat_src + src_idx))[3 * x + 1];\n"
"double src_data_2 = ((__global double *)((__global char *)mat_src + src_idx))[3 * x + 2];\n"
"((__global double *)((__global char *)mat_dst0 + dst0_idx))[x] = src_data_0;\n"
"((__global double *)((__global char *)mat_dst1 + dst1_idx))[x] = src_data_1;\n"
"((__global double *)((__global char *)mat_dst2 + dst2_idx))[x] = src_data_2;\n"
"}\n"
"}\n"
"__kernel void split_vector_C2_D6 (__global double *mat_src,  int src_step,  int src_offset,\n"
"__global double *mat_dst0, int dst0_step, int dst0_offset,\n"
"__global double *mat_dst1, int dst1_step, int dst1_offset,\n"
"int rows, int cols, int dst_step1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if((x  < cols) && (y < rows))\n"
"{\n"
"int src_idx  = mad24(y, src_step,  src_offset);\n"
"int dst0_idx = mad24(y, dst0_step, dst0_offset);\n"
"int dst1_idx = mad24(y, dst1_step, dst1_offset);\n"
"double2 src_data = ((__global double2 *)((__global char *)mat_src + src_idx))[x];\n"
"((__global double *)((__global char *)mat_dst0 + dst0_idx))[x] = src_data.x;\n"
"((__global double *)((__global char *)mat_dst1 + dst1_idx))[x] = src_data.y;\n"
"}\n"
"}\n"
"#endif\n"
;
const char* stereobm="#define ROWSperTHREAD 21\n"
"#define BLOCK_W       128\n"
"#define N_DISPARITIES 8\n"
"#define STEREO_MIND 0\n"
"#define STEREO_DISP_STEP N_DISPARITIES\n"
"int SQ(int a)\n"
"{\n"
"return a * a;\n"
"}\n"
"unsigned int CalcSSD(volatile __local unsigned int *col_ssd_cache,\n"
"volatile __local unsigned int *col_ssd, int radius)\n"
"{\n"
"unsigned int cache = 0;\n"
"unsigned int cache2 = 0;\n"
"for(int i = 1; i <= radius; i++)\n"
"cache += col_ssd[i];\n"
"col_ssd_cache[0] = cache;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(0) < BLOCK_W - radius)\n"
"cache2 = col_ssd_cache[radius];\n"
"else\n"
"for(int i = radius + 1; i < (2 * radius + 1); i++)\n"
"cache2 += col_ssd[i];\n"
"return col_ssd[0] + cache + cache2;\n"
"}\n"
"uint2 MinSSD(volatile __local unsigned int *col_ssd_cache,\n"
"volatile __local unsigned int *col_ssd, int radius)\n"
"{\n"
"unsigned int ssd[N_DISPARITIES];\n"
"ssd[0] = CalcSSD(col_ssd_cache, col_ssd + 0 * (BLOCK_W + 2 * radius), radius);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ssd[1] = CalcSSD(col_ssd_cache, col_ssd + 1 * (BLOCK_W + 2 * radius), radius);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ssd[2] = CalcSSD(col_ssd_cache, col_ssd + 2 * (BLOCK_W + 2 * radius), radius);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ssd[3] = CalcSSD(col_ssd_cache, col_ssd + 3 * (BLOCK_W + 2 * radius), radius);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ssd[4] = CalcSSD(col_ssd_cache, col_ssd + 4 * (BLOCK_W + 2 * radius), radius);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ssd[5] = CalcSSD(col_ssd_cache, col_ssd + 5 * (BLOCK_W + 2 * radius), radius);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ssd[6] = CalcSSD(col_ssd_cache, col_ssd + 6 * (BLOCK_W + 2 * radius), radius);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ssd[7] = CalcSSD(col_ssd_cache, col_ssd + 7 * (BLOCK_W + 2 * radius), radius);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"unsigned int mssd = min(min(min(ssd[0], ssd[1]), min(ssd[4], ssd[5])), min(min(ssd[2], ssd[3]), min(ssd[6], ssd[7])));\n"
"int bestIdx = 0;\n"
"for (int i = 0; i < N_DISPARITIES; i++)\n"
"{\n"
"if (mssd == ssd[i])\n"
"bestIdx = i;\n"
"}\n"
"return (uint2)(mssd, bestIdx);\n"
"}\n"
"void StepDown(int idx1, int idx2, __global unsigned char* imageL,\n"
"__global unsigned char* imageR, int d, volatile  __local unsigned int *col_ssd, int radius)\n"
"{\n"
"unsigned char leftPixel1;\n"
"unsigned char leftPixel2;\n"
"unsigned char rightPixel1[8];\n"
"unsigned char rightPixel2[8];\n"
"unsigned int diff1, diff2;\n"
"leftPixel1 = imageL[idx1];\n"
"leftPixel2 = imageL[idx2];\n"
"idx1 = idx1 - d;\n"
"idx2 = idx2 - d;\n"
"rightPixel1[7] = imageR[idx1 - 7];\n"
"rightPixel1[0] = imageR[idx1 - 0];\n"
"rightPixel1[1] = imageR[idx1 - 1];\n"
"rightPixel1[2] = imageR[idx1 - 2];\n"
"rightPixel1[3] = imageR[idx1 - 3];\n"
"rightPixel1[4] = imageR[idx1 - 4];\n"
"rightPixel1[5] = imageR[idx1 - 5];\n"
"rightPixel1[6] = imageR[idx1 - 6];\n"
"rightPixel2[7] = imageR[idx2 - 7];\n"
"rightPixel2[0] = imageR[idx2 - 0];\n"
"rightPixel2[1] = imageR[idx2 - 1];\n"
"rightPixel2[2] = imageR[idx2 - 2];\n"
"rightPixel2[3] = imageR[idx2 - 3];\n"
"rightPixel2[4] = imageR[idx2 - 4];\n"
"rightPixel2[5] = imageR[idx2 - 5];\n"
"rightPixel2[6] = imageR[idx2 - 6];\n"
"diff1 = leftPixel1 - rightPixel1[0];\n"
"diff2 = leftPixel2 - rightPixel2[0];\n"
"col_ssd[0 * (BLOCK_W + 2 * radius)] += SQ(diff2) - SQ(diff1);\n"
"diff1 = leftPixel1 - rightPixel1[1];\n"
"diff2 = leftPixel2 - rightPixel2[1];\n"
"col_ssd[1 * (BLOCK_W + 2 * radius)] += SQ(diff2) - SQ(diff1);\n"
"diff1 = leftPixel1 - rightPixel1[2];\n"
"diff2 = leftPixel2 - rightPixel2[2];\n"
"col_ssd[2 * (BLOCK_W + 2 * radius)] += SQ(diff2) - SQ(diff1);\n"
"diff1 = leftPixel1 - rightPixel1[3];\n"
"diff2 = leftPixel2 - rightPixel2[3];\n"
"col_ssd[3 * (BLOCK_W + 2 * radius)] += SQ(diff2) - SQ(diff1);\n"
"diff1 = leftPixel1 - rightPixel1[4];\n"
"diff2 = leftPixel2 - rightPixel2[4];\n"
"col_ssd[4 * (BLOCK_W + 2 * radius)] += SQ(diff2) - SQ(diff1);\n"
"diff1 = leftPixel1 - rightPixel1[5];\n"
"diff2 = leftPixel2 - rightPixel2[5];\n"
"col_ssd[5 * (BLOCK_W + 2 * radius)] += SQ(diff2) - SQ(diff1);\n"
"diff1 = leftPixel1 - rightPixel1[6];\n"
"diff2 = leftPixel2 - rightPixel2[6];\n"
"col_ssd[6 * (BLOCK_W + 2 * radius)] += SQ(diff2) - SQ(diff1);\n"
"diff1 = leftPixel1 - rightPixel1[7];\n"
"diff2 = leftPixel2 - rightPixel2[7];\n"
"col_ssd[7 * (BLOCK_W + 2 * radius)] += SQ(diff2) - SQ(diff1);\n"
"}\n"
"void InitColSSD(int x_tex, int y_tex, int im_pitch, __global unsigned char* imageL,\n"
"__global unsigned char* imageR, int d,\n"
"volatile __local unsigned int *col_ssd, int radius)\n"
"{\n"
"unsigned char leftPixel1;\n"
"int idx;\n"
"unsigned int diffa[] = {0, 0, 0, 0, 0, 0, 0, 0};\n"
"for(int i = 0; i < (2 * radius + 1); i++)\n"
"{\n"
"idx = y_tex * im_pitch + x_tex;\n"
"leftPixel1 = imageL[idx];\n"
"idx = idx - d;\n"
"diffa[0] += SQ(leftPixel1 - imageR[idx - 0]);\n"
"diffa[1] += SQ(leftPixel1 - imageR[idx - 1]);\n"
"diffa[2] += SQ(leftPixel1 - imageR[idx - 2]);\n"
"diffa[3] += SQ(leftPixel1 - imageR[idx - 3]);\n"
"diffa[4] += SQ(leftPixel1 - imageR[idx - 4]);\n"
"diffa[5] += SQ(leftPixel1 - imageR[idx - 5]);\n"
"diffa[6] += SQ(leftPixel1 - imageR[idx - 6]);\n"
"diffa[7] += SQ(leftPixel1 - imageR[idx - 7]);\n"
"y_tex += 1;\n"
"}\n"
"col_ssd[0 * (BLOCK_W + 2 * radius)] = diffa[0];\n"
"col_ssd[1 * (BLOCK_W + 2 * radius)] = diffa[1];\n"
"col_ssd[2 * (BLOCK_W + 2 * radius)] = diffa[2];\n"
"col_ssd[3 * (BLOCK_W + 2 * radius)] = diffa[3];\n"
"col_ssd[4 * (BLOCK_W + 2 * radius)] = diffa[4];\n"
"col_ssd[5 * (BLOCK_W + 2 * radius)] = diffa[5];\n"
"col_ssd[6 * (BLOCK_W + 2 * radius)] = diffa[6];\n"
"col_ssd[7 * (BLOCK_W + 2 * radius)] = diffa[7];\n"
"}\n"
"__kernel void stereoKernel(__global unsigned char *left, __global unsigned char *right,\n"
"__global unsigned int *cminSSDImage, int cminSSD_step,\n"
"__global unsigned char *disp, int disp_step,int cwidth, int cheight,\n"
"int img_step, int maxdisp, int radius,\n"
"__local unsigned int *col_ssd_cache)\n"
"{\n"
"volatile __local unsigned int *col_ssd = col_ssd_cache + BLOCK_W + get_local_id(0);\n"
"volatile __local unsigned int *col_ssd_extra = get_local_id(0) < (2 * radius) ? col_ssd + BLOCK_W : 0;\n"
"int X = get_group_id(0) * BLOCK_W + get_local_id(0) + maxdisp + radius;\n"
"#define Y (get_group_id(1) * ROWSperTHREAD + radius)\n"
"volatile __global unsigned int* minSSDImage = cminSSDImage + X + Y * cminSSD_step;\n"
"__global unsigned char* disparImage = disp + X + Y * disp_step;\n"
"int end_row = ROWSperTHREAD < (cheight - Y) ? ROWSperTHREAD:(cheight - Y);\n"
"int y_tex;\n"
"int x_tex = X - radius;\n"
"if (x_tex >= cwidth)\n"
"return;\n"
"for(int d = STEREO_MIND; d < maxdisp; d += STEREO_DISP_STEP)\n"
"{\n"
"y_tex = Y - radius;\n"
"InitColSSD(x_tex, y_tex, img_step, left, right, d, col_ssd, radius);\n"
"if (col_ssd_extra > 0)\n"
"if (x_tex + BLOCK_W < cwidth)\n"
"InitColSSD(x_tex + BLOCK_W, y_tex, img_step, left, right, d, col_ssd_extra, radius);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (X < cwidth - radius && Y < cheight - radius)\n"
"{\n"
"uint2 minSSD = MinSSD(col_ssd_cache + get_local_id(0), col_ssd, radius);\n"
"if (minSSD.x < minSSDImage[0])\n"
"{\n"
"disparImage[0] = (unsigned char)(d + minSSD.y);\n"
"minSSDImage[0] = minSSD.x;\n"
"}\n"
"}\n"
"for(int row = 1; row < end_row; row++)\n"
"{\n"
"int idx1 = y_tex * img_step + x_tex;\n"
"int idx2 = (y_tex + (2 * radius + 1)) * img_step + x_tex;\n"
"barrier(CLK_GLOBAL_MEM_FENCE);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"StepDown(idx1, idx2, left, right, d, col_ssd, radius);\n"
"if (col_ssd_extra > 0)\n"
"if (x_tex + BLOCK_W < cwidth)\n"
"StepDown(idx1, idx2, left + BLOCK_W, right + BLOCK_W, d, col_ssd_extra, radius);\n"
"y_tex += 1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (X < cwidth - radius && row < cheight - radius - Y)\n"
"{\n"
"int idx = row * cminSSD_step;\n"
"uint2 minSSD = MinSSD(col_ssd_cache + get_local_id(0), col_ssd, radius);\n"
"if (minSSD.x < minSSDImage[idx])\n"
"{\n"
"disparImage[disp_step * row] = (unsigned char)(d + minSSD.y);\n"
"minSSDImage[idx] = minSSD.x;\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel void prefilter_xsobel(__global unsigned char *input, __global unsigned char *output,\n"
"int rows, int cols, int prefilterCap)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if(x < cols && y < rows)\n"
"{\n"
"int cov = input[(y-1) * cols + (x-1)] * (-1) + input[(y-1) * cols + (x+1)] * (1) +\n"
"input[(y)   * cols + (x-1)] * (-2) + input[(y)   * cols + (x+1)] * (2) +\n"
"input[(y+1) * cols + (x-1)] * (-1) + input[(y+1) * cols + (x+1)] * (1);\n"
"cov = min(min(max(-prefilterCap, cov), prefilterCap) + prefilterCap, 255);\n"
"output[y * cols + x] = cov & 0xFF;\n"
"}\n"
"}\n"
"float sobel(__global unsigned char *input, int x, int y, int rows, int cols)\n"
"{\n"
"float conv = 0;\n"
"int y1 = y==0? 0 : y-1;\n"
"int x1 = x==0? 0 : x-1;\n"
"if(x < cols && y < rows && x > 0 && y > 0)\n"
"{\n"
"conv = (float)input[(y1)  * cols + (x1)] * (-1) + (float)input[(y1)  * cols + (x+1)] * (1) +\n"
"(float)input[(y)   * cols + (x1)] * (-2) + (float)input[(y)   * cols + (x+1)] * (2) +\n"
"(float)input[(y+1) * cols + (x1)] * (-1) + (float)input[(y+1) * cols + (x+1)] * (1);\n"
"}\n"
"return fabs(conv);\n"
"}\n"
"float CalcSums(__local float *cols, __local float *cols_cache, int winsz)\n"
"{\n"
"float cache = 0;\n"
"float cache2 = 0;\n"
"int winsz2 = winsz/2;\n"
"int x = get_local_id(0);\n"
"int group_size_x = get_local_size(0);\n"
"for(int i = 1; i <= winsz2; i++)\n"
"cache += cols[i];\n"
"cols_cache[0] = cache;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (x < group_size_x - winsz2)\n"
"cache2 = cols_cache[winsz2];\n"
"else\n"
"for(int i = winsz2 + 1; i < winsz; i++)\n"
"cache2 += cols[i];\n"
"return cols[0] + cache + cache2;\n"
"}\n"
"#define RpT (2 * ROWSperTHREAD)\n"
"__kernel void textureness_kernel(__global unsigned char *disp, int disp_rows, int disp_cols,\n"
"int disp_step, __global unsigned char *input, int input_rows,\n"
"int input_cols,int winsz, float threshold,\n"
"__local float *cols_cache)\n"
"{\n"
"int winsz2 = winsz/2;\n"
"int n_dirty_pixels = (winsz2) * 2;\n"
"int local_id_x = get_local_id(0);\n"
"int group_size_x = get_local_size(0);\n"
"int group_id_y = get_group_id(1);\n"
"__local float *cols = cols_cache + group_size_x + local_id_x;\n"
"__local float *cols_extra = local_id_x < n_dirty_pixels ? cols + group_size_x : 0;\n"
"int x = get_global_id(0);\n"
"int beg_row = group_id_y * RpT;\n"
"int end_row = min(beg_row + RpT, disp_rows);\n"
"int y = beg_row;\n"
"float sum = 0;\n"
"float sum_extra = 0;\n"
"for(int i = y - winsz2; i <= y + winsz2; ++i)\n"
"{\n"
"sum += sobel(input, x - winsz2, i, input_rows, input_cols);\n"
"if (cols_extra)\n"
"sum_extra += sobel(input, x + group_size_x - winsz2, i, input_rows, input_cols);\n"
"}\n"
"*cols = sum;\n"
"if (cols_extra)\n"
"*cols_extra = sum_extra;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float sum_win = CalcSums(cols, cols_cache + local_id_x, winsz) * 255;\n"
"if (sum_win < threshold)\n"
"disp[y * disp_step + x] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for(int y = beg_row + 1; y < end_row; ++y)\n"
"{\n"
"sum = sum - sobel(input, x - winsz2, y - winsz2 - 1, input_rows, input_cols) +\n"
"sobel(input, x - winsz2, y + winsz2, input_rows, input_cols);\n"
"*cols = sum;\n"
"if (cols_extra)\n"
"{\n"
"sum_extra = sum_extra - sobel(input, x + group_size_x - winsz2, y - winsz2 - 1,input_rows, input_cols)\n"
"+ sobel(input, x + group_size_x - winsz2, y + winsz2, input_rows, input_cols);\n"
"*cols_extra = sum_extra;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float sum_win = CalcSums(cols, cols_cache + local_id_x, winsz) * 255;\n"
"if (sum_win < threshold)\n"
"disp[y * disp_step + x] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
;
const char* stereobp="#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#endif\n"
"#ifdef T_FLOAT\n"
"#define T float\n"
"#else\n"
"#define T short\n"
"#endif\n"
"T saturate_cast(float v){\n"
"#ifdef T_SHORT\n"
"return convert_short_sat_rte(v); \n"
"#else\n"
"return v;\n"
"#endif\n"
"}\n"
"#define FLOAT_MAX 3.402823466e+38f\n"
"typedef struct\n"
"{\n"
"int   cndisp;\n"
"float cmax_data_term;\n"
"float cdata_weight;\n"
"float cmax_disc_term;\n"
"float cdisc_single_jump;\n"
"}con_srtuct_t;\n"
"float pix_diff_1(__global const uchar *ls, __global const uchar *rs)\n"
"{\n"
"return abs((int)(*ls) - *rs); \n"
"}\n"
"float pix_diff_3(__global const uchar *ls, __global const uchar *rs)\n"
"{\n"
"const float tr = 0.299f;\n"
"const float tg = 0.587f;\n"
"const float tb = 0.114f;\n"
"float val;\n"
"val =  tb * abs((int)ls[0] - rs[0]);\n"
"val += tg * abs((int)ls[1] - rs[1]);\n"
"val += tr * abs((int)ls[2] - rs[2]);\n"
"return val;\n"
"}\n"
"float pix_diff_4(__global const uchar *ls, __global const uchar *rs)\n"
"{\n"
"uchar4 l, r;\n"
"l = *((__global uchar4 *)ls);\n"
"r = *((__global uchar4 *)rs);\n"
"const float tr = 0.299f;\n"
"const float tg = 0.587f;\n"
"const float tb = 0.114f;\n"
"float val;\n"
"val  = tb * abs((int)l.x - r.x);\n"
"val += tg * abs((int)l.y - r.y);\n"
"val += tr * abs((int)l.z - r.z);\n"
"return val;\n"
"}\n"
"#ifndef CN\n"
"#define CN 4\n"
"#endif\n"
"#define CAT(X,Y) X##Y\n"
"#define CAT2(X,Y) CAT(X,Y)\n"
"#define PIX_DIFF CAT2(pix_diff_, CN)\n"
"__kernel void comp_data(__global uchar *left,  int left_rows,  int left_cols,  int left_step,\n"
"__global uchar *right, int right_step,\n"
"__global T *data, int data_step,\n"
"__constant con_srtuct_t *con_st)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y > 0 && y < (left_rows - 1) && x > 0 && x < (left_cols - 1))\n"
"{\n"
"data_step /= sizeof(T);\n"
"const __global uchar* ls = left  + y * left_step  + x * CN;\n"
"const __global uchar* rs = right + y * right_step + x * CN;\n"
"__global T *ds = data + y * data_step + x;\n"
"const unsigned int disp_step = data_step * left_rows;\n"
"for (int disp = 0; disp < con_st -> cndisp; disp++)\n"
"{\n"
"if (x - disp >= 1)\n"
"{\n"
"float val = 0;\n"
"val = PIX_DIFF(ls, rs - disp * CN);\n"
"ds[disp * disp_step] =  saturate_cast(fmin(con_st -> cdata_weight * val, \n"
"con_st -> cdata_weight * con_st -> cmax_data_term));\n"
"}\n"
"else\n"
"{\n"
"ds[disp * disp_step] =  saturate_cast(con_st -> cdata_weight * con_st -> cmax_data_term);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel void data_step_down(__global T *src, int src_rows, \n"
"__global T *dst, int dst_rows, int dst_cols, \n"
"int src_step, int dst_step,\n"
"int cndisp)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"src_step /= sizeof(T);\n"
"dst_step /= sizeof(T);\n"
"for (int d = 0; d < cndisp; ++d)\n"
"{\n"
"float dst_reg;\n"
"dst_reg  = src[(d * src_rows + (2*y+0)) * src_step + 2*x+0];\n"
"dst_reg += src[(d * src_rows + (2*y+1)) * src_step + 2*x+0];\n"
"dst_reg += src[(d * src_rows + (2*y+0)) * src_step + 2*x+1];\n"
"dst_reg += src[(d * src_rows + (2*y+1)) * src_step + 2*x+1];\n"
"dst[(d * dst_rows + y) * dst_step + x] = saturate_cast(dst_reg);\n"
"}\n"
"}\n"
"}\n"
"__kernel void level_up_message(__global T *src, int src_rows, int src_step,\n"
"__global T *dst, int dst_rows, int dst_cols, int dst_step,\n"
"int cndisp)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"src_step /= sizeof(T);\n"
"dst_step /= sizeof(T);\n"
"const int dst_disp_step = dst_step * dst_rows;\n"
"const int src_disp_step = src_step * src_rows;\n"
"__global T       *dstr = dst + y * dst_step + x;\n"
"__global const T *srcr = src + (y / 2 * src_step) + (x / 2);\n"
"for (int d = 0; d < cndisp; ++d)\n"
"dstr[d * dst_disp_step] = srcr[d * src_disp_step];\n"
"}\n"
"}\n"
"void calc_min_linear_penalty(__global T * dst, int disp_step, \n"
"int cndisp, float cdisc_single_jump)\n"
"{\n"
"float prev = dst[0];\n"
"float cur;\n"
"for (int disp = 1; disp < cndisp; ++disp)\n"
"{\n"
"prev += cdisc_single_jump;\n"
"cur = dst[disp_step * disp];\n"
"if (prev < cur)\n"
"{\n"
"cur = prev;\n"
"dst[disp_step * disp] = saturate_cast(prev);\n"
"}\n"
"prev = cur;\n"
"}\n"
"prev = dst[(cndisp - 1) * disp_step];\n"
"for (int disp = cndisp - 2; disp >= 0; disp--)\n"
"{\n"
"prev += cdisc_single_jump;\n"
"cur = dst[disp_step * disp];\n"
"if (prev < cur)\n"
"{\n"
"cur = prev;\n"
"dst[disp_step * disp] = saturate_cast(prev);\n"
"}\n"
"prev = cur;\n"
"}\n"
"}\n"
"void message(const __global T *msg1, const __global T *msg2,\n"
"const __global T *msg3, const __global T *data, __global T *dst,\n"
"int msg_disp_step, int data_disp_step, int cndisp, float cmax_disc_term, float cdisc_single_jump)\n"
"{\n"
"float minimum = FLOAT_MAX;\n"
"for(int i = 0; i < cndisp; ++i)\n"
"{\n"
"float dst_reg;\n"
"dst_reg  = msg1[msg_disp_step * i];\n"
"dst_reg += msg2[msg_disp_step * i];\n"
"dst_reg += msg3[msg_disp_step * i];\n"
"dst_reg += data[data_disp_step * i];\n"
"if (dst_reg < minimum)\n"
"minimum = dst_reg;\n"
"dst[msg_disp_step * i] = saturate_cast(dst_reg);\n"
"}\n"
"calc_min_linear_penalty(dst, msg_disp_step, cndisp, cdisc_single_jump);\n"
"minimum += cmax_disc_term;\n"
"float sum = 0;\n"
"for(int i = 0; i < cndisp; ++i)\n"
"{\n"
"float dst_reg = dst[msg_disp_step * i];\n"
"if (dst_reg > minimum)\n"
"{\n"
"dst_reg = minimum;\n"
"dst[msg_disp_step * i] = saturate_cast(minimum);\n"
"}\n"
"sum += dst_reg;\n"
"}\n"
"sum /= cndisp;\n"
"for(int i = 0; i < cndisp; ++i)\n"
"dst[msg_disp_step * i] -= sum;\n"
"}\n"
"__kernel void one_iteration(__global T *u,    int u_step,\n"
"__global T *data, int data_step,\n"
"__global T *d,    __global T *l, __global T *r,\n"
"int t, int cols, int rows, \n"
"int cndisp, float cmax_disc_term, float cdisc_single_jump)\n"
"{\n"
"const int y = get_global_id(1);\n"
"const int x = ((get_global_id(0)) << 1) + ((y + t) & 1);\n"
"if ((y > 0) && (y < rows - 1) && (x > 0) && (x < cols - 1))\n"
"{\n"
"u_step    /= sizeof(T);\n"
"data_step /= sizeof(T);\n"
"__global T *us = u + y * u_step + x;\n"
"__global T *ds = d + y * u_step + x;\n"
"__global T *ls = l + y * u_step + x;\n"
"__global T *rs = r + y * u_step + x;\n"
"const __global  T *dt = data + y * data_step + x;\n"
"int msg_disp_step = u_step * rows;\n"
"int data_disp_step = data_step * rows;\n"
"message(us + u_step, ls      + 1, rs - 1, dt, us, msg_disp_step, data_disp_step, cndisp, \n"
"cmax_disc_term, cdisc_single_jump);\n"
"message(ds - u_step, ls      + 1, rs - 1, dt, ds, msg_disp_step, data_disp_step, cndisp,\n"
"cmax_disc_term, cdisc_single_jump);\n"
"message(us + u_step, ds - u_step, rs - 1, dt, rs, msg_disp_step, data_disp_step, cndisp,\n"
"cmax_disc_term, cdisc_single_jump);\n"
"message(us + u_step, ds - u_step, ls + 1, dt, ls, msg_disp_step, data_disp_step, cndisp,\n"
"cmax_disc_term, cdisc_single_jump);\n"
"}\n"
"}\n"
"__kernel void output(const __global T *u, int u_step,\n"
"const __global T *d, const __global T *l,\n"
"const __global T *r, const __global T *data,\n"
"__global T *disp, int disp_rows, int disp_cols, int disp_step,\n"
"int cndisp)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (y > 0 && y < disp_rows - 1 && x > 0 && x < disp_cols - 1)\n"
"{\n"
"u_step    /= sizeof(T);\n"
"disp_step /= sizeof(T);\n"
"const __global T *us = u + (y + 1) * u_step + x;\n"
"const __global T *ds = d + (y - 1) * u_step + x;\n"
"const __global T *ls = l + y * u_step + (x + 1);\n"
"const __global T *rs = r + y * u_step + (x - 1);\n"
"const __global T *dt = data + y * u_step + x;\n"
"int disp_steps = disp_rows * u_step;\n"
"int best = 0;\n"
"float best_val = FLOAT_MAX;\n"
"for (int d = 0; d < cndisp; ++d)\n"
"{\n"
"float val;\n"
"val  = us[d * disp_steps];\n"
"val += ds[d * disp_steps];\n"
"val += ls[d * disp_steps];\n"
"val += rs[d * disp_steps];\n"
"val += dt[d * disp_steps];\n"
"if (val < best_val)\n"
"{\n"
"best_val = val;\n"
"best = d;\n"
"}\n"
"}\n"
"(disp + y * disp_step)[x] = convert_short_sat(best);\n"
"}\n"
"}\n"
;
}
}
