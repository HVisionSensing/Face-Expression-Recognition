// This file is auto-generated. Do not edit!

namespace cv
{
namespace ocl
{
const char* surf="#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n"
"#ifdef DISABLE_IMAGE2D\n"
"#define IMAGE_INT32 __global uint  *\n"
"#define IMAGE_INT8  __global uchar *\n"
"#else\n"
"#define IMAGE_INT32 image2d_t\n"
"#define IMAGE_INT8  image2d_t\n"
"#endif\n"
"uint read_sumTex(IMAGE_INT32 img, sampler_t sam, int2 coord, int rows, int cols, int elemPerRow)\n"
"{\n"
"#ifdef DISABLE_IMAGE2D\n"
"int x = clamp(coord.x, 0, cols);\n"
"int y = clamp(coord.y, 0, rows);\n"
"return img[elemPerRow * y + x];\n"
"#else\n"
"return read_imageui(img, sam, coord).x;\n"
"#endif\n"
"}\n"
"uchar read_imgTex(IMAGE_INT8 img, sampler_t sam, float2 coord, int rows, int cols, int elemPerRow)\n"
"{\n"
"#ifdef DISABLE_IMAGE2D\n"
"int x = clamp(convert_int_rte(coord.x), 0, cols - 1);\n"
"int y = clamp(convert_int_rte(coord.y), 0, rows - 1);\n"
"return img[elemPerRow * y + x];\n"
"#else\n"
"return (uchar)read_imageui(img, sam, coord).x;\n"
"#endif\n"
"}\n"
"#if defined (DOUBLE_SUPPORT)\n"
"#ifdef cl_khr_fp64\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#elif defined (cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#endif\n"
"#define F double\n"
"#else\n"
"#define F float\n"
"#endif\n"
"__constant sampler_t sampler    = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST;\n"
"#ifndef FLT_EPSILON\n"
"#define FLT_EPSILON (1e-15)\n"
"#endif\n"
"#ifndef CV_PI_F\n"
"#define CV_PI_F 3.14159265f\n"
"#endif\n"
"float icvCalcHaarPatternSum_2(\n"
"IMAGE_INT32 sumTex,\n"
"__constant float src[2][5],\n"
"int oldSize,\n"
"int newSize,\n"
"int y, int x,\n"
"int rows, int cols, int elemPerRow)\n"
"{\n"
"float ratio = (float)newSize / oldSize;\n"
"F d = 0;\n"
"#pragma unroll\n"
"for (int k = 0; k < 2; ++k)\n"
"{\n"
"int dx1 = convert_int_rte(ratio * src[k][0]);\n"
"int dy1 = convert_int_rte(ratio * src[k][1]);\n"
"int dx2 = convert_int_rte(ratio * src[k][2]);\n"
"int dy2 = convert_int_rte(ratio * src[k][3]);\n"
"F t = 0;\n"
"t += read_sumTex( sumTex, sampler, (int2)(x + dx1, y + dy1), rows, cols, elemPerRow );\n"
"t -= read_sumTex( sumTex, sampler, (int2)(x + dx1, y + dy2), rows, cols, elemPerRow );\n"
"t -= read_sumTex( sumTex, sampler, (int2)(x + dx2, y + dy1), rows, cols, elemPerRow );\n"
"t += read_sumTex( sumTex, sampler, (int2)(x + dx2, y + dy2), rows, cols, elemPerRow );\n"
"d += t * src[k][4] / ((dx2 - dx1) * (dy2 - dy1));\n"
"}\n"
"return (float)d;\n"
"}\n"
"float icvCalcHaarPatternSum_3(\n"
"IMAGE_INT32 sumTex,\n"
"__constant float src[2][5],\n"
"int oldSize,\n"
"int newSize,\n"
"int y, int x,\n"
"int rows, int cols, int elemPerRow)\n"
"{\n"
"float ratio = (float)newSize / oldSize;\n"
"F d = 0;\n"
"#pragma unroll\n"
"for (int k = 0; k < 3; ++k)\n"
"{\n"
"int dx1 = convert_int_rte(ratio * src[k][0]);\n"
"int dy1 = convert_int_rte(ratio * src[k][1]);\n"
"int dx2 = convert_int_rte(ratio * src[k][2]);\n"
"int dy2 = convert_int_rte(ratio * src[k][3]);\n"
"F t = 0;\n"
"t += read_sumTex( sumTex, sampler, (int2)(x + dx1, y + dy1), rows, cols, elemPerRow );\n"
"t -= read_sumTex( sumTex, sampler, (int2)(x + dx1, y + dy2), rows, cols, elemPerRow );\n"
"t -= read_sumTex( sumTex, sampler, (int2)(x + dx2, y + dy1), rows, cols, elemPerRow );\n"
"t += read_sumTex( sumTex, sampler, (int2)(x + dx2, y + dy2), rows, cols, elemPerRow );\n"
"d += t * src[k][4] / ((dx2 - dx1) * (dy2 - dy1));\n"
"}\n"
"return (float)d;\n"
"}\n"
"float icvCalcHaarPatternSum_4(\n"
"IMAGE_INT32 sumTex,\n"
"__constant float src[2][5],\n"
"int oldSize,\n"
"int newSize,\n"
"int y, int x,\n"
"int rows, int cols, int elemPerRow)\n"
"{\n"
"float ratio = (float)newSize / oldSize;\n"
"F d = 0;\n"
"#pragma unroll\n"
"for (int k = 0; k < 4; ++k)\n"
"{\n"
"int dx1 = convert_int_rte(ratio * src[k][0]);\n"
"int dy1 = convert_int_rte(ratio * src[k][1]);\n"
"int dx2 = convert_int_rte(ratio * src[k][2]);\n"
"int dy2 = convert_int_rte(ratio * src[k][3]);\n"
"F t = 0;\n"
"t += read_sumTex( sumTex, sampler, (int2)(x + dx1, y + dy1), rows, cols, elemPerRow );\n"
"t -= read_sumTex( sumTex, sampler, (int2)(x + dx1, y + dy2), rows, cols, elemPerRow );\n"
"t -= read_sumTex( sumTex, sampler, (int2)(x + dx2, y + dy1), rows, cols, elemPerRow );\n"
"t += read_sumTex( sumTex, sampler, (int2)(x + dx2, y + dy2), rows, cols, elemPerRow );\n"
"d += t * src[k][4] / ((dx2 - dx1) * (dy2 - dy1));\n"
"}\n"
"return (float)d;\n"
"}\n"
"__constant float c_DX [3][5] = { {0, 2, 3, 7, 1}, {3, 2, 6, 7, -2}, {6, 2, 9, 7, 1} };\n"
"__constant float c_DY [3][5] = { {2, 0, 7, 3, 1}, {2, 3, 7, 6, -2}, {2, 6, 7, 9, 1} };\n"
"__constant float c_DXY[4][5] = { {1, 1, 4, 4, 1}, {5, 1, 8, 4, -1}, {1, 5, 4, 8, -1}, {5, 5, 8, 8, 1} };\n"
"__inline int calcSize(int octave, int layer)\n"
"{\n"
"const int HAAR_SIZE0 = 9;\n"
"const int HAAR_SIZE_INC = 6;\n"
"return (HAAR_SIZE0 + HAAR_SIZE_INC * layer) << octave;\n"
"}\n"
"__kernel void icvCalcLayerDetAndTrace(\n"
"IMAGE_INT32 sumTex,\n"
"__global float * det,\n"
"__global float * trace,\n"
"int det_step,\n"
"int trace_step,\n"
"int c_img_rows,\n"
"int c_img_cols,\n"
"int c_nOctaveLayers,\n"
"int c_octave,\n"
"int c_layer_rows,\n"
"int sumTex_step\n"
")\n"
"{\n"
"det_step   /= sizeof(*det);\n"
"trace_step /= sizeof(*trace);\n"
"sumTex_step/= sizeof(uint);\n"
"const int gridDim_y  = get_num_groups(1) / (c_nOctaveLayers + 2);\n"
"const int blockIdx_y = get_group_id(1) % gridDim_y;\n"
"const int blockIdx_z = get_group_id(1) / gridDim_y;\n"
"const int j = get_local_id(0) + get_group_id(0) * get_local_size(0);\n"
"const int i = get_local_id(1) + blockIdx_y * get_local_size(1);\n"
"const int layer = blockIdx_z;\n"
"const int size = calcSize(c_octave, layer);\n"
"const int samples_i = 1 + ((c_img_rows - size) >> c_octave);\n"
"const int samples_j = 1 + ((c_img_cols - size) >> c_octave);\n"
"const int margin = (size >> 1) >> c_octave;\n"
"if (size <= c_img_rows && size <= c_img_cols && i < samples_i && j < samples_j)\n"
"{\n"
"const float dx  = icvCalcHaarPatternSum_3(sumTex, c_DX , 9, size, i << c_octave, j << c_octave, c_img_rows, c_img_cols, sumTex_step);\n"
"const float dy  = icvCalcHaarPatternSum_3(sumTex, c_DY , 9, size, i << c_octave, j << c_octave, c_img_rows, c_img_cols, sumTex_step);\n"
"const float dxy = icvCalcHaarPatternSum_4(sumTex, c_DXY, 9, size, i << c_octave, j << c_octave, c_img_rows, c_img_cols, sumTex_step);\n"
"det  [j + margin + det_step   * (layer * c_layer_rows + i + margin)] = dx * dy - 0.81f * dxy * dxy;\n"
"trace[j + margin + trace_step * (layer * c_layer_rows + i + margin)] = dx + dy;\n"
"}\n"
"}\n"
"__constant float c_DM[5] = {0, 0, 9, 9, 1};\n"
"bool within_check(IMAGE_INT32 maskSumTex, int sum_i, int sum_j, int size, int rows, int cols, int step)\n"
"{\n"
"float ratio = (float)size / 9.0f;\n"
"float d = 0;\n"
"int dx1 = convert_int_rte(ratio * c_DM[0]);\n"
"int dy1 = convert_int_rte(ratio * c_DM[1]);\n"
"int dx2 = convert_int_rte(ratio * c_DM[2]);\n"
"int dy2 = convert_int_rte(ratio * c_DM[3]);\n"
"float t = 0;\n"
"t += read_sumTex(maskSumTex, sampler, (int2)(sum_j + dx1, sum_i + dy1), rows, cols, step);\n"
"t -= read_sumTex(maskSumTex, sampler, (int2)(sum_j + dx1, sum_i + dy2), rows, cols, step);\n"
"t -= read_sumTex(maskSumTex, sampler, (int2)(sum_j + dx2, sum_i + dy1), rows, cols, step);\n"
"t += read_sumTex(maskSumTex, sampler, (int2)(sum_j + dx2, sum_i + dy2), rows, cols, step);\n"
"d += t * c_DM[4] / ((dx2 - dx1) * (dy2 - dy1));\n"
"return (d >= 0.5f);\n"
"}\n"
"__kernel\n"
"void icvFindMaximaInLayer_withmask(\n"
"__global const float * det,\n"
"__global const float * trace,\n"
"__global int4 * maxPosBuffer,\n"
"volatile __global int* maxCounter,\n"
"int counter_offset,\n"
"int det_step,\n"
"int trace_step,\n"
"int c_img_rows,\n"
"int c_img_cols,\n"
"int c_nOctaveLayers,\n"
"int c_octave,\n"
"int c_layer_rows,\n"
"int c_layer_cols,\n"
"int c_max_candidates,\n"
"float c_hessianThreshold,\n"
"IMAGE_INT32 maskSumTex,\n"
"int mask_step\n"
")\n"
"{\n"
"volatile __local  float N9[768];\n"
"det_step   /= sizeof(*det);\n"
"trace_step /= sizeof(*trace);\n"
"maxCounter += counter_offset;\n"
"mask_step  /= sizeof(uint);\n"
"const int gridDim_y  = get_num_groups(1) / c_nOctaveLayers;\n"
"const int blockIdx_y = get_group_id(1)   % gridDim_y;\n"
"const int blockIdx_z = get_group_id(1)   / gridDim_y;\n"
"const int layer = blockIdx_z + 1;\n"
"const int size = calcSize(c_octave, layer);\n"
"const int margin = ((calcSize(c_octave, layer + 1) >> 1) >> c_octave) + 1;\n"
"const int j = get_local_id(0) + get_group_id(0) * (get_local_size(0) - 2) + margin - 1;\n"
"const int i = get_local_id(1) + blockIdx_y * (get_local_size(1) - 2) + margin - 1;\n"
"const int zoff = get_local_size(0) * get_local_size(1);\n"
"const int localLin = get_local_id(0) + get_local_id(1) * get_local_size(0) + zoff;\n"
"N9[localLin - zoff] =\n"
"det[det_step *\n"
"(c_layer_rows * (layer - 1) + min(max(i, 0), c_img_rows - 1))\n"
"+ min(max(j, 0), c_img_cols - 1)];\n"
"N9[localLin       ] =\n"
"det[det_step *\n"
"(c_layer_rows * (layer    ) + min(max(i, 0), c_img_rows - 1))\n"
"+ min(max(j, 0), c_img_cols - 1)];\n"
"N9[localLin + zoff] =\n"
"det[det_step *\n"
"(c_layer_rows * (layer + 1) + min(max(i, 0), c_img_rows - 1))\n"
"+ min(max(j, 0), c_img_cols - 1)];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (i < c_layer_rows - margin\n"
"&& j < c_layer_cols - margin\n"
"&& get_local_id(0) > 0\n"
"&& get_local_id(0) < get_local_size(0) - 1\n"
"&& get_local_id(1) > 0\n"
"&& get_local_id(1) < get_local_size(1) - 1\n"
")\n"
"{\n"
"float val0 = N9[localLin];\n"
"if (val0 > c_hessianThreshold)\n"
"{\n"
"const int sum_i = (i - ((size >> 1) >> c_octave)) << c_octave;\n"
"const int sum_j = (j - ((size >> 1) >> c_octave)) << c_octave;\n"
"if (within_check(maskSumTex, sum_i, sum_j, size, c_img_rows, c_img_cols, mask_step))\n"
"{\n"
"const bool condmax = val0 > N9[localLin - 1 - get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin     - get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin + 1 - get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin - 1                     - zoff]\n"
"&&                   val0 > N9[localLin                         - zoff]\n"
"&&                   val0 > N9[localLin + 1                     - zoff]\n"
"&&                   val0 > N9[localLin - 1 + get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin     + get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin + 1 + get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin - 1 - get_local_size(0)]\n"
"&&                   val0 > N9[localLin     - get_local_size(0)]\n"
"&&                   val0 > N9[localLin + 1 - get_local_size(0)]\n"
"&&                   val0 > N9[localLin - 1                    ]\n"
"&&                   val0 > N9[localLin + 1                    ]\n"
"&&                   val0 > N9[localLin - 1 + get_local_size(0)]\n"
"&&                   val0 > N9[localLin     + get_local_size(0)]\n"
"&&                   val0 > N9[localLin + 1 + get_local_size(0)]\n"
"&&                   val0 > N9[localLin - 1 - get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin     - get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin + 1 - get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin - 1                     + zoff]\n"
"&&                   val0 > N9[localLin                         + zoff]\n"
"&&                   val0 > N9[localLin + 1                     + zoff]\n"
"&&                   val0 > N9[localLin - 1 + get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin     + get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin + 1 + get_local_size(0) + zoff]\n"
";\n"
"if(condmax)\n"
"{\n"
"int ind = atomic_inc(maxCounter);\n"
"if (ind < c_max_candidates)\n"
"{\n"
"const int laplacian = (int) copysign(1.0f, trace[trace_step* (layer * c_layer_rows + i) + j]);\n"
"maxPosBuffer[ind] = (int4)(j, i, layer, laplacian);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"__kernel\n"
"void icvFindMaximaInLayer(\n"
"__global float * det,\n"
"__global float * trace,\n"
"__global int4 * maxPosBuffer,\n"
"volatile __global  int* maxCounter,\n"
"int counter_offset,\n"
"int det_step,\n"
"int trace_step,\n"
"int c_img_rows,\n"
"int c_img_cols,\n"
"int c_nOctaveLayers,\n"
"int c_octave,\n"
"int c_layer_rows,\n"
"int c_layer_cols,\n"
"int c_max_candidates,\n"
"float c_hessianThreshold\n"
")\n"
"{\n"
"volatile __local  float N9[768];\n"
"det_step   /= sizeof(float);\n"
"trace_step /= sizeof(float);\n"
"maxCounter += counter_offset;\n"
"const int gridDim_y  = get_num_groups(1) / c_nOctaveLayers;\n"
"const int blockIdx_y = get_group_id(1)   % gridDim_y;\n"
"const int blockIdx_z = get_group_id(1)   / gridDim_y;\n"
"const int layer = blockIdx_z + 1;\n"
"const int size = calcSize(c_octave, layer);\n"
"const int margin = ((calcSize(c_octave, layer + 1) >> 1) >> c_octave) + 1;\n"
"const int j = get_local_id(0) + get_group_id(0) * (get_local_size(0) - 2) + margin - 1;\n"
"const int i = get_local_id(1) + blockIdx_y      * (get_local_size(1) - 2) + margin - 1;\n"
"const int zoff     = get_local_size(0) * get_local_size(1);\n"
"const int localLin = get_local_id(0) + get_local_id(1) * get_local_size(0) + zoff;\n"
"int l_x = min(max(j, 0), c_img_cols - 1);\n"
"int l_y = c_layer_rows * layer + min(max(i, 0), c_img_rows - 1);\n"
"N9[localLin - zoff] =\n"
"det[det_step * (l_y - c_layer_rows) + l_x];\n"
"N9[localLin       ] =\n"
"det[det_step * (l_y               ) + l_x];\n"
"N9[localLin + zoff] =\n"
"det[det_step * (l_y + c_layer_rows) + l_x];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (i < c_layer_rows - margin\n"
"&& j < c_layer_cols - margin\n"
"&& get_local_id(0) > 0\n"
"&& get_local_id(0) < get_local_size(0) - 1\n"
"&& get_local_id(1) > 0\n"
"&& get_local_id(1) < get_local_size(1) - 1\n"
")\n"
"{\n"
"float val0 = N9[localLin];\n"
"if (val0 > c_hessianThreshold)\n"
"{\n"
"const bool condmax = val0 > N9[localLin - 1 - get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin     - get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin + 1 - get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin - 1                     - zoff]\n"
"&&                   val0 > N9[localLin                         - zoff]\n"
"&&                   val0 > N9[localLin + 1                     - zoff]\n"
"&&                   val0 > N9[localLin - 1 + get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin     + get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin + 1 + get_local_size(0) - zoff]\n"
"&&                   val0 > N9[localLin - 1 - get_local_size(0)]\n"
"&&                   val0 > N9[localLin     - get_local_size(0)]\n"
"&&                   val0 > N9[localLin + 1 - get_local_size(0)]\n"
"&&                   val0 > N9[localLin - 1                    ]\n"
"&&                   val0 > N9[localLin + 1                    ]\n"
"&&                   val0 > N9[localLin - 1 + get_local_size(0)]\n"
"&&                   val0 > N9[localLin     + get_local_size(0)]\n"
"&&                   val0 > N9[localLin + 1 + get_local_size(0)]\n"
"&&                   val0 > N9[localLin - 1 - get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin     - get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin + 1 - get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin - 1                     + zoff]\n"
"&&                   val0 > N9[localLin                         + zoff]\n"
"&&                   val0 > N9[localLin + 1                     + zoff]\n"
"&&                   val0 > N9[localLin - 1 + get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin     + get_local_size(0) + zoff]\n"
"&&                   val0 > N9[localLin + 1 + get_local_size(0) + zoff]\n"
";\n"
"if(condmax)\n"
"{\n"
"int ind = atomic_inc(maxCounter);\n"
"if (ind < c_max_candidates)\n"
"{\n"
"const int laplacian = (int) copysign(1.0f, trace[trace_step* (layer * c_layer_rows + i) + j]);\n"
"maxPosBuffer[ind] = (int4)(j, i, layer, laplacian);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"inline bool solve3x3_float(volatile __local  const float A[3][3], volatile __local  const float b[3], volatile __local  float x[3])\n"
"{\n"
"float det = A[0][0] * (A[1][1] * A[2][2] - A[1][2] * A[2][1])\n"
"- A[0][1] * (A[1][0] * A[2][2] - A[1][2] * A[2][0])\n"
"+ A[0][2] * (A[1][0] * A[2][1] - A[1][1] * A[2][0]);\n"
"if (det != 0)\n"
"{\n"
"F invdet = 1.0 / det;\n"
"x[0] = invdet *\n"
"(b[0]    * (A[1][1] * A[2][2] - A[1][2] * A[2][1]) -\n"
"A[0][1] * (b[1]    * A[2][2] - A[1][2] * b[2]   ) +\n"
"A[0][2] * (b[1]    * A[2][1] - A[1][1] * b[2]   ));\n"
"x[1] = invdet *\n"
"(A[0][0] * (b[1]    * A[2][2] - A[1][2] * b[2]   ) -\n"
"b[0]    * (A[1][0] * A[2][2] - A[1][2] * A[2][0]) +\n"
"A[0][2] * (A[1][0] * b[2]    - b[1]    * A[2][0]));\n"
"x[2] = invdet *\n"
"(A[0][0] * (A[1][1] * b[2]    - b[1]    * A[2][1]) -\n"
"A[0][1] * (A[1][0] * b[2]    - b[1]    * A[2][0]) +\n"
"b[0]    * (A[1][0] * A[2][1] - A[1][1] * A[2][0]));\n"
"return true;\n"
"}\n"
"return false;\n"
"}\n"
"#define X_ROW          0\n"
"#define Y_ROW          1\n"
"#define LAPLACIAN_ROW  2\n"
"#define OCTAVE_ROW     3\n"
"#define SIZE_ROW       4\n"
"#define ANGLE_ROW      5\n"
"#define HESSIAN_ROW    6\n"
"#define ROWS_COUNT     7\n"
"__kernel\n"
"void icvInterpolateKeypoint(\n"
"__global const float * det,\n"
"__global const int4 * maxPosBuffer,\n"
"__global float * keypoints,\n"
"volatile __global  int * featureCounter,\n"
"int det_step,\n"
"int keypoints_step,\n"
"int c_img_rows,\n"
"int c_img_cols,\n"
"int c_octave,\n"
"int c_layer_rows,\n"
"int c_max_features\n"
")\n"
"{\n"
"det_step /= sizeof(*det);\n"
"keypoints_step /= sizeof(*keypoints);\n"
"__global float * featureX       = keypoints + X_ROW * keypoints_step;\n"
"__global float * featureY       = keypoints + Y_ROW * keypoints_step;\n"
"__global int * featureLaplacian = (__global int *)keypoints + LAPLACIAN_ROW * keypoints_step;\n"
"__global int * featureOctave    = (__global int *)keypoints + OCTAVE_ROW * keypoints_step;\n"
"__global float * featureSize    = keypoints + SIZE_ROW * keypoints_step;\n"
"__global float * featureHessian = keypoints + HESSIAN_ROW * keypoints_step;\n"
"const int4 maxPos = maxPosBuffer[get_group_id(0)];\n"
"const int j = maxPos.x - 1 + get_local_id(0);\n"
"const int i = maxPos.y - 1 + get_local_id(1);\n"
"const int layer = maxPos.z - 1 + get_local_id(2);\n"
"volatile __local  float N9[3][3][3];\n"
"N9[get_local_id(2)][get_local_id(1)][get_local_id(0)] =\n"
"det[det_step * (c_layer_rows * layer + i) + j];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(0) == 0 && get_local_id(1) == 0 && get_local_id(2) == 0)\n"
"{\n"
"volatile __local  float dD[3];\n"
"dD[0] = -0.5f * (N9[1][1][2] - N9[1][1][0]);\n"
"dD[1] = -0.5f * (N9[1][2][1] - N9[1][0][1]);\n"
"dD[2] = -0.5f * (N9[2][1][1] - N9[0][1][1]);\n"
"volatile __local  float H[3][3];\n"
"H[0][0] = N9[1][1][0] - 2.0f * N9[1][1][1] + N9[1][1][2];\n"
"H[0][1]= 0.25f * (N9[1][2][2] - N9[1][2][0] - N9[1][0][2] + N9[1][0][0]);\n"
"H[0][2]= 0.25f * (N9[2][1][2] - N9[2][1][0] - N9[0][1][2] + N9[0][1][0]);\n"
"H[1][0] = H[0][1];\n"
"H[1][1] = N9[1][0][1] - 2.0f * N9[1][1][1] + N9[1][2][1];\n"
"H[1][2]= 0.25f * (N9[2][2][1] - N9[2][0][1] - N9[0][2][1] + N9[0][0][1]);\n"
"H[2][0] = H[0][2];\n"
"H[2][1] = H[1][2];\n"
"H[2][2] = N9[0][1][1] - 2.0f * N9[1][1][1] + N9[2][1][1];\n"
"volatile __local  float x[3];\n"
"if (solve3x3_float(H, dD, x))\n"
"{\n"
"if (fabs(x[0]) <= 1.f && fabs(x[1]) <= 1.f && fabs(x[2]) <= 1.f)\n"
"{\n"
"const int size = calcSize(c_octave, maxPos.z);\n"
"const int sum_i = (maxPos.y - ((size >> 1) >> c_octave)) << c_octave;\n"
"const int sum_j = (maxPos.x - ((size >> 1) >> c_octave)) << c_octave;\n"
"const float center_i = sum_i + (float)(size - 1) / 2;\n"
"const float center_j = sum_j + (float)(size - 1) / 2;\n"
"const float px = center_j + x[0] * (1 << c_octave);\n"
"const float py = center_i + x[1] * (1 << c_octave);\n"
"const int ds = size - calcSize(c_octave, maxPos.z - 1);\n"
"const float psize = round(size + x[2] * ds);\n"
"const float s = psize * 1.2f / 9.0f;\n"
"const int grad_wav_size = 2 * convert_int_rte(2.0f * s);\n"
"if ((c_img_rows + 1) >= grad_wav_size && (c_img_cols + 1) >= grad_wav_size)\n"
"{\n"
"int ind = atomic_inc(featureCounter);\n"
"if (ind < c_max_features)\n"
"{\n"
"featureX[ind] = px;\n"
"featureY[ind] = py;\n"
"featureLaplacian[ind] = maxPos.w;\n"
"featureOctave[ind] = c_octave;\n"
"featureSize[ind] = psize;\n"
"featureHessian[ind] = N9[1][1][1];\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"#define ORI_SEARCH_INC 5\n"
"#define ORI_WIN        60\n"
"#define ORI_SAMPLES    113\n"
"__constant float c_aptX[ORI_SAMPLES] = {-6, -5, -5, -5, -5, -5, -5, -5, -4, -4, -4, -4, -4, -4, -4, -4, -4, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6};\n"
"__constant float c_aptY[ORI_SAMPLES] = {0, -3, -2, -1, 0, 1, 2, 3, -4, -3, -2, -1, 0, 1, 2, 3, 4, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, -4, -3, -2, -1, 0, 1, 2, 3, 4, -3, -2, -1, 0, 1, 2, 3, 0};\n"
"__constant float c_aptW[ORI_SAMPLES] = {0.001455130288377404f, 0.001707611023448408f, 0.002547456417232752f, 0.003238451667129993f, 0.0035081731621176f,\n"
"0.003238451667129993f, 0.002547456417232752f, 0.001707611023448408f, 0.002003900473937392f, 0.0035081731621176f, 0.005233579315245152f,\n"
"0.00665318313986063f, 0.00720730796456337f, 0.00665318313986063f, 0.005233579315245152f, 0.0035081731621176f,\n"
"0.002003900473937392f, 0.001707611023448408f, 0.0035081731621176f, 0.006141661666333675f, 0.009162282571196556f,\n"
"0.01164754293859005f, 0.01261763460934162f, 0.01164754293859005f, 0.009162282571196556f, 0.006141661666333675f,\n"
"0.0035081731621176f, 0.001707611023448408f, 0.002547456417232752f, 0.005233579315245152f, 0.009162282571196556f,\n"
"0.01366852037608624f, 0.01737609319388866f, 0.0188232995569706f, 0.01737609319388866f, 0.01366852037608624f,\n"
"0.009162282571196556f, 0.005233579315245152f, 0.002547456417232752f, 0.003238451667129993f, 0.00665318313986063f,\n"
"0.01164754293859005f, 0.01737609319388866f, 0.02208934165537357f, 0.02392910048365593f, 0.02208934165537357f,\n"
"0.01737609319388866f, 0.01164754293859005f, 0.00665318313986063f, 0.003238451667129993f, 0.001455130288377404f,\n"
"0.0035081731621176f, 0.00720730796456337f, 0.01261763460934162f, 0.0188232995569706f, 0.02392910048365593f,\n"
"0.02592208795249462f, 0.02392910048365593f, 0.0188232995569706f, 0.01261763460934162f, 0.00720730796456337f,\n"
"0.0035081731621176f, 0.001455130288377404f, 0.003238451667129993f, 0.00665318313986063f, 0.01164754293859005f,\n"
"0.01737609319388866f, 0.02208934165537357f, 0.02392910048365593f, 0.02208934165537357f, 0.01737609319388866f,\n"
"0.01164754293859005f, 0.00665318313986063f, 0.003238451667129993f, 0.002547456417232752f, 0.005233579315245152f,\n"
"0.009162282571196556f, 0.01366852037608624f, 0.01737609319388866f, 0.0188232995569706f, 0.01737609319388866f,\n"
"0.01366852037608624f, 0.009162282571196556f, 0.005233579315245152f, 0.002547456417232752f, 0.001707611023448408f,\n"
"0.0035081731621176f, 0.006141661666333675f, 0.009162282571196556f, 0.01164754293859005f, 0.01261763460934162f,\n"
"0.01164754293859005f, 0.009162282571196556f, 0.006141661666333675f, 0.0035081731621176f, 0.001707611023448408f,\n"
"0.002003900473937392f, 0.0035081731621176f, 0.005233579315245152f, 0.00665318313986063f, 0.00720730796456337f,\n"
"0.00665318313986063f, 0.005233579315245152f, 0.0035081731621176f, 0.002003900473937392f, 0.001707611023448408f,\n"
"0.002547456417232752f, 0.003238451667129993f, 0.0035081731621176f, 0.003238451667129993f, 0.002547456417232752f,\n"
"0.001707611023448408f, 0.001455130288377404f};\n"
"__constant float c_NX[2][5] = {{0, 0, 2, 4, -1}, {2, 0, 4, 4, 1}};\n"
"__constant float c_NY[2][5] = {{0, 0, 4, 2, 1}, {0, 2, 4, 4, -1}};\n"
"void reduce_32_sum(volatile __local  float * data, volatile float* partial_reduction, int tid)\n"
"{\n"
"#define op(A, B) (*A)+(B)\n"
"data[tid] = *partial_reduction;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 1\n"
"#endif\n"
"if (tid < 16)\n"
"{\n"
"data[tid] = *partial_reduction = op(partial_reduction, data[tid + 16]);\n"
"#if WAVE_SIZE < 16\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"#endif\n"
"data[tid] = *partial_reduction = op(partial_reduction, data[tid + 8 ]);\n"
"#if WAVE_SIZE < 8\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 4)\n"
"{\n"
"#endif\n"
"data[tid] = *partial_reduction = op(partial_reduction, data[tid + 4 ]);\n"
"#if WAVE_SIZE < 4\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 2)\n"
"{\n"
"#endif\n"
"data[tid] = *partial_reduction = op(partial_reduction, data[tid + 2 ]);\n"
"#if WAVE_SIZE < 2\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 1)\n"
"{\n"
"#endif\n"
"data[tid] = *partial_reduction = op(partial_reduction, data[tid + 1 ]);\n"
"}\n"
"#undef WAVE_SIZE\n"
"#undef op\n"
"}\n"
"__kernel\n"
"void icvCalcOrientation(\n"
"IMAGE_INT32 sumTex,\n"
"__global float * keypoints,\n"
"int keypoints_step,\n"
"int c_img_rows,\n"
"int c_img_cols,\n"
"int sum_step\n"
")\n"
"{\n"
"keypoints_step /= sizeof(*keypoints);\n"
"sum_step       /= sizeof(uint);\n"
"__global float* featureX    = keypoints + X_ROW * keypoints_step;\n"
"__global float* featureY    = keypoints + Y_ROW * keypoints_step;\n"
"__global float* featureSize = keypoints + SIZE_ROW * keypoints_step;\n"
"__global float* featureDir  = keypoints + ANGLE_ROW * keypoints_step;\n"
"volatile __local  float s_X[128];\n"
"volatile __local  float s_Y[128];\n"
"volatile __local  float s_angle[128];\n"
"volatile __local  float s_sumx[32 * 4];\n"
"volatile __local  float s_sumy[32 * 4];\n"
"const float s = featureSize[get_group_id(0)] * 1.2f / 9.0f;\n"
"const int grad_wav_size = 2 * convert_int_rte(2.0f * s);\n"
"if ((c_img_rows + 1) < grad_wav_size || (c_img_cols + 1) < grad_wav_size)\n"
"return;\n"
"const int tid = get_local_id(1) * get_local_size(0) + get_local_id(0);\n"
"float X = 0.0f, Y = 0.0f, angle = 0.0f;\n"
"if (tid < ORI_SAMPLES)\n"
"{\n"
"const float margin = (float)(grad_wav_size - 1) / 2.0f;\n"
"const int x = convert_int_rte(featureX[get_group_id(0)] + c_aptX[tid] * s - margin);\n"
"const int y = convert_int_rte(featureY[get_group_id(0)] + c_aptY[tid] * s - margin);\n"
"if (y >= 0 && y < (c_img_rows + 1) - grad_wav_size &&\n"
"x >= 0 && x < (c_img_cols + 1) - grad_wav_size)\n"
"{\n"
"X = c_aptW[tid] * icvCalcHaarPatternSum_2(sumTex, c_NX, 4, grad_wav_size, y, x, c_img_rows, c_img_cols, sum_step);\n"
"Y = c_aptW[tid] * icvCalcHaarPatternSum_2(sumTex, c_NY, 4, grad_wav_size, y, x, c_img_rows, c_img_cols, sum_step);\n"
"angle = atan2(Y, X);\n"
"if (angle < 0)\n"
"angle += 2.0f * CV_PI_F;\n"
"angle *= 180.0f / CV_PI_F;\n"
"}\n"
"}\n"
"s_X[tid] = X;\n"
"s_Y[tid] = Y;\n"
"s_angle[tid] = angle;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"float bestx = 0, besty = 0, best_mod = 0;\n"
"#pragma unroll\n"
"for (int i = 0; i < 18; ++i)\n"
"{\n"
"const int dir = (i * 4 + get_local_id(1)) * ORI_SEARCH_INC;\n"
"volatile float sumx = 0.0f, sumy = 0.0f;\n"
"int d = abs(convert_int_rte(s_angle[get_local_id(0)]) - dir);\n"
"if (d < ORI_WIN / 2 || d > 360 - ORI_WIN / 2)\n"
"{\n"
"sumx = s_X[get_local_id(0)];\n"
"sumy = s_Y[get_local_id(0)];\n"
"}\n"
"d = abs(convert_int_rte(s_angle[get_local_id(0) + 32]) - dir);\n"
"if (d < ORI_WIN / 2 || d > 360 - ORI_WIN / 2)\n"
"{\n"
"sumx += s_X[get_local_id(0) + 32];\n"
"sumy += s_Y[get_local_id(0) + 32];\n"
"}\n"
"d = abs(convert_int_rte(s_angle[get_local_id(0) + 64]) - dir);\n"
"if (d < ORI_WIN / 2 || d > 360 - ORI_WIN / 2)\n"
"{\n"
"sumx += s_X[get_local_id(0) + 64];\n"
"sumy += s_Y[get_local_id(0) + 64];\n"
"}\n"
"d = abs(convert_int_rte(s_angle[get_local_id(0) + 96]) - dir);\n"
"if (d < ORI_WIN / 2 || d > 360 - ORI_WIN / 2)\n"
"{\n"
"sumx += s_X[get_local_id(0) + 96];\n"
"sumy += s_Y[get_local_id(0) + 96];\n"
"}\n"
"reduce_32_sum(s_sumx + get_local_id(1) * 32, &sumx, get_local_id(0));\n"
"reduce_32_sum(s_sumy + get_local_id(1) * 32, &sumy, get_local_id(0));\n"
"const float temp_mod = sumx * sumx + sumy * sumy;\n"
"if (temp_mod > best_mod)\n"
"{\n"
"best_mod = temp_mod;\n"
"bestx = sumx;\n"
"besty = sumy;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (get_local_id(0) == 0)\n"
"{\n"
"s_X[get_local_id(1)] = bestx;\n"
"s_Y[get_local_id(1)] = besty;\n"
"s_angle[get_local_id(1)] = best_mod;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(1) == 0 && get_local_id(0) == 0)\n"
"{\n"
"int bestIdx = 0;\n"
"if (s_angle[1] > s_angle[bestIdx])\n"
"bestIdx = 1;\n"
"if (s_angle[2] > s_angle[bestIdx])\n"
"bestIdx = 2;\n"
"if (s_angle[3] > s_angle[bestIdx])\n"
"bestIdx = 3;\n"
"float kp_dir = atan2(s_Y[bestIdx], s_X[bestIdx]);\n"
"if (kp_dir < 0)\n"
"kp_dir += 2.0f * CV_PI_F;\n"
"kp_dir *= 180.0f / CV_PI_F;\n"
"kp_dir = 360.0f - kp_dir;\n"
"if (fabs(kp_dir - 360.f) < FLT_EPSILON)\n"
"kp_dir = 0.f;\n"
"featureDir[get_group_id(0)] = kp_dir;\n"
"}\n"
"}\n"
"__kernel\n"
"void icvSetUpright(\n"
"__global float * keypoints,\n"
"int keypoints_step,\n"
"int nFeatures\n"
")\n"
"{\n"
"keypoints_step /= sizeof(*keypoints);\n"
"__global float* featureDir  = keypoints + ANGLE_ROW * keypoints_step;\n"
"if(get_global_id(0) <= nFeatures)\n"
"{\n"
"featureDir[get_global_id(0)] = 270.0f;\n"
"}\n"
"}\n"
"#undef ORI_SEARCH_INC\n"
"#undef ORI_WIN\n"
"#undef ORI_SAMPLES\n"
"#define PATCH_SZ 20\n"
"__constant float c_DW[PATCH_SZ * PATCH_SZ] =\n"
"{\n"
"3.695352233989979e-006f, 8.444558261544444e-006f, 1.760426494001877e-005f, 3.34794785885606e-005f, 5.808438800158911e-005f, 9.193058212986216e-005f, 0.0001327334757661447f, 0.0001748319627949968f, 0.0002100782439811155f, 0.0002302826324012131f, 0.0002302826324012131f, 0.0002100782439811155f, 0.0001748319627949968f, 0.0001327334757661447f, 9.193058212986216e-005f, 5.808438800158911e-005f, 3.34794785885606e-005f, 1.760426494001877e-005f, 8.444558261544444e-006f, 3.695352233989979e-006f,\n"
"8.444558261544444e-006f, 1.929736572492402e-005f, 4.022897701361217e-005f, 7.650675252079964e-005f, 0.0001327334903180599f, 0.0002100782585330308f, 0.0003033203829545528f, 0.0003995231236331165f, 0.0004800673632416874f, 0.0005262381164357066f, 0.0005262381164357066f, 0.0004800673632416874f, 0.0003995231236331165f, 0.0003033203829545528f, 0.0002100782585330308f, 0.0001327334903180599f, 7.650675252079964e-005f, 4.022897701361217e-005f, 1.929736572492402e-005f, 8.444558261544444e-006f,\n"
"1.760426494001877e-005f, 4.022897701361217e-005f, 8.386484114453197e-005f, 0.0001594926579855382f, 0.0002767078403849155f, 0.0004379475140012801f, 0.0006323281559161842f, 0.0008328808471560478f, 0.001000790391117334f, 0.001097041997127235f, 0.001097041997127235f, 0.001000790391117334f, 0.0008328808471560478f, 0.0006323281559161842f, 0.0004379475140012801f, 0.0002767078403849155f, 0.0001594926579855382f, 8.386484114453197e-005f, 4.022897701361217e-005f, 1.760426494001877e-005f,\n"
"3.34794785885606e-005f, 7.650675252079964e-005f, 0.0001594926579855382f, 0.0003033203247468919f, 0.0005262380582280457f, 0.0008328807889483869f, 0.001202550483867526f, 0.001583957928232849f, 0.001903285388834775f, 0.002086334861814976f, 0.002086334861814976f, 0.001903285388834775f, 0.001583957928232849f, 0.001202550483867526f, 0.0008328807889483869f, 0.0005262380582280457f, 0.0003033203247468919f, 0.0001594926579855382f, 7.650675252079964e-005f, 3.34794785885606e-005f,\n"
"5.808438800158911e-005f, 0.0001327334903180599f, 0.0002767078403849155f, 0.0005262380582280457f, 0.0009129836107604206f, 0.001444985857233405f, 0.002086335094645619f, 0.002748048631474376f, 0.00330205773934722f, 0.003619635012000799f, 0.003619635012000799f, 0.00330205773934722f, 0.002748048631474376f, 0.002086335094645619f, 0.001444985857233405f, 0.0009129836107604206f, 0.0005262380582280457f, 0.0002767078403849155f, 0.0001327334903180599f, 5.808438800158911e-005f,\n"
"9.193058212986216e-005f, 0.0002100782585330308f, 0.0004379475140012801f, 0.0008328807889483869f, 0.001444985857233405f, 0.002286989474669099f, 0.00330205773934722f, 0.004349356517195702f, 0.00522619066759944f, 0.005728822201490402f, 0.005728822201490402f, 0.00522619066759944f, 0.004349356517195702f, 0.00330205773934722f, 0.002286989474669099f, 0.001444985857233405f, 0.0008328807889483869f, 0.0004379475140012801f, 0.0002100782585330308f, 9.193058212986216e-005f,\n"
"0.0001327334757661447f, 0.0003033203829545528f, 0.0006323281559161842f, 0.001202550483867526f, 0.002086335094645619f, 0.00330205773934722f, 0.004767658654600382f, 0.006279794964939356f, 0.007545807864516974f, 0.008271530270576477f, 0.008271530270576477f, 0.007545807864516974f, 0.006279794964939356f, 0.004767658654600382f, 0.00330205773934722f, 0.002086335094645619f, 0.001202550483867526f, 0.0006323281559161842f, 0.0003033203829545528f, 0.0001327334757661447f,\n"
"0.0001748319627949968f, 0.0003995231236331165f, 0.0008328808471560478f, 0.001583957928232849f, 0.002748048631474376f, 0.004349356517195702f, 0.006279794964939356f, 0.008271529339253902f, 0.009939077310264111f, 0.01089497376233339f, 0.01089497376233339f, 0.009939077310264111f, 0.008271529339253902f, 0.006279794964939356f, 0.004349356517195702f, 0.002748048631474376f, 0.001583957928232849f, 0.0008328808471560478f, 0.0003995231236331165f, 0.0001748319627949968f,\n"
"0.0002100782439811155f, 0.0004800673632416874f, 0.001000790391117334f, 0.001903285388834775f, 0.00330205773934722f, 0.00522619066759944f, 0.007545807864516974f, 0.009939077310264111f, 0.01194280479103327f, 0.01309141051024199f, 0.01309141051024199f, 0.01194280479103327f, 0.009939077310264111f, 0.007545807864516974f, 0.00522619066759944f, 0.00330205773934722f, 0.001903285388834775f, 0.001000790391117334f, 0.0004800673632416874f, 0.0002100782439811155f,\n"
"0.0002302826324012131f, 0.0005262381164357066f, 0.001097041997127235f, 0.002086334861814976f, 0.003619635012000799f, 0.005728822201490402f, 0.008271530270576477f, 0.01089497376233339f, 0.01309141051024199f, 0.01435048412531614f, 0.01435048412531614f, 0.01309141051024199f, 0.01089497376233339f, 0.008271530270576477f, 0.005728822201490402f, 0.003619635012000799f, 0.002086334861814976f, 0.001097041997127235f, 0.0005262381164357066f, 0.0002302826324012131f,\n"
"0.0002302826324012131f, 0.0005262381164357066f, 0.001097041997127235f, 0.002086334861814976f, 0.003619635012000799f, 0.005728822201490402f, 0.008271530270576477f, 0.01089497376233339f, 0.01309141051024199f, 0.01435048412531614f, 0.01435048412531614f, 0.01309141051024199f, 0.01089497376233339f, 0.008271530270576477f, 0.005728822201490402f, 0.003619635012000799f, 0.002086334861814976f, 0.001097041997127235f, 0.0005262381164357066f, 0.0002302826324012131f,\n"
"0.0002100782439811155f, 0.0004800673632416874f, 0.001000790391117334f, 0.001903285388834775f, 0.00330205773934722f, 0.00522619066759944f, 0.007545807864516974f, 0.009939077310264111f, 0.01194280479103327f, 0.01309141051024199f, 0.01309141051024199f, 0.01194280479103327f, 0.009939077310264111f, 0.007545807864516974f, 0.00522619066759944f, 0.00330205773934722f, 0.001903285388834775f, 0.001000790391117334f, 0.0004800673632416874f, 0.0002100782439811155f,\n"
"0.0001748319627949968f, 0.0003995231236331165f, 0.0008328808471560478f, 0.001583957928232849f, 0.002748048631474376f, 0.004349356517195702f, 0.006279794964939356f, 0.008271529339253902f, 0.009939077310264111f, 0.01089497376233339f, 0.01089497376233339f, 0.009939077310264111f, 0.008271529339253902f, 0.006279794964939356f, 0.004349356517195702f, 0.002748048631474376f, 0.001583957928232849f, 0.0008328808471560478f, 0.0003995231236331165f, 0.0001748319627949968f,\n"
"0.0001327334757661447f, 0.0003033203829545528f, 0.0006323281559161842f, 0.001202550483867526f, 0.002086335094645619f, 0.00330205773934722f, 0.004767658654600382f, 0.006279794964939356f, 0.007545807864516974f, 0.008271530270576477f, 0.008271530270576477f, 0.007545807864516974f, 0.006279794964939356f, 0.004767658654600382f, 0.00330205773934722f, 0.002086335094645619f, 0.001202550483867526f, 0.0006323281559161842f, 0.0003033203829545528f, 0.0001327334757661447f,\n"
"9.193058212986216e-005f, 0.0002100782585330308f, 0.0004379475140012801f, 0.0008328807889483869f, 0.001444985857233405f, 0.002286989474669099f, 0.00330205773934722f, 0.004349356517195702f, 0.00522619066759944f, 0.005728822201490402f, 0.005728822201490402f, 0.00522619066759944f, 0.004349356517195702f, 0.00330205773934722f, 0.002286989474669099f, 0.001444985857233405f, 0.0008328807889483869f, 0.0004379475140012801f, 0.0002100782585330308f, 9.193058212986216e-005f,\n"
"5.808438800158911e-005f, 0.0001327334903180599f, 0.0002767078403849155f, 0.0005262380582280457f, 0.0009129836107604206f, 0.001444985857233405f, 0.002086335094645619f, 0.002748048631474376f, 0.00330205773934722f, 0.003619635012000799f, 0.003619635012000799f, 0.00330205773934722f, 0.002748048631474376f, 0.002086335094645619f, 0.001444985857233405f, 0.0009129836107604206f, 0.0005262380582280457f, 0.0002767078403849155f, 0.0001327334903180599f, 5.808438800158911e-005f,\n"
"3.34794785885606e-005f, 7.650675252079964e-005f, 0.0001594926579855382f, 0.0003033203247468919f, 0.0005262380582280457f, 0.0008328807889483869f, 0.001202550483867526f, 0.001583957928232849f, 0.001903285388834775f, 0.002086334861814976f, 0.002086334861814976f, 0.001903285388834775f, 0.001583957928232849f, 0.001202550483867526f, 0.0008328807889483869f, 0.0005262380582280457f, 0.0003033203247468919f, 0.0001594926579855382f, 7.650675252079964e-005f, 3.34794785885606e-005f,\n"
"1.760426494001877e-005f, 4.022897701361217e-005f, 8.386484114453197e-005f, 0.0001594926579855382f, 0.0002767078403849155f, 0.0004379475140012801f, 0.0006323281559161842f, 0.0008328808471560478f, 0.001000790391117334f, 0.001097041997127235f, 0.001097041997127235f, 0.001000790391117334f, 0.0008328808471560478f, 0.0006323281559161842f, 0.0004379475140012801f, 0.0002767078403849155f, 0.0001594926579855382f, 8.386484114453197e-005f, 4.022897701361217e-005f, 1.760426494001877e-005f,\n"
"8.444558261544444e-006f, 1.929736572492402e-005f, 4.022897701361217e-005f, 7.650675252079964e-005f, 0.0001327334903180599f, 0.0002100782585330308f, 0.0003033203829545528f, 0.0003995231236331165f, 0.0004800673632416874f, 0.0005262381164357066f, 0.0005262381164357066f, 0.0004800673632416874f, 0.0003995231236331165f, 0.0003033203829545528f, 0.0002100782585330308f, 0.0001327334903180599f, 7.650675252079964e-005f, 4.022897701361217e-005f, 1.929736572492402e-005f, 8.444558261544444e-006f,\n"
"3.695352233989979e-006f, 8.444558261544444e-006f, 1.760426494001877e-005f, 3.34794785885606e-005f, 5.808438800158911e-005f, 9.193058212986216e-005f, 0.0001327334757661447f, 0.0001748319627949968f, 0.0002100782439811155f, 0.0002302826324012131f, 0.0002302826324012131f, 0.0002100782439811155f, 0.0001748319627949968f, 0.0001327334757661447f, 9.193058212986216e-005f, 5.808438800158911e-005f, 3.34794785885606e-005f, 1.760426494001877e-005f, 8.444558261544444e-006f, 3.695352233989979e-006f\n"
"};\n"
"inline uchar readerGet(\n"
"IMAGE_INT8 src,\n"
"const float centerX, const float centerY, const float win_offset, const float cos_dir, const float sin_dir,\n"
"int i, int j, int rows, int cols, int elemPerRow\n"
")\n"
"{\n"
"float pixel_x = centerX + (win_offset + j) * cos_dir + (win_offset + i) * sin_dir;\n"
"float pixel_y = centerY - (win_offset + j) * sin_dir + (win_offset + i) * cos_dir;\n"
"return read_imgTex(src, sampler, (float2)(pixel_x, pixel_y), rows, cols, elemPerRow);\n"
"}\n"
"inline float linearFilter(\n"
"IMAGE_INT8 src,\n"
"const float centerX, const float centerY, const float win_offset, const float cos_dir, const float sin_dir,\n"
"float y, float x, int rows, int cols, int elemPerRow\n"
")\n"
"{\n"
"x -= 0.5f;\n"
"y -= 0.5f;\n"
"float out = 0.0f;\n"
"const int x1 = convert_int_rtn(x);\n"
"const int y1 = convert_int_rtn(y);\n"
"const int x2 = x1 + 1;\n"
"const int y2 = y1 + 1;\n"
"uchar src_reg = readerGet(src, centerX, centerY, win_offset, cos_dir, sin_dir, y1, x1, rows, cols, elemPerRow);\n"
"out = out + src_reg * ((x2 - x) * (y2 - y));\n"
"src_reg = readerGet(src, centerX, centerY, win_offset, cos_dir, sin_dir, y1, x2, rows, cols, elemPerRow);\n"
"out = out + src_reg * ((x - x1) * (y2 - y));\n"
"src_reg = readerGet(src, centerX, centerY, win_offset, cos_dir, sin_dir, y2, x1, rows, cols, elemPerRow);\n"
"out = out + src_reg * ((x2 - x) * (y - y1));\n"
"src_reg = readerGet(src, centerX, centerY, win_offset, cos_dir, sin_dir, y2, x2, rows, cols, elemPerRow);\n"
"out = out + src_reg * ((x - x1) * (y - y1));\n"
"return out;\n"
"}\n"
"void calc_dx_dy(\n"
"IMAGE_INT8 imgTex,\n"
"volatile __local  float s_dx_bin[25],\n"
"volatile __local  float s_dy_bin[25],\n"
"volatile __local  float s_PATCH[6][6],\n"
"__global const float* featureX,\n"
"__global const float* featureY,\n"
"__global const float* featureSize,\n"
"__global const float* featureDir,\n"
"int rows,\n"
"int cols,\n"
"int elemPerRow\n"
")\n"
"{\n"
"const float centerX = featureX[get_group_id(0)];\n"
"const float centerY = featureY[get_group_id(0)];\n"
"const float size = featureSize[get_group_id(0)];\n"
"float descriptor_dir = 360.0f - featureDir[get_group_id(0)];\n"
"if(fabs(descriptor_dir - 360.0f) < FLT_EPSILON)\n"
"{\n"
"descriptor_dir = 0.0f;\n"
"}\n"
"descriptor_dir *= (float)(CV_PI_F / 180.0f);\n"
"const float s = size * 1.2f / 9.0f;\n"
"const int win_size = (int)((PATCH_SZ + 1) * s);\n"
"float sin_dir;\n"
"float cos_dir;\n"
"sin_dir = sincos(descriptor_dir, &cos_dir);\n"
"const float win_offset = -(float)(win_size - 1) / 2;\n"
"const int xBlock = (get_group_id(1) & 3);\n"
"const int yBlock = (get_group_id(1) >> 2);\n"
"const int xIndex = xBlock * 5 + get_local_id(0);\n"
"const int yIndex = yBlock * 5 + get_local_id(1);\n"
"const float icoo = ((float)yIndex / (PATCH_SZ + 1)) * win_size;\n"
"const float jcoo = ((float)xIndex / (PATCH_SZ + 1)) * win_size;\n"
"s_PATCH[get_local_id(1)][get_local_id(0)] = linearFilter(imgTex, centerX, centerY, win_offset, cos_dir, sin_dir, icoo, jcoo, rows, cols, elemPerRow);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(0) < 5 && get_local_id(1) < 5)\n"
"{\n"
"const int tid = get_local_id(1) * 5 + get_local_id(0);\n"
"const float dw = c_DW[yIndex * PATCH_SZ + xIndex];\n"
"const float vx = (\n"
"s_PATCH[get_local_id(1)    ][get_local_id(0) + 1] -\n"
"s_PATCH[get_local_id(1)    ][get_local_id(0)    ] +\n"
"s_PATCH[get_local_id(1) + 1][get_local_id(0) + 1] -\n"
"s_PATCH[get_local_id(1) + 1][get_local_id(0)    ])\n"
"* dw;\n"
"const float vy = (\n"
"s_PATCH[get_local_id(1) + 1][get_local_id(0)    ] -\n"
"s_PATCH[get_local_id(1)    ][get_local_id(0)    ] +\n"
"s_PATCH[get_local_id(1) + 1][get_local_id(0) + 1] -\n"
"s_PATCH[get_local_id(1)    ][get_local_id(0) + 1])\n"
"* dw;\n"
"s_dx_bin[tid] = vx;\n"
"s_dy_bin[tid] = vy;\n"
"}\n"
"}\n"
"void reduce_sum25(\n"
"volatile __local  float* sdata1,\n"
"volatile __local  float* sdata2,\n"
"volatile __local  float* sdata3,\n"
"volatile __local  float* sdata4,\n"
"int tid\n"
")\n"
"{\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 1\n"
"#endif\n"
"if (tid < 9)\n"
"{\n"
"sdata1[tid] += sdata1[tid + 16];\n"
"sdata2[tid] += sdata2[tid + 16];\n"
"sdata3[tid] += sdata3[tid + 16];\n"
"sdata4[tid] += sdata4[tid + 16];\n"
"#if WAVE_SIZE < 16\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"#endif\n"
"sdata1[tid] += sdata1[tid + 8];\n"
"sdata2[tid] += sdata2[tid + 8];\n"
"sdata3[tid] += sdata3[tid + 8];\n"
"sdata4[tid] += sdata4[tid + 8];\n"
"#if WAVE_SIZE < 8\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 4)\n"
"{\n"
"#endif\n"
"sdata1[tid] += sdata1[tid + 4];\n"
"sdata2[tid] += sdata2[tid + 4];\n"
"sdata3[tid] += sdata3[tid + 4];\n"
"sdata4[tid] += sdata4[tid + 4];\n"
"#if WAVE_SIZE < 4\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 2)\n"
"{\n"
"#endif\n"
"sdata1[tid] += sdata1[tid + 2];\n"
"sdata2[tid] += sdata2[tid + 2];\n"
"sdata3[tid] += sdata3[tid + 2];\n"
"sdata4[tid] += sdata4[tid + 2];\n"
"#if WAVE_SIZE < 2\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 1)\n"
"{\n"
"#endif\n"
"sdata1[tid] += sdata1[tid + 1];\n"
"sdata2[tid] += sdata2[tid + 1];\n"
"sdata3[tid] += sdata3[tid + 1];\n"
"sdata4[tid] += sdata4[tid + 1];\n"
"}\n"
"#undef WAVE_SIZE\n"
"}\n"
"__kernel\n"
"void compute_descriptors64(\n"
"IMAGE_INT8 imgTex,\n"
"__global float * descriptors,\n"
"__global const float * keypoints,\n"
"int descriptors_step,\n"
"int keypoints_step,\n"
"int rows,\n"
"int cols,\n"
"int img_step\n"
")\n"
"{\n"
"descriptors_step /= sizeof(float);\n"
"keypoints_step   /= sizeof(float);\n"
"__global const float * featureX    = keypoints + X_ROW * keypoints_step;\n"
"__global const float * featureY    = keypoints + Y_ROW * keypoints_step;\n"
"__global const float * featureSize = keypoints + SIZE_ROW * keypoints_step;\n"
"__global const float * featureDir  = keypoints + ANGLE_ROW * keypoints_step;\n"
"volatile __local  float sdx[25];\n"
"volatile __local  float sdy[25];\n"
"volatile __local  float sdxabs[25];\n"
"volatile __local  float sdyabs[25];\n"
"volatile __local  float s_PATCH[6][6];\n"
"calc_dx_dy(imgTex, sdx, sdy, s_PATCH, featureX, featureY, featureSize, featureDir, rows, cols, img_step);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"const int tid = get_local_id(1) * get_local_size(0) + get_local_id(0);\n"
"if (tid < 25)\n"
"{\n"
"sdxabs[tid] = fabs(sdx[tid]);\n"
"sdyabs[tid] = fabs(sdy[tid]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"reduce_sum25(sdx, sdy, sdxabs, sdyabs, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 25)\n"
"{\n"
"__global float* descriptors_block = descriptors + descriptors_step * get_group_id(0) + (get_group_id(1) << 2);\n"
"if (tid == 0)\n"
"{\n"
"descriptors_block[0] = sdx[0];\n"
"descriptors_block[1] = sdy[0];\n"
"descriptors_block[2] = sdxabs[0];\n"
"descriptors_block[3] = sdyabs[0];\n"
"}\n"
"}\n"
"}\n"
"__kernel\n"
"void compute_descriptors128(\n"
"IMAGE_INT8 imgTex,\n"
"__global float * descriptors,\n"
"__global float * keypoints,\n"
"int descriptors_step,\n"
"int keypoints_step,\n"
"int rows,\n"
"int cols,\n"
"int img_step\n"
")\n"
"{\n"
"descriptors_step /= sizeof(*descriptors);\n"
"keypoints_step   /= sizeof(*keypoints);\n"
"__global float * featureX   = keypoints + X_ROW * keypoints_step;\n"
"__global float * featureY   = keypoints + Y_ROW * keypoints_step;\n"
"__global float* featureSize = keypoints + SIZE_ROW * keypoints_step;\n"
"__global float* featureDir  = keypoints + ANGLE_ROW * keypoints_step;\n"
"volatile __local  float sdx[25];\n"
"volatile __local  float sdy[25];\n"
"volatile __local  float sd1[25];\n"
"volatile __local  float sd2[25];\n"
"volatile __local  float sdabs1[25];\n"
"volatile __local  float sdabs2[25];\n"
"volatile __local  float s_PATCH[6][6];\n"
"calc_dx_dy(imgTex, sdx, sdy, s_PATCH, featureX, featureY, featureSize, featureDir, rows, cols, img_step);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"const int tid = get_local_id(1) * get_local_size(0) + get_local_id(0);\n"
"if (tid < 25)\n"
"{\n"
"if (sdy[tid] >= 0)\n"
"{\n"
"sd1[tid] = sdx[tid];\n"
"sdabs1[tid] = fabs(sdx[tid]);\n"
"sd2[tid] = 0;\n"
"sdabs2[tid] = 0;\n"
"}\n"
"else\n"
"{\n"
"sd1[tid] = 0;\n"
"sdabs1[tid] = 0;\n"
"sd2[tid] = sdx[tid];\n"
"sdabs2[tid] = fabs(sdx[tid]);\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"reduce_sum25(sd1, sd2, sdabs1, sdabs2, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"__global float* descriptors_block = descriptors + descriptors_step * get_group_id(0) + (get_group_id(1) << 3);\n"
"if (tid < 25)\n"
"{\n"
"if (tid == 0)\n"
"{\n"
"descriptors_block[0] = sd1[0];\n"
"descriptors_block[1] = sdabs1[0];\n"
"descriptors_block[2] = sd2[0];\n"
"descriptors_block[3] = sdabs2[0];\n"
"}\n"
"if (sdx[tid] >= 0)\n"
"{\n"
"sd1[tid] = sdy[tid];\n"
"sdabs1[tid] = fabs(sdy[tid]);\n"
"sd2[tid] = 0;\n"
"sdabs2[tid] = 0;\n"
"}\n"
"else\n"
"{\n"
"sd1[tid] = 0;\n"
"sdabs1[tid] = 0;\n"
"sd2[tid] = sdy[tid];\n"
"sdabs2[tid] = fabs(sdy[tid]);\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"reduce_sum25(sd1, sd2, sdabs1, sdabs2, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 25)\n"
"{\n"
"if (tid == 0)\n"
"{\n"
"descriptors_block[4] = sd1[0];\n"
"descriptors_block[5] = sdabs1[0];\n"
"descriptors_block[6] = sd2[0];\n"
"descriptors_block[7] = sdabs2[0];\n"
"}\n"
"}\n"
"}\n"
"void reduce_sum128(volatile __local  float* smem, int tid)\n"
"{\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 1\n"
"#endif\n"
"if (tid < 64)\n"
"{\n"
"smem[tid] += smem[tid + 64];\n"
"#if WAVE_SIZE < 64\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 32) \n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 32];\n"
"#if WAVE_SIZE < 32\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16) \n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 16];\n"
"#if WAVE_SIZE < 16\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 8];\n"
"#if WAVE_SIZE < 8\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 4)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 4];\n"
"#if WAVE_SIZE < 4\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 2)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 2];\n"
"#if WAVE_SIZE < 2\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 1)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 1];\n"
"}\n"
"}\n"
"void reduce_sum64(volatile __local  float* smem, int tid)\n"
"{\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 1\n"
"#endif\n"
"if (tid < 32)\n"
"{\n"
"smem[tid] += smem[tid + 32];\n"
"#if WAVE_SIZE < 32\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16) \n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 16];\n"
"#if WAVE_SIZE < 16\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 8];\n"
"#if WAVE_SIZE < 8\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 4)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 4];\n"
"#if WAVE_SIZE < 4\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 2)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 2];\n"
"#if WAVE_SIZE < 2\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 1)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 1];\n"
"}\n"
"}\n"
"__kernel\n"
"void normalize_descriptors128(__global float * descriptors, int descriptors_step)\n"
"{\n"
"descriptors_step /= sizeof(*descriptors);\n"
"__global float* descriptor_base = descriptors + descriptors_step * get_group_id(0);\n"
"volatile __local  float sqDesc[128];\n"
"const float lookup = descriptor_base[get_local_id(0)];\n"
"sqDesc[get_local_id(0)] = lookup * lookup;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"reduce_sum128(sqDesc, get_local_id(0));\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"volatile __local  float len;\n"
"if (get_local_id(0) == 0)\n"
"{\n"
"len = sqrt(sqDesc[0]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"descriptor_base[get_local_id(0)] = lookup / len;\n"
"}\n"
"__kernel\n"
"void normalize_descriptors64(__global float * descriptors, int descriptors_step)\n"
"{\n"
"descriptors_step /= sizeof(*descriptors);\n"
"__global float* descriptor_base = descriptors + descriptors_step * get_group_id(0);\n"
"volatile __local  float sqDesc[64];\n"
"const float lookup = descriptor_base[get_local_id(0)];\n"
"sqDesc[get_local_id(0)] = lookup * lookup;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"reduce_sum64(sqDesc, get_local_id(0));\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"volatile __local  float len;\n"
"if (get_local_id(0) == 0)\n"
"{\n"
"len = sqrt(sqDesc[0]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"descriptor_base[get_local_id(0)] = lookup / len;\n"
"}\n"
;
}
}
